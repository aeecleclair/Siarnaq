/**
 * Generated by @openapi-codegen
 *
 * @version 2.4.1-alpha
 */
import * as reactQuery from "@tanstack/react-query";
import { useHyperionContext, HyperionContext } from "./hyperionContext";
import type * as Fetcher from "./hyperionFetcher";
import { hyperionFetch } from "./hyperionFetcher";
import type * as Schemas from "./hyperionSchemas";

export type PostAuthSimpleTokenError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostAuthSimpleTokenVariables = HyperionContext["fetcherOptions"];

/**
 * Ask for a JWT acc   ess token using oauth password flow.
 *
 * *username* and *password* must be provided
 *
 * Note: the request body needs to use **form-data** and not json.
 */
export const fetchPostAuthSimpleToken = (
  variables: PostAuthSimpleTokenVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.AccessToken,
    PostAuthSimpleTokenError,
    undefined,
    {},
    {},
    {}
  >({ url: "/auth/simple_token", method: "post", ...variables, signal });

/**
 * Ask for a JWT acc   ess token using oauth password flow.
 *
 * *username* and *password* must be provided
 *
 * Note: the request body needs to use **form-data** and not json.
 */
export const usePostAuthSimpleToken = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.AccessToken,
      PostAuthSimpleTokenError,
      PostAuthSimpleTokenVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.AccessToken,
    PostAuthSimpleTokenError,
    PostAuthSimpleTokenVariables
  >({
    mutationFn: (variables: PostAuthSimpleTokenVariables) =>
      fetchPostAuthSimpleToken({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetAuthAuthorizeQueryParams = {
  client_id: string;
  redirect_uri?: string | null;
  response_type: string;
  scope?: string | null;
  state?: string | null;
  nonce?: string | null;
  code_challenge?: string | null;
  code_challenge_method?: string | null;
};

export type GetAuthAuthorizeError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetAuthAuthorizeVariables = {
  queryParams: GetAuthAuthorizeQueryParams;
} & HyperionContext["fetcherOptions"];

/**
 * This endpoint is the one the user is redirected to when they begin the Oauth or Openid connect (*oidc*) *Authorization code* process.
 * The page allows the user to login and may let the user choose what type of data they want to authorize the client for.
 *
 * This is the endpoint that should be set in the client OAuth or OIDC configuration page. It can be called by a GET or a POST request.
 *
 * See `/auth/authorization-flow/authorize-validation` endpoint for information about the parameters.
 *
 * > In order for the authorization code grant to be secure, the authorization page must appear in a web browser the user is familiar with,
 * > and must not be embedded in an iframe popup or an embedded browser in a mobile app.
 * > If it could be embedded in another website, the user would have no way of verifying it is the legitimate service and is not a phishing attempt.
 *
 * **This endpoint is a UI endpoint which send and html page response. It will redirect to `/auth/authorization-flow/authorize-validation`**
 */
export const fetchGetAuthAuthorize = (
  variables: GetAuthAuthorizeVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    GetAuthAuthorizeError,
    undefined,
    {},
    GetAuthAuthorizeQueryParams,
    {}
  >({ url: "/auth/authorize", method: "get", ...variables, signal });

/**
 * This endpoint is the one the user is redirected to when they begin the Oauth or Openid connect (*oidc*) *Authorization code* process.
 * The page allows the user to login and may let the user choose what type of data they want to authorize the client for.
 *
 * This is the endpoint that should be set in the client OAuth or OIDC configuration page. It can be called by a GET or a POST request.
 *
 * See `/auth/authorization-flow/authorize-validation` endpoint for information about the parameters.
 *
 * > In order for the authorization code grant to be secure, the authorization page must appear in a web browser the user is familiar with,
 * > and must not be embedded in an iframe popup or an embedded browser in a mobile app.
 * > If it could be embedded in another website, the user would have no way of verifying it is the legitimate service and is not a phishing attempt.
 *
 * **This endpoint is a UI endpoint which send and html page response. It will redirect to `/auth/authorization-flow/authorize-validation`**
 */
export const useGetAuthAuthorize = <TData = undefined,>(
  variables: GetAuthAuthorizeVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, GetAuthAuthorizeError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<undefined, GetAuthAuthorizeError, TData>({
    queryKey: queryKeyFn({
      path: "/auth/authorize",
      operationId: "getAuthAuthorize",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetAuthAuthorize({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type PostAuthAuthorizeError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostAuthAuthorizeVariables = HyperionContext["fetcherOptions"];

/**
 * This endpoint is the one the user is redirected to when they begin the OAuth or Openid connect (*oidc*) *Authorization code* process with or without PKCE.
 * The page allows the user to login and may let the user choose what type of data they want to authorize the client for.
 *
 * This is the endpoint that should be set in the client OAuth or OIDC configuration page. It can be called by a GET or a POST request.
 *
 * See `/auth/authorization-flow/authorize-validation` endpoint for information about the parameters.
 *
 * > In order for the authorization code grant to be secure, the authorization page must appear in a web browser the user is familiar with,
 * > and must not be embedded in an iframe popup or an embedded browser in a mobile app.
 * > If it could be embedded in another website, the user would have no way of verifying it is the legitimate service and is not a phishing attempt.
 *
 * **This endpoint is a UI endpoint which send and html page response. It will redirect to `/auth/authorization-flow/authorize-validation`**
 */
export const fetchPostAuthAuthorize = (
  variables: PostAuthAuthorizeVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<undefined, PostAuthAuthorizeError, undefined, {}, {}, {}>({
    url: "/auth/authorize",
    method: "post",
    ...variables,
    signal,
  });

/**
 * This endpoint is the one the user is redirected to when they begin the OAuth or Openid connect (*oidc*) *Authorization code* process with or without PKCE.
 * The page allows the user to login and may let the user choose what type of data they want to authorize the client for.
 *
 * This is the endpoint that should be set in the client OAuth or OIDC configuration page. It can be called by a GET or a POST request.
 *
 * See `/auth/authorization-flow/authorize-validation` endpoint for information about the parameters.
 *
 * > In order for the authorization code grant to be secure, the authorization page must appear in a web browser the user is familiar with,
 * > and must not be embedded in an iframe popup or an embedded browser in a mobile app.
 * > If it could be embedded in another website, the user would have no way of verifying it is the legitimate service and is not a phishing attempt.
 *
 * **This endpoint is a UI endpoint which send and html page response. It will redirect to `/auth/authorization-flow/authorize-validation`**
 */
export const usePostAuthAuthorize = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PostAuthAuthorizeError,
      PostAuthAuthorizeVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PostAuthAuthorizeError,
    PostAuthAuthorizeVariables
  >({
    mutationFn: (variables: PostAuthAuthorizeVariables) =>
      fetchPostAuthAuthorize({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type PostAuthAuthorizationFlowAuthorizeValidationError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type PostAuthAuthorizationFlowAuthorizeValidationVariables =
  HyperionContext["fetcherOptions"];

/**
 * Part 1 of the authorization code grant.
 *
 * Parameters must be `application/x-www-form-urlencoded` and includes:
 *
 * * parameters for OAuth and Openid connect:
 *     * `response_type`: must be `code`
 *     * `client_id`: client identifier, needs to be registered in the server known_clients
 *     * `redirect_uri`: optional for OAuth (when registered in known_clients) but required for oidc. The url we need to redirect the user to after the authorization.
 *     * `scope`: optional for OAuth, must contain "openid" for oidc. List of scope the client want to get access to.
 *     * `state`: recommended. Opaque value used to maintain state between the request and the callback.
 *
 * * additional parameters for Openid connect:
 *     * `nonce`: oidc only. A string value used to associate a client session with an ID Token, and to mitigate replay attacks.
 *
 * * additional parameters for PKCE (see specs on https://datatracker.ietf.org/doc/html/rfc7636/):
 *     * `code_challenge`: PKCE only
 *     * `code_challenge_method`: PKCE only
 *
 *
 * * parameters that allows to authenticate the user and know which scopes he grants access to.
 *     * `email`
 *     * `password`
 *
 * References:
 *  * https://www.rfc-editor.org/rfc/rfc6749.html#section-4.1.2
 *  * https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest
 */
export const fetchPostAuthAuthorizationFlowAuthorizeValidation = (
  variables: PostAuthAuthorizationFlowAuthorizeValidationVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PostAuthAuthorizationFlowAuthorizeValidationError,
    undefined,
    {},
    {},
    {}
  >({
    url: "/auth/authorization-flow/authorize-validation",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Part 1 of the authorization code grant.
 *
 * Parameters must be `application/x-www-form-urlencoded` and includes:
 *
 * * parameters for OAuth and Openid connect:
 *     * `response_type`: must be `code`
 *     * `client_id`: client identifier, needs to be registered in the server known_clients
 *     * `redirect_uri`: optional for OAuth (when registered in known_clients) but required for oidc. The url we need to redirect the user to after the authorization.
 *     * `scope`: optional for OAuth, must contain "openid" for oidc. List of scope the client want to get access to.
 *     * `state`: recommended. Opaque value used to maintain state between the request and the callback.
 *
 * * additional parameters for Openid connect:
 *     * `nonce`: oidc only. A string value used to associate a client session with an ID Token, and to mitigate replay attacks.
 *
 * * additional parameters for PKCE (see specs on https://datatracker.ietf.org/doc/html/rfc7636/):
 *     * `code_challenge`: PKCE only
 *     * `code_challenge_method`: PKCE only
 *
 *
 * * parameters that allows to authenticate the user and know which scopes he grants access to.
 *     * `email`
 *     * `password`
 *
 * References:
 *  * https://www.rfc-editor.org/rfc/rfc6749.html#section-4.1.2
 *  * https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest
 */
export const usePostAuthAuthorizationFlowAuthorizeValidation = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PostAuthAuthorizationFlowAuthorizeValidationError,
      PostAuthAuthorizationFlowAuthorizeValidationVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PostAuthAuthorizationFlowAuthorizeValidationError,
    PostAuthAuthorizationFlowAuthorizeValidationVariables
  >({
    mutationFn: (
      variables: PostAuthAuthorizationFlowAuthorizeValidationVariables,
    ) =>
      fetchPostAuthAuthorizationFlowAuthorizeValidation({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type PostAuthTokenHeaders = {
  authorization?: string | null;
};

export type PostAuthTokenError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostAuthTokenVariables = {
  headers?: PostAuthTokenHeaders;
} & HyperionContext["fetcherOptions"];

/**
 * Part 2 of the authorization code grant.
 * The client exchange its authorization code for an access token. The endpoint supports OAuth and Openid connect, with or without PKCE.
 *
 * Parameters must be `application/x-www-form-urlencoded` and include:
 *
 * * parameters for OAuth and Openid connect:
 *     * `grant_type`: must be `authorization_code` or `refresh_token`
 *     * `code`: the authorization code received from the authorization endpoint
 *     * `redirect_uri`: optional for OAuth (when registered in known_clients) but required for oidc. The url we need to redirect the user to after the authorization. If provided, must be the same as previously registered in the `redirect_uri` field of the client.
 *
 * * Client credentials
 *     The client must send either:
 *         the client id and secret in the authorization header or with client_id and client_secret parameters
 *
 * * additional parameters for PKCE:
 *     * `code_verifier`: PKCE only, allows to verify the previous code_challenge
 *
 * https://datatracker.ietf.org/doc/html/rfc6749#section-4.1.3
 * https://openid.net/specs/openid-connect-core-1_0.html#TokenRequestValidation
 */
export const fetchPostAuthToken = (
  variables: PostAuthTokenVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.TokenResponse,
    PostAuthTokenError,
    undefined,
    PostAuthTokenHeaders,
    {},
    {}
  >({ url: "/auth/token", method: "post", ...variables, signal });

/**
 * Part 2 of the authorization code grant.
 * The client exchange its authorization code for an access token. The endpoint supports OAuth and Openid connect, with or without PKCE.
 *
 * Parameters must be `application/x-www-form-urlencoded` and include:
 *
 * * parameters for OAuth and Openid connect:
 *     * `grant_type`: must be `authorization_code` or `refresh_token`
 *     * `code`: the authorization code received from the authorization endpoint
 *     * `redirect_uri`: optional for OAuth (when registered in known_clients) but required for oidc. The url we need to redirect the user to after the authorization. If provided, must be the same as previously registered in the `redirect_uri` field of the client.
 *
 * * Client credentials
 *     The client must send either:
 *         the client id and secret in the authorization header or with client_id and client_secret parameters
 *
 * * additional parameters for PKCE:
 *     * `code_verifier`: PKCE only, allows to verify the previous code_challenge
 *
 * https://datatracker.ietf.org/doc/html/rfc6749#section-4.1.3
 * https://openid.net/specs/openid-connect-core-1_0.html#TokenRequestValidation
 */
export const usePostAuthToken = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.TokenResponse,
      PostAuthTokenError,
      PostAuthTokenVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.TokenResponse,
    PostAuthTokenError,
    PostAuthTokenVariables
  >({
    mutationFn: (variables: PostAuthTokenVariables) =>
      fetchPostAuthToken({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetAuthUserinfoError = Fetcher.ErrorWrapper<undefined>;

export type GetAuthUserinfoVariables = HyperionContext["fetcherOptions"];

/**
 * Openid connect specify an endpoint the client can use to get information about the user.
 * The oidc client will provide the access_token it got previously in the request.
 *
 * The information expected depends on the client and may include the user identifier, name, email, phone...
 * See the reference for possible claims. See the client documentation and implementation to know what it needs and can receive.
 * The sub (subject) Claim MUST always be returned in the UserInfo Response.
 *
 * The client can ask for specific information using scopes and claims. See the reference for more information.
 * This procedure is not implemented in Hyperion as we can customize the response using auth_client class
 *
 * Reference:
 * https://openid.net/specs/openid-connect-core-1_0.html#UserInfo
 */
export const fetchGetAuthUserinfo = (
  variables: GetAuthUserinfoVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<void, GetAuthUserinfoError, undefined, {}, {}, {}>({
    url: "/auth/userinfo",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Openid connect specify an endpoint the client can use to get information about the user.
 * The oidc client will provide the access_token it got previously in the request.
 *
 * The information expected depends on the client and may include the user identifier, name, email, phone...
 * See the reference for possible claims. See the client documentation and implementation to know what it needs and can receive.
 * The sub (subject) Claim MUST always be returned in the UserInfo Response.
 *
 * The client can ask for specific information using scopes and claims. See the reference for more information.
 * This procedure is not implemented in Hyperion as we can customize the response using auth_client class
 *
 * Reference:
 * https://openid.net/specs/openid-connect-core-1_0.html#UserInfo
 */
export const useGetAuthUserinfo = <TData = void,>(
  variables: GetAuthUserinfoVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<void, GetAuthUserinfoError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<void, GetAuthUserinfoError, TData>({
    queryKey: queryKeyFn({
      path: "/auth/userinfo",
      operationId: "getAuthUserinfo",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetAuthUserinfo({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type GetOidcAuthorizationFlowJwksUriError =
  Fetcher.ErrorWrapper<undefined>;

export type GetOidcAuthorizationFlowJwksUriVariables =
  HyperionContext["fetcherOptions"];

export const fetchGetOidcAuthorizationFlowJwksUri = (
  variables: GetOidcAuthorizationFlowJwksUriVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    void,
    GetOidcAuthorizationFlowJwksUriError,
    undefined,
    {},
    {},
    {}
  >({
    url: "/oidc/authorization-flow/jwks_uri",
    method: "get",
    ...variables,
    signal,
  });

export const useGetOidcAuthorizationFlowJwksUri = <TData = void,>(
  variables: GetOidcAuthorizationFlowJwksUriVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      void,
      GetOidcAuthorizationFlowJwksUriError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<void, GetOidcAuthorizationFlowJwksUriError, TData>(
    {
      queryKey: queryKeyFn({
        path: "/oidc/authorization-flow/jwks_uri",
        operationId: "getOidcAuthorizationFlowJwksUri",
        variables,
      }),
      queryFn: ({ signal }) =>
        fetchGetOidcAuthorizationFlowJwksUri(
          { ...fetcherOptions, ...variables },
          signal,
        ),
      ...options,
      ...queryOptions,
    },
  );
};

export type GetWellKnownOpenidConfigurationError =
  Fetcher.ErrorWrapper<undefined>;

export type GetWellKnownOpenidConfigurationVariables =
  HyperionContext["fetcherOptions"];

export const fetchGetWellKnownOpenidConfiguration = (
  variables: GetWellKnownOpenidConfigurationVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    void,
    GetWellKnownOpenidConfigurationError,
    undefined,
    {},
    {},
    {}
  >({
    url: "/.well-known/openid-configuration",
    method: "get",
    ...variables,
    signal,
  });

export const useGetWellKnownOpenidConfiguration = <TData = void,>(
  variables: GetWellKnownOpenidConfigurationVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      void,
      GetWellKnownOpenidConfigurationError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<void, GetWellKnownOpenidConfigurationError, TData>(
    {
      queryKey: queryKeyFn({
        path: "/.well-known/openid-configuration",
        operationId: "getWellKnownOpenidConfiguration",
        variables,
      }),
      queryFn: ({ signal }) =>
        fetchGetWellKnownOpenidConfiguration(
          { ...fetcherOptions, ...variables },
          signal,
        ),
      ...options,
      ...queryOptions,
    },
  );
};

export type GetInformationError = Fetcher.ErrorWrapper<undefined>;

export type GetInformationVariables = HyperionContext["fetcherOptions"];

/**
 * Return information about Hyperion. This endpoint can be used to check if the API is up.
 */
export const fetchGetInformation = (
  variables: GetInformationVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.CoreInformation,
    GetInformationError,
    undefined,
    {},
    {},
    {}
  >({ url: "/information", method: "get", ...variables, signal });

/**
 * Return information about Hyperion. This endpoint can be used to check if the API is up.
 */
export const useGetInformation = <TData = Schemas.CoreInformation,>(
  variables: GetInformationVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.CoreInformation,
      GetInformationError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<
    Schemas.CoreInformation,
    GetInformationError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/information",
      operationId: "getInformation",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetInformation({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type GetPrivacyError = Fetcher.ErrorWrapper<undefined>;

export type GetPrivacyVariables = HyperionContext["fetcherOptions"];

/**
 * Return Hyperion privacy
 */
export const fetchGetPrivacy = (
  variables: GetPrivacyVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<undefined, GetPrivacyError, undefined, {}, {}, {}>({
    url: "/privacy",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Return Hyperion privacy
 */
export const useGetPrivacy = <TData = undefined,>(
  variables: GetPrivacyVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, GetPrivacyError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<undefined, GetPrivacyError, TData>({
    queryKey: queryKeyFn({
      path: "/privacy",
      operationId: "getPrivacy",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetPrivacy({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type GetTermsAndConditionsError = Fetcher.ErrorWrapper<undefined>;

export type GetTermsAndConditionsVariables = HyperionContext["fetcherOptions"];

/**
 * Return Hyperion terms and conditions pages
 */
export const fetchGetTermsAndConditions = (
  variables: GetTermsAndConditionsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<undefined, GetTermsAndConditionsError, undefined, {}, {}, {}>({
    url: "/terms-and-conditions",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Return Hyperion terms and conditions pages
 */
export const useGetTermsAndConditions = <TData = undefined,>(
  variables: GetTermsAndConditionsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, GetTermsAndConditionsError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<undefined, GetTermsAndConditionsError, TData>({
    queryKey: queryKeyFn({
      path: "/terms-and-conditions",
      operationId: "getTermsAndConditions",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetTermsAndConditions({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type GetSupportError = Fetcher.ErrorWrapper<undefined>;

export type GetSupportVariables = HyperionContext["fetcherOptions"];

/**
 * Return Hyperion terms and conditions pages
 */
export const fetchGetSupport = (
  variables: GetSupportVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<undefined, GetSupportError, undefined, {}, {}, {}>({
    url: "/support",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Return Hyperion terms and conditions pages
 */
export const useGetSupport = <TData = undefined,>(
  variables: GetSupportVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, GetSupportError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<undefined, GetSupportError, TData>({
    queryKey: queryKeyFn({
      path: "/support",
      operationId: "getSupport",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetSupport({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type GetSecurityTxtError = Fetcher.ErrorWrapper<undefined>;

export type GetSecurityTxtVariables = HyperionContext["fetcherOptions"];

/**
 * Return Hyperion security.txt file
 */
export const fetchGetSecurityTxt = (
  variables: GetSecurityTxtVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<undefined, GetSecurityTxtError, undefined, {}, {}, {}>({
    url: "/security.txt",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Return Hyperion security.txt file
 */
export const useGetSecurityTxt = <TData = undefined,>(
  variables: GetSecurityTxtVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, GetSecurityTxtError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<undefined, GetSecurityTxtError, TData>({
    queryKey: queryKeyFn({
      path: "/security.txt",
      operationId: "getSecurityTxt",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetSecurityTxt({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type GetWellKnownSecurityTxtError = Fetcher.ErrorWrapper<undefined>;

export type GetWellKnownSecurityTxtVariables =
  HyperionContext["fetcherOptions"];

/**
 * Return Hyperion security.txt file
 */
export const fetchGetWellKnownSecurityTxt = (
  variables: GetWellKnownSecurityTxtVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<undefined, GetWellKnownSecurityTxtError, undefined, {}, {}, {}>(
    { url: "/.well-known/security.txt", method: "get", ...variables, signal },
  );

/**
 * Return Hyperion security.txt file
 */
export const useGetWellKnownSecurityTxt = <TData = undefined,>(
  variables: GetWellKnownSecurityTxtVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, GetWellKnownSecurityTxtError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<undefined, GetWellKnownSecurityTxtError, TData>({
    queryKey: queryKeyFn({
      path: "/.well-known/security.txt",
      operationId: "getWellKnownSecurityTxt",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetWellKnownSecurityTxt({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type GetRobotsTxtError = Fetcher.ErrorWrapper<undefined>;

export type GetRobotsTxtVariables = HyperionContext["fetcherOptions"];

/**
 * Return Hyperion robots.txt file
 */
export const fetchGetRobotsTxt = (
  variables: GetRobotsTxtVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<undefined, GetRobotsTxtError, undefined, {}, {}, {}>({
    url: "/robots.txt",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Return Hyperion robots.txt file
 */
export const useGetRobotsTxt = <TData = undefined,>(
  variables: GetRobotsTxtVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, GetRobotsTxtError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<undefined, GetRobotsTxtError, TData>({
    queryKey: queryKeyFn({
      path: "/robots.txt",
      operationId: "getRobotsTxt",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetRobotsTxt({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type GetStyleFileCssPathParams = {
  file: string;
};

export type GetStyleFileCssError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetStyleFileCssVariables = {
  pathParams: GetStyleFileCssPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Return a style file from the assets folder
 */
export const fetchGetStyleFileCss = (
  variables: GetStyleFileCssVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    GetStyleFileCssError,
    undefined,
    {},
    {},
    GetStyleFileCssPathParams
  >({ url: "/style/{file}.css", method: "get", ...variables, signal });

/**
 * Return a style file from the assets folder
 */
export const useGetStyleFileCss = <TData = undefined,>(
  variables: GetStyleFileCssVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, GetStyleFileCssError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<undefined, GetStyleFileCssError, TData>({
    queryKey: queryKeyFn({
      path: "/style/{file}.css",
      operationId: "getStyleFileCss",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetStyleFileCss({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type GetFaviconIcoError = Fetcher.ErrorWrapper<undefined>;

export type GetFaviconIcoVariables = HyperionContext["fetcherOptions"];

export const fetchGetFaviconIco = (
  variables: GetFaviconIcoVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<undefined, GetFaviconIcoError, undefined, {}, {}, {}>({
    url: "/favicon.ico",
    method: "get",
    ...variables,
    signal,
  });

export const useGetFaviconIco = <TData = undefined,>(
  variables: GetFaviconIcoVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, GetFaviconIcoError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<undefined, GetFaviconIcoError, TData>({
    queryKey: queryKeyFn({
      path: "/favicon.ico",
      operationId: "getFaviconIco",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetFaviconIco({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type GetModuleVisibilityError = Fetcher.ErrorWrapper<undefined>;

export type GetModuleVisibilityResponse = Schemas.ModuleVisibility[];

export type GetModuleVisibilityVariables = HyperionContext["fetcherOptions"];

/**
 * Get all existing module_visibility.
 *
 * **This endpoint is only usable by administrators**
 */
export const fetchGetModuleVisibility = (
  variables: GetModuleVisibilityVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetModuleVisibilityResponse,
    GetModuleVisibilityError,
    undefined,
    {},
    {},
    {}
  >({ url: "/module-visibility/", method: "get", ...variables, signal });

/**
 * Get all existing module_visibility.
 *
 * **This endpoint is only usable by administrators**
 */
export const useGetModuleVisibility = <TData = GetModuleVisibilityResponse,>(
  variables: GetModuleVisibilityVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetModuleVisibilityResponse,
      GetModuleVisibilityError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<
    GetModuleVisibilityResponse,
    GetModuleVisibilityError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/module-visibility/",
      operationId: "getModuleVisibility",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetModuleVisibility({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type PostModuleVisibilityError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostModuleVisibilityVariables = {
  body: Schemas.ModuleVisibilityCreate;
} & HyperionContext["fetcherOptions"];

/**
 * Add a new group to a module
 *
 * **This endpoint is only usable by administrators**
 */
export const fetchPostModuleVisibility = (
  variables: PostModuleVisibilityVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.ModuleVisibilityCreate,
    PostModuleVisibilityError,
    Schemas.ModuleVisibilityCreate,
    {},
    {},
    {}
  >({ url: "/module-visibility/", method: "post", ...variables, signal });

/**
 * Add a new group to a module
 *
 * **This endpoint is only usable by administrators**
 */
export const usePostModuleVisibility = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.ModuleVisibilityCreate,
      PostModuleVisibilityError,
      PostModuleVisibilityVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.ModuleVisibilityCreate,
    PostModuleVisibilityError,
    PostModuleVisibilityVariables
  >({
    mutationFn: (variables: PostModuleVisibilityVariables) =>
      fetchPostModuleVisibility({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetModuleVisibilityMeError = Fetcher.ErrorWrapper<undefined>;

export type GetModuleVisibilityMeResponse = string[];

export type GetModuleVisibilityMeVariables = HyperionContext["fetcherOptions"];

/**
 * Get group user accessible root
 *
 * **This endpoint is only usable by everyone**
 */
export const fetchGetModuleVisibilityMe = (
  variables: GetModuleVisibilityMeVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetModuleVisibilityMeResponse,
    GetModuleVisibilityMeError,
    undefined,
    {},
    {},
    {}
  >({ url: "/module-visibility/me", method: "get", ...variables, signal });

/**
 * Get group user accessible root
 *
 * **This endpoint is only usable by everyone**
 */
export const useGetModuleVisibilityMe = <
  TData = GetModuleVisibilityMeResponse,
>(
  variables: GetModuleVisibilityMeVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetModuleVisibilityMeResponse,
      GetModuleVisibilityMeError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<
    GetModuleVisibilityMeResponse,
    GetModuleVisibilityMeError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/module-visibility/me",
      operationId: "getModuleVisibilityMe",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetModuleVisibilityMe({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type DeleteModuleVisibilityRootGroupIdPathParams = {
  root: string;
  groupId: string;
};

export type DeleteModuleVisibilityRootGroupIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type DeleteModuleVisibilityRootGroupIdVariables = {
  pathParams: DeleteModuleVisibilityRootGroupIdPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchDeleteModuleVisibilityRootGroupId = (
  variables: DeleteModuleVisibilityRootGroupIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteModuleVisibilityRootGroupIdError,
    undefined,
    {},
    {},
    DeleteModuleVisibilityRootGroupIdPathParams
  >({
    url: "/module-visibility/{root}/{groupId}",
    method: "delete",
    ...variables,
    signal,
  });

export const useDeleteModuleVisibilityRootGroupId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteModuleVisibilityRootGroupIdError,
      DeleteModuleVisibilityRootGroupIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteModuleVisibilityRootGroupIdError,
    DeleteModuleVisibilityRootGroupIdVariables
  >({
    mutationFn: (variables: DeleteModuleVisibilityRootGroupIdVariables) =>
      fetchDeleteModuleVisibilityRootGroupId({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type GetGroupsError = Fetcher.ErrorWrapper<undefined>;

export type GetGroupsResponse = Schemas.CoreGroupSimple[];

export type GetGroupsVariables = HyperionContext["fetcherOptions"];

/**
 * Return all groups from database as a list of dictionaries
 */
export const fetchGetGroups = (
  variables: GetGroupsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<GetGroupsResponse, GetGroupsError, undefined, {}, {}, {}>({
    url: "/groups/",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Return all groups from database as a list of dictionaries
 */
export const useGetGroups = <TData = GetGroupsResponse,>(
  variables: GetGroupsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<GetGroupsResponse, GetGroupsError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<GetGroupsResponse, GetGroupsError, TData>({
    queryKey: queryKeyFn({
      path: "/groups/",
      operationId: "getGroups",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetGroups({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type PostGroupsError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostGroupsVariables = {
  body: Schemas.CoreGroupCreate;
} & HyperionContext["fetcherOptions"];

/**
 * Create a new group.
 *
 * **This endpoint is only usable by administrators**
 */
export const fetchPostGroups = (
  variables: PostGroupsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.CoreGroupSimple,
    PostGroupsError,
    Schemas.CoreGroupCreate,
    {},
    {},
    {}
  >({ url: "/groups/", method: "post", ...variables, signal });

/**
 * Create a new group.
 *
 * **This endpoint is only usable by administrators**
 */
export const usePostGroups = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.CoreGroupSimple,
      PostGroupsError,
      PostGroupsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.CoreGroupSimple,
    PostGroupsError,
    PostGroupsVariables
  >({
    mutationFn: (variables: PostGroupsVariables) =>
      fetchPostGroups({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetGroupsGroupIdPathParams = {
  groupId: string;
};

export type GetGroupsGroupIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetGroupsGroupIdVariables = {
  pathParams: GetGroupsGroupIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Return group with id from database as a dictionary. This includes a list of users being members of the group.
 *
 * **This endpoint is only usable by administrators**
 */
export const fetchGetGroupsGroupId = (
  variables: GetGroupsGroupIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.CoreGroup,
    GetGroupsGroupIdError,
    undefined,
    {},
    {},
    GetGroupsGroupIdPathParams
  >({ url: "/groups/{groupId}", method: "get", ...variables, signal });

/**
 * Return group with id from database as a dictionary. This includes a list of users being members of the group.
 *
 * **This endpoint is only usable by administrators**
 */
export const useGetGroupsGroupId = <TData = Schemas.CoreGroup,>(
  variables: GetGroupsGroupIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.CoreGroup, GetGroupsGroupIdError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<Schemas.CoreGroup, GetGroupsGroupIdError, TData>({
    queryKey: queryKeyFn({
      path: "/groups/{groupId}",
      operationId: "getGroupsGroupId",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetGroupsGroupId({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type PatchGroupsGroupIdPathParams = {
  groupId: string;
};

export type PatchGroupsGroupIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PatchGroupsGroupIdVariables = {
  body?: Schemas.CoreGroupUpdate;
  pathParams: PatchGroupsGroupIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Update the name or the description of a group.
 *
 * **This endpoint is only usable by administrators**
 */
export const fetchPatchGroupsGroupId = (
  variables: PatchGroupsGroupIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchGroupsGroupIdError,
    Schemas.CoreGroupUpdate,
    {},
    {},
    PatchGroupsGroupIdPathParams
  >({ url: "/groups/{groupId}", method: "patch", ...variables, signal });

/**
 * Update the name or the description of a group.
 *
 * **This endpoint is only usable by administrators**
 */
export const usePatchGroupsGroupId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchGroupsGroupIdError,
      PatchGroupsGroupIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchGroupsGroupIdError,
    PatchGroupsGroupIdVariables
  >({
    mutationFn: (variables: PatchGroupsGroupIdVariables) =>
      fetchPatchGroupsGroupId({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type DeleteGroupsGroupIdPathParams = {
  groupId: string;
};

export type DeleteGroupsGroupIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type DeleteGroupsGroupIdVariables = {
  pathParams: DeleteGroupsGroupIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Delete group from database.
 * This will remove the group from all users but won't delete any user.
 *
 * `GroupTypes` groups can not be deleted.
 *
 * **This endpoint is only usable by administrators**
 */
export const fetchDeleteGroupsGroupId = (
  variables: DeleteGroupsGroupIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteGroupsGroupIdError,
    undefined,
    {},
    {},
    DeleteGroupsGroupIdPathParams
  >({ url: "/groups/{groupId}", method: "delete", ...variables, signal });

/**
 * Delete group from database.
 * This will remove the group from all users but won't delete any user.
 *
 * `GroupTypes` groups can not be deleted.
 *
 * **This endpoint is only usable by administrators**
 */
export const useDeleteGroupsGroupId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteGroupsGroupIdError,
      DeleteGroupsGroupIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteGroupsGroupIdError,
    DeleteGroupsGroupIdVariables
  >({
    mutationFn: (variables: DeleteGroupsGroupIdVariables) =>
      fetchDeleteGroupsGroupId({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type PostGroupsMembershipError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostGroupsMembershipVariables = {
  body: Schemas.CoreMembership;
} & HyperionContext["fetcherOptions"];

/**
 * Create a new membership in database and return the group. This allows to "add a user to a group".
 *
 * **This endpoint is only usable by administrators**
 */
export const fetchPostGroupsMembership = (
  variables: PostGroupsMembershipVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.CoreGroup,
    PostGroupsMembershipError,
    Schemas.CoreMembership,
    {},
    {},
    {}
  >({ url: "/groups/membership", method: "post", ...variables, signal });

/**
 * Create a new membership in database and return the group. This allows to "add a user to a group".
 *
 * **This endpoint is only usable by administrators**
 */
export const usePostGroupsMembership = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.CoreGroup,
      PostGroupsMembershipError,
      PostGroupsMembershipVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.CoreGroup,
    PostGroupsMembershipError,
    PostGroupsMembershipVariables
  >({
    mutationFn: (variables: PostGroupsMembershipVariables) =>
      fetchPostGroupsMembership({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type DeleteGroupsMembershipError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type DeleteGroupsMembershipVariables = {
  body: Schemas.CoreMembershipDelete;
} & HyperionContext["fetcherOptions"];

/**
 * Delete a membership using the user and group ids.
 *
 * **This endpoint is only usable by administrators**
 */
export const fetchDeleteGroupsMembership = (
  variables: DeleteGroupsMembershipVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteGroupsMembershipError,
    Schemas.CoreMembershipDelete,
    {},
    {},
    {}
  >({ url: "/groups/membership", method: "delete", ...variables, signal });

/**
 * Delete a membership using the user and group ids.
 *
 * **This endpoint is only usable by administrators**
 */
export const useDeleteGroupsMembership = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteGroupsMembershipError,
      DeleteGroupsMembershipVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteGroupsMembershipError,
    DeleteGroupsMembershipVariables
  >({
    mutationFn: (variables: DeleteGroupsMembershipVariables) =>
      fetchDeleteGroupsMembership({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type PostGroupsBatchMembershipError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostGroupsBatchMembershipVariables = {
  body: Schemas.CoreBatchMembership;
} & HyperionContext["fetcherOptions"];

/**
 * Add a list of user to a group, using a list of email.
 * If an user does not exist it will be ignored.
 *
 * **This endpoint is only usable by administrators**
 */
export const fetchPostGroupsBatchMembership = (
  variables: PostGroupsBatchMembershipVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PostGroupsBatchMembershipError,
    Schemas.CoreBatchMembership,
    {},
    {},
    {}
  >({ url: "/groups/batch-membership", method: "post", ...variables, signal });

/**
 * Add a list of user to a group, using a list of email.
 * If an user does not exist it will be ignored.
 *
 * **This endpoint is only usable by administrators**
 */
export const usePostGroupsBatchMembership = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PostGroupsBatchMembershipError,
      PostGroupsBatchMembershipVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PostGroupsBatchMembershipError,
    PostGroupsBatchMembershipVariables
  >({
    mutationFn: (variables: PostGroupsBatchMembershipVariables) =>
      fetchPostGroupsBatchMembership({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type DeleteGroupsBatchMembershipError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type DeleteGroupsBatchMembershipVariables = {
  body: Schemas.CoreBatchDeleteMembership;
} & HyperionContext["fetcherOptions"];

/**
 * This endpoint removes all users from a given group.
 *
 * **This endpoint is only usable by administrators**
 */
export const fetchDeleteGroupsBatchMembership = (
  variables: DeleteGroupsBatchMembershipVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteGroupsBatchMembershipError,
    Schemas.CoreBatchDeleteMembership,
    {},
    {},
    {}
  >({
    url: "/groups/batch-membership",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * This endpoint removes all users from a given group.
 *
 * **This endpoint is only usable by administrators**
 */
export const useDeleteGroupsBatchMembership = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteGroupsBatchMembershipError,
      DeleteGroupsBatchMembershipVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteGroupsBatchMembershipError,
    DeleteGroupsBatchMembershipVariables
  >({
    mutationFn: (variables: DeleteGroupsBatchMembershipVariables) =>
      fetchDeleteGroupsBatchMembership({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetNotificationDevicesError = Fetcher.ErrorWrapper<undefined>;

export type GetNotificationDevicesResponse = Schemas.FirebaseDevice[];

export type GetNotificationDevicesVariables = HyperionContext["fetcherOptions"];

/**
 * Get all devices a user have registered.
 * This endpoint is useful to get firebase tokens for debugging purposes.
 *
 * **Only admins can use this endpoint**
 */
export const fetchGetNotificationDevices = (
  variables: GetNotificationDevicesVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetNotificationDevicesResponse,
    GetNotificationDevicesError,
    undefined,
    {},
    {},
    {}
  >({ url: "/notification/devices", method: "get", ...variables, signal });

/**
 * Get all devices a user have registered.
 * This endpoint is useful to get firebase tokens for debugging purposes.
 *
 * **Only admins can use this endpoint**
 */
export const useGetNotificationDevices = <
  TData = GetNotificationDevicesResponse,
>(
  variables: GetNotificationDevicesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetNotificationDevicesResponse,
      GetNotificationDevicesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<
    GetNotificationDevicesResponse,
    GetNotificationDevicesError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/notification/devices",
      operationId: "getNotificationDevices",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetNotificationDevices({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type PostNotificationDevicesError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostNotificationDevicesVariables = {
  body: Schemas.BodyRegisterFirebaseDeviceNotificationDevicesPost;
} & HyperionContext["fetcherOptions"];

/**
 * Register a firebase device for the user, if the device already exists, this will update the creation date.
 * This endpoint should be called once a month to ensure that the token is still valide.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const fetchPostNotificationDevices = (
  variables: PostNotificationDevicesVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PostNotificationDevicesError,
    Schemas.BodyRegisterFirebaseDeviceNotificationDevicesPost,
    {},
    {},
    {}
  >({ url: "/notification/devices", method: "post", ...variables, signal });

/**
 * Register a firebase device for the user, if the device already exists, this will update the creation date.
 * This endpoint should be called once a month to ensure that the token is still valide.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const usePostNotificationDevices = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PostNotificationDevicesError,
      PostNotificationDevicesVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PostNotificationDevicesError,
    PostNotificationDevicesVariables
  >({
    mutationFn: (variables: PostNotificationDevicesVariables) =>
      fetchPostNotificationDevices({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type DeleteNotificationDevicesFirebaseTokenPathParams = {
  firebaseToken: string;
};

export type DeleteNotificationDevicesFirebaseTokenError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type DeleteNotificationDevicesFirebaseTokenVariables = {
  pathParams: DeleteNotificationDevicesFirebaseTokenPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Unregister a new firebase device for the user
 *
 * **The user must be authenticated to use this endpoint**
 */
export const fetchDeleteNotificationDevicesFirebaseToken = (
  variables: DeleteNotificationDevicesFirebaseTokenVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteNotificationDevicesFirebaseTokenError,
    undefined,
    {},
    {},
    DeleteNotificationDevicesFirebaseTokenPathParams
  >({
    url: "/notification/devices/{firebaseToken}",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * Unregister a new firebase device for the user
 *
 * **The user must be authenticated to use this endpoint**
 */
export const useDeleteNotificationDevicesFirebaseToken = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteNotificationDevicesFirebaseTokenError,
      DeleteNotificationDevicesFirebaseTokenVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteNotificationDevicesFirebaseTokenError,
    DeleteNotificationDevicesFirebaseTokenVariables
  >({
    mutationFn: (variables: DeleteNotificationDevicesFirebaseTokenVariables) =>
      fetchDeleteNotificationDevicesFirebaseToken({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type GetNotificationMessagesFirebaseTokenPathParams = {
  firebaseToken: string;
};

export type GetNotificationMessagesFirebaseTokenError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetNotificationMessagesFirebaseTokenResponse = Schemas.Message[];

export type GetNotificationMessagesFirebaseTokenVariables = {
  pathParams: GetNotificationMessagesFirebaseTokenPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Get all messages for a specific device from the user
 *
 * **The user must be authenticated to use this endpoint**
 */
export const fetchGetNotificationMessagesFirebaseToken = (
  variables: GetNotificationMessagesFirebaseTokenVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetNotificationMessagesFirebaseTokenResponse,
    GetNotificationMessagesFirebaseTokenError,
    undefined,
    {},
    {},
    GetNotificationMessagesFirebaseTokenPathParams
  >({
    url: "/notification/messages/{firebaseToken}",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get all messages for a specific device from the user
 *
 * **The user must be authenticated to use this endpoint**
 */
export const useGetNotificationMessagesFirebaseToken = <
  TData = GetNotificationMessagesFirebaseTokenResponse,
>(
  variables: GetNotificationMessagesFirebaseTokenVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetNotificationMessagesFirebaseTokenResponse,
      GetNotificationMessagesFirebaseTokenError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<
    GetNotificationMessagesFirebaseTokenResponse,
    GetNotificationMessagesFirebaseTokenError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/notification/messages/{firebaseToken}",
      operationId: "getNotificationMessagesFirebaseToken",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetNotificationMessagesFirebaseToken(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type PostNotificationTopicsTopicStrSubscribePathParams = {
  /**
   * The topic to subscribe to. The Topic may be followed by an additional identifier (ex: cinema_4c029b5f-2bf7-4b70-85d4-340a4bd28653)
   */
  topicStr: string;
};

export type PostNotificationTopicsTopicStrSubscribeError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type PostNotificationTopicsTopicStrSubscribeVariables = {
  pathParams: PostNotificationTopicsTopicStrSubscribePathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Subscribe to a topic
 *
 * **The user must be authenticated to use this endpoint**
 */
export const fetchPostNotificationTopicsTopicStrSubscribe = (
  variables: PostNotificationTopicsTopicStrSubscribeVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PostNotificationTopicsTopicStrSubscribeError,
    undefined,
    {},
    {},
    PostNotificationTopicsTopicStrSubscribePathParams
  >({
    url: "/notification/topics/{topicStr}/subscribe",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Subscribe to a topic
 *
 * **The user must be authenticated to use this endpoint**
 */
export const usePostNotificationTopicsTopicStrSubscribe = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PostNotificationTopicsTopicStrSubscribeError,
      PostNotificationTopicsTopicStrSubscribeVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PostNotificationTopicsTopicStrSubscribeError,
    PostNotificationTopicsTopicStrSubscribeVariables
  >({
    mutationFn: (variables: PostNotificationTopicsTopicStrSubscribeVariables) =>
      fetchPostNotificationTopicsTopicStrSubscribe({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type PostNotificationTopicsTopicStrUnsubscribePathParams = {
  topicStr: string;
};

export type PostNotificationTopicsTopicStrUnsubscribeError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type PostNotificationTopicsTopicStrUnsubscribeVariables = {
  pathParams: PostNotificationTopicsTopicStrUnsubscribePathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Unsubscribe to a topic
 *
 * **The user must be authenticated to use this endpoint**
 */
export const fetchPostNotificationTopicsTopicStrUnsubscribe = (
  variables: PostNotificationTopicsTopicStrUnsubscribeVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PostNotificationTopicsTopicStrUnsubscribeError,
    undefined,
    {},
    {},
    PostNotificationTopicsTopicStrUnsubscribePathParams
  >({
    url: "/notification/topics/{topicStr}/unsubscribe",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Unsubscribe to a topic
 *
 * **The user must be authenticated to use this endpoint**
 */
export const usePostNotificationTopicsTopicStrUnsubscribe = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PostNotificationTopicsTopicStrUnsubscribeError,
      PostNotificationTopicsTopicStrUnsubscribeVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PostNotificationTopicsTopicStrUnsubscribeError,
    PostNotificationTopicsTopicStrUnsubscribeVariables
  >({
    mutationFn: (
      variables: PostNotificationTopicsTopicStrUnsubscribeVariables,
    ) =>
      fetchPostNotificationTopicsTopicStrUnsubscribe({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type GetNotificationTopicsError = Fetcher.ErrorWrapper<undefined>;

export type GetNotificationTopicsResponse = string[];

export type GetNotificationTopicsVariables = HyperionContext["fetcherOptions"];

/**
 * Get topics the user is subscribed to
 * Does not return session topics (those with a topic_identifier)
 *
 * **The user must be authenticated to use this endpoint**
 */
export const fetchGetNotificationTopics = (
  variables: GetNotificationTopicsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetNotificationTopicsResponse,
    GetNotificationTopicsError,
    undefined,
    {},
    {},
    {}
  >({ url: "/notification/topics", method: "get", ...variables, signal });

/**
 * Get topics the user is subscribed to
 * Does not return session topics (those with a topic_identifier)
 *
 * **The user must be authenticated to use this endpoint**
 */
export const useGetNotificationTopics = <
  TData = GetNotificationTopicsResponse,
>(
  variables: GetNotificationTopicsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetNotificationTopicsResponse,
      GetNotificationTopicsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<
    GetNotificationTopicsResponse,
    GetNotificationTopicsError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/notification/topics",
      operationId: "getNotificationTopics",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetNotificationTopics({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type GetNotificationTopicsTopicPathParams = {
  topic: Schemas.Topic;
};

export type GetNotificationTopicsTopicError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetNotificationTopicsTopicResponse = string[];

export type GetNotificationTopicsTopicVariables = {
  pathParams: GetNotificationTopicsTopicPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Get custom topic (with identifiers) the user is subscribed to
 *
 * **The user must be authenticated to use this endpoint**
 */
export const fetchGetNotificationTopicsTopic = (
  variables: GetNotificationTopicsTopicVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetNotificationTopicsTopicResponse,
    GetNotificationTopicsTopicError,
    undefined,
    {},
    {},
    GetNotificationTopicsTopicPathParams
  >({
    url: "/notification/topics/{topic}",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get custom topic (with identifiers) the user is subscribed to
 *
 * **The user must be authenticated to use this endpoint**
 */
export const useGetNotificationTopicsTopic = <
  TData = GetNotificationTopicsTopicResponse,
>(
  variables: GetNotificationTopicsTopicVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetNotificationTopicsTopicResponse,
      GetNotificationTopicsTopicError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<
    GetNotificationTopicsTopicResponse,
    GetNotificationTopicsTopicError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/notification/topics/{topic}",
      operationId: "getNotificationTopicsTopic",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetNotificationTopicsTopic(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type PostNotificationSendError = Fetcher.ErrorWrapper<undefined>;

export type PostNotificationSendVariables = HyperionContext["fetcherOptions"];

/**
 * Send ourself a test notification.
 *
 * **Only admins can use this endpoint**
 */
export const fetchPostNotificationSend = (
  variables: PostNotificationSendVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<void, PostNotificationSendError, undefined, {}, {}, {}>({
    url: "/notification/send",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Send ourself a test notification.
 *
 * **Only admins can use this endpoint**
 */
export const usePostNotificationSend = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      void,
      PostNotificationSendError,
      PostNotificationSendVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    void,
    PostNotificationSendError,
    PostNotificationSendVariables
  >({
    mutationFn: (variables: PostNotificationSendVariables) =>
      fetchPostNotificationSend({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type PostNotificationSendFutureError = Fetcher.ErrorWrapper<undefined>;

export type PostNotificationSendFutureVariables =
  HyperionContext["fetcherOptions"];

/**
 * Send ourself a test notification.
 *
 * **Only admins can use this endpoint**
 */
export const fetchPostNotificationSendFuture = (
  variables: PostNotificationSendFutureVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<void, PostNotificationSendFutureError, undefined, {}, {}, {}>({
    url: "/notification/send/future",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Send ourself a test notification.
 *
 * **Only admins can use this endpoint**
 */
export const usePostNotificationSendFuture = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      void,
      PostNotificationSendFutureError,
      PostNotificationSendFutureVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    void,
    PostNotificationSendFutureError,
    PostNotificationSendFutureVariables
  >({
    mutationFn: (variables: PostNotificationSendFutureVariables) =>
      fetchPostNotificationSendFuture({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetUsersError = Fetcher.ErrorWrapper<undefined>;

export type GetUsersResponse = Schemas.CoreUserSimple[];

export type GetUsersVariables = HyperionContext["fetcherOptions"];

/**
 * Return all users from database as a list of `CoreUserSimple`
 *
 * **This endpoint is only usable by administrators**
 */
export const fetchGetUsers = (
  variables: GetUsersVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<GetUsersResponse, GetUsersError, undefined, {}, {}, {}>({
    url: "/users/",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Return all users from database as a list of `CoreUserSimple`
 *
 * **This endpoint is only usable by administrators**
 */
export const useGetUsers = <TData = GetUsersResponse,>(
  variables: GetUsersVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<GetUsersResponse, GetUsersError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<GetUsersResponse, GetUsersError, TData>({
    queryKey: queryKeyFn({
      path: "/users/",
      operationId: "getUsers",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetUsers({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type GetUsersCountError = Fetcher.ErrorWrapper<undefined>;

export type GetUsersCountVariables = HyperionContext["fetcherOptions"];

/**
 * Return all users from database as a list of `CoreUserSimple`
 *
 * **This endpoint is only usable by administrators**
 */
export const fetchGetUsersCount = (
  variables: GetUsersCountVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<number, GetUsersCountError, undefined, {}, {}, {}>({
    url: "/users/count",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Return all users from database as a list of `CoreUserSimple`
 *
 * **This endpoint is only usable by administrators**
 */
export const useGetUsersCount = <TData = number,>(
  variables: GetUsersCountVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<number, GetUsersCountError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<number, GetUsersCountError, TData>({
    queryKey: queryKeyFn({
      path: "/users/count",
      operationId: "getUsersCount",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetUsersCount({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type GetUsersSearchQueryParams = {
  query: string;
  includedGroups?: string[];
  excludedGroups?: string[];
};

export type GetUsersSearchError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetUsersSearchResponse = Schemas.CoreUserSimple[];

export type GetUsersSearchVariables = {
  queryParams: GetUsersSearchQueryParams;
} & HyperionContext["fetcherOptions"];

/**
 * Search for a user using Fuzzy String Matching
 *
 * `query` will be compared against users name, firstname and nickname
 *
 * **The user must be authenticated to use this endpoint**
 */
export const fetchGetUsersSearch = (
  variables: GetUsersSearchVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetUsersSearchResponse,
    GetUsersSearchError,
    undefined,
    {},
    GetUsersSearchQueryParams,
    {}
  >({ url: "/users/search", method: "get", ...variables, signal });

/**
 * Search for a user using Fuzzy String Matching
 *
 * `query` will be compared against users name, firstname and nickname
 *
 * **The user must be authenticated to use this endpoint**
 */
export const useGetUsersSearch = <TData = GetUsersSearchResponse,>(
  variables: GetUsersSearchVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetUsersSearchResponse,
      GetUsersSearchError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<
    GetUsersSearchResponse,
    GetUsersSearchError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/users/search",
      operationId: "getUsersSearch",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetUsersSearch({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type GetUsersMeError = Fetcher.ErrorWrapper<undefined>;

export type GetUsersMeVariables = HyperionContext["fetcherOptions"];

/**
 * Return `CoreUser` representation of current user
 *
 * **The user must be authenticated to use this endpoint**
 */
export const fetchGetUsersMe = (
  variables: GetUsersMeVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<Schemas.CoreUser, GetUsersMeError, undefined, {}, {}, {}>({
    url: "/users/me",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Return `CoreUser` representation of current user
 *
 * **The user must be authenticated to use this endpoint**
 */
export const useGetUsersMe = <TData = Schemas.CoreUser,>(
  variables: GetUsersMeVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.CoreUser, GetUsersMeError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<Schemas.CoreUser, GetUsersMeError, TData>({
    queryKey: queryKeyFn({
      path: "/users/me",
      operationId: "getUsersMe",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetUsersMe({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type PatchUsersMeError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PatchUsersMeVariables = {
  body?: Schemas.CoreUserUpdate;
} & HyperionContext["fetcherOptions"];

/**
 * Update the current user, the request should contain a JSON with the fields to change (not necessarily all fields) and their new value
 *
 * **The user must be authenticated to use this endpoint**
 */
export const fetchPatchUsersMe = (
  variables: PatchUsersMeVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchUsersMeError,
    Schemas.CoreUserUpdate,
    {},
    {},
    {}
  >({ url: "/users/me", method: "patch", ...variables, signal });

/**
 * Update the current user, the request should contain a JSON with the fields to change (not necessarily all fields) and their new value
 *
 * **The user must be authenticated to use this endpoint**
 */
export const usePatchUsersMe = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchUsersMeError,
      PatchUsersMeVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchUsersMeError,
    PatchUsersMeVariables
  >({
    mutationFn: (variables: PatchUsersMeVariables) =>
      fetchPatchUsersMe({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type PostUsersCreateError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostUsersCreateVariables = {
  body: Schemas.CoreUserCreateRequest;
} & HyperionContext["fetcherOptions"];

/**
 * Start the user account creation process. The user will be sent an email with a link to activate his account.
 * > The received token needs to be sent to the `/users/activate` endpoint to activate the account.
 *
 * If the **password** is not provided, it will be required during the activation process. Don't submit a password if you are creating an account for someone else.
 *
 * When creating **student** or **staff** account a valid ECL email is required.
 * Only admin users can create other **account types**, contact CLAIR for more information.
 */
export const fetchPostUsersCreate = (
  variables: PostUsersCreateVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.AppCoreStandardResponsesResult,
    PostUsersCreateError,
    Schemas.CoreUserCreateRequest,
    {},
    {},
    {}
  >({ url: "/users/create", method: "post", ...variables, signal });

/**
 * Start the user account creation process. The user will be sent an email with a link to activate his account.
 * > The received token needs to be sent to the `/users/activate` endpoint to activate the account.
 *
 * If the **password** is not provided, it will be required during the activation process. Don't submit a password if you are creating an account for someone else.
 *
 * When creating **student** or **staff** account a valid ECL email is required.
 * Only admin users can create other **account types**, contact CLAIR for more information.
 */
export const usePostUsersCreate = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.AppCoreStandardResponsesResult,
      PostUsersCreateError,
      PostUsersCreateVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.AppCoreStandardResponsesResult,
    PostUsersCreateError,
    PostUsersCreateVariables
  >({
    mutationFn: (variables: PostUsersCreateVariables) =>
      fetchPostUsersCreate({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type PostUsersBatchCreationError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostUsersBatchCreationRequestBody =
  Schemas.CoreBatchUserCreateRequest[];

export type PostUsersBatchCreationVariables = {
  body?: PostUsersBatchCreationRequestBody;
} & HyperionContext["fetcherOptions"];

/**
 * Batch user account creation process. All users will be sent an email with a link to activate their account.
 * > The received token needs to be send to `/users/activate` endpoint to activate the account.
 *
 * Even for creating **student** or **staff** account a valid ECL email is not required but should preferably be used.
 *
 * The endpoint return a dictionary of unsuccessful user creation: `{email: error message}`.
 *
 * **This endpoint is only usable by administrators**
 */
export const fetchPostUsersBatchCreation = (
  variables: PostUsersBatchCreationVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.BatchResult,
    PostUsersBatchCreationError,
    PostUsersBatchCreationRequestBody,
    {},
    {},
    {}
  >({ url: "/users/batch-creation", method: "post", ...variables, signal });

/**
 * Batch user account creation process. All users will be sent an email with a link to activate their account.
 * > The received token needs to be send to `/users/activate` endpoint to activate the account.
 *
 * Even for creating **student** or **staff** account a valid ECL email is not required but should preferably be used.
 *
 * The endpoint return a dictionary of unsuccessful user creation: `{email: error message}`.
 *
 * **This endpoint is only usable by administrators**
 */
export const usePostUsersBatchCreation = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.BatchResult,
      PostUsersBatchCreationError,
      PostUsersBatchCreationVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.BatchResult,
    PostUsersBatchCreationError,
    PostUsersBatchCreationVariables
  >({
    mutationFn: (variables: PostUsersBatchCreationVariables) =>
      fetchPostUsersBatchCreation({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetUsersActivateQueryParams = {
  activation_token: string;
};

export type GetUsersActivateError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetUsersActivateVariables = {
  queryParams: GetUsersActivateQueryParams;
} & HyperionContext["fetcherOptions"];

/**
 * Return a HTML page to activate an account. The activation token is passed as a query string.
 *
 * **This endpoint is an UI endpoint which send and html page response.
 */
export const fetchGetUsersActivate = (
  variables: GetUsersActivateVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    GetUsersActivateError,
    undefined,
    {},
    GetUsersActivateQueryParams,
    {}
  >({ url: "/users/activate", method: "get", ...variables, signal });

/**
 * Return a HTML page to activate an account. The activation token is passed as a query string.
 *
 * **This endpoint is an UI endpoint which send and html page response.
 */
export const useGetUsersActivate = <TData = undefined,>(
  variables: GetUsersActivateVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, GetUsersActivateError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<undefined, GetUsersActivateError, TData>({
    queryKey: queryKeyFn({
      path: "/users/activate",
      operationId: "getUsersActivate",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetUsersActivate({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type PostUsersActivateError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostUsersActivateVariables = {
  body: Schemas.CoreUserActivateRequest;
} & HyperionContext["fetcherOptions"];

/**
 * Activate the previously created account.
 *
 * **token**: the activation token sent by email to the user
 *
 * **password**: user password, required if it was not provided previously
 */
export const fetchPostUsersActivate = (
  variables: PostUsersActivateVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.AppCoreStandardResponsesResult,
    PostUsersActivateError,
    Schemas.CoreUserActivateRequest,
    {},
    {},
    {}
  >({ url: "/users/activate", method: "post", ...variables, signal });

/**
 * Activate the previously created account.
 *
 * **token**: the activation token sent by email to the user
 *
 * **password**: user password, required if it was not provided previously
 */
export const usePostUsersActivate = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.AppCoreStandardResponsesResult,
      PostUsersActivateError,
      PostUsersActivateVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.AppCoreStandardResponsesResult,
    PostUsersActivateError,
    PostUsersActivateVariables
  >({
    mutationFn: (variables: PostUsersActivateVariables) =>
      fetchPostUsersActivate({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type PostUsersMakeAdminError = Fetcher.ErrorWrapper<undefined>;

export type PostUsersMakeAdminVariables = HyperionContext["fetcherOptions"];

/**
 * This endpoint is only usable if the database contains exactly one user.
 * It will add this user to the `admin` group.
 */
export const fetchPostUsersMakeAdmin = (
  variables: PostUsersMakeAdminVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.AppCoreStandardResponsesResult,
    PostUsersMakeAdminError,
    undefined,
    {},
    {},
    {}
  >({ url: "/users/make-admin", method: "post", ...variables, signal });

/**
 * This endpoint is only usable if the database contains exactly one user.
 * It will add this user to the `admin` group.
 */
export const usePostUsersMakeAdmin = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.AppCoreStandardResponsesResult,
      PostUsersMakeAdminError,
      PostUsersMakeAdminVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.AppCoreStandardResponsesResult,
    PostUsersMakeAdminError,
    PostUsersMakeAdminVariables
  >({
    mutationFn: (variables: PostUsersMakeAdminVariables) =>
      fetchPostUsersMakeAdmin({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type PostUsersRecoverError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostUsersRecoverVariables = {
  body: Schemas.BodyRecoverUserUsersRecoverPost;
} & HyperionContext["fetcherOptions"];

/**
 * Allow a user to start a password reset process.
 *
 * If the provided **email** corresponds to an existing account, a password reset token will be sent.
 * Using this token, the password can be changed with `/users/reset-password` endpoint
 */
export const fetchPostUsersRecover = (
  variables: PostUsersRecoverVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.AppCoreStandardResponsesResult,
    PostUsersRecoverError,
    Schemas.BodyRecoverUserUsersRecoverPost,
    {},
    {},
    {}
  >({ url: "/users/recover", method: "post", ...variables, signal });

/**
 * Allow a user to start a password reset process.
 *
 * If the provided **email** corresponds to an existing account, a password reset token will be sent.
 * Using this token, the password can be changed with `/users/reset-password` endpoint
 */
export const usePostUsersRecover = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.AppCoreStandardResponsesResult,
      PostUsersRecoverError,
      PostUsersRecoverVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.AppCoreStandardResponsesResult,
    PostUsersRecoverError,
    PostUsersRecoverVariables
  >({
    mutationFn: (variables: PostUsersRecoverVariables) =>
      fetchPostUsersRecover({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type PostUsersResetPasswordError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostUsersResetPasswordVariables = {
  body: Schemas.ResetPasswordRequest;
} & HyperionContext["fetcherOptions"];

/**
 * Reset the user password, using a **reset_token** provided by `/users/recover` endpoint.
 */
export const fetchPostUsersResetPassword = (
  variables: PostUsersResetPasswordVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.AppCoreStandardResponsesResult,
    PostUsersResetPasswordError,
    Schemas.ResetPasswordRequest,
    {},
    {},
    {}
  >({ url: "/users/reset-password", method: "post", ...variables, signal });

/**
 * Reset the user password, using a **reset_token** provided by `/users/recover` endpoint.
 */
export const usePostUsersResetPassword = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.AppCoreStandardResponsesResult,
      PostUsersResetPasswordError,
      PostUsersResetPasswordVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.AppCoreStandardResponsesResult,
    PostUsersResetPasswordError,
    PostUsersResetPasswordVariables
  >({
    mutationFn: (variables: PostUsersResetPasswordVariables) =>
      fetchPostUsersResetPassword({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type PostUsersMigrateMailError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostUsersMigrateMailVariables = {
  body: Schemas.MailMigrationRequest;
} & HyperionContext["fetcherOptions"];

/**
 * Due to a change in the email format, all student users need to migrate their email address.
 * This endpoint will send a confirmation code to the user's new email address. He will need to use this code to confirm the change with `/users/confirm-mail-migration` endpoint.
 */
export const fetchPostUsersMigrateMail = (
  variables: PostUsersMigrateMailVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PostUsersMigrateMailError,
    Schemas.MailMigrationRequest,
    {},
    {},
    {}
  >({ url: "/users/migrate-mail", method: "post", ...variables, signal });

/**
 * Due to a change in the email format, all student users need to migrate their email address.
 * This endpoint will send a confirmation code to the user's new email address. He will need to use this code to confirm the change with `/users/confirm-mail-migration` endpoint.
 */
export const usePostUsersMigrateMail = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PostUsersMigrateMailError,
      PostUsersMigrateMailVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PostUsersMigrateMailError,
    PostUsersMigrateMailVariables
  >({
    mutationFn: (variables: PostUsersMigrateMailVariables) =>
      fetchPostUsersMigrateMail({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetUsersMigrateMailConfirmQueryParams = {
  token: string;
};

export type GetUsersMigrateMailConfirmError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetUsersMigrateMailConfirmVariables = {
  queryParams: GetUsersMigrateMailConfirmQueryParams;
} & HyperionContext["fetcherOptions"];

/**
 * Due to a change in the email format, all student users need to migrate their email address.
 * This endpoint will updates the user new email address.
 */
export const fetchGetUsersMigrateMailConfirm = (
  variables: GetUsersMigrateMailConfirmVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    void,
    GetUsersMigrateMailConfirmError,
    undefined,
    {},
    GetUsersMigrateMailConfirmQueryParams,
    {}
  >({
    url: "/users/migrate-mail-confirm",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Due to a change in the email format, all student users need to migrate their email address.
 * This endpoint will updates the user new email address.
 */
export const useGetUsersMigrateMailConfirm = <TData = void,>(
  variables: GetUsersMigrateMailConfirmVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<void, GetUsersMigrateMailConfirmError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<void, GetUsersMigrateMailConfirmError, TData>({
    queryKey: queryKeyFn({
      path: "/users/migrate-mail-confirm",
      operationId: "getUsersMigrateMailConfirm",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetUsersMigrateMailConfirm(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type PostUsersChangePasswordError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostUsersChangePasswordVariables = {
  body: Schemas.ChangePasswordRequest;
} & HyperionContext["fetcherOptions"];

/**
 * Change a user password.
 *
 * This endpoint will check the **old_password**, see also the `/users/reset-password` endpoint if the user forgot their password.
 */
export const fetchPostUsersChangePassword = (
  variables: PostUsersChangePasswordVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.AppCoreStandardResponsesResult,
    PostUsersChangePasswordError,
    Schemas.ChangePasswordRequest,
    {},
    {},
    {}
  >({ url: "/users/change-password", method: "post", ...variables, signal });

/**
 * Change a user password.
 *
 * This endpoint will check the **old_password**, see also the `/users/reset-password` endpoint if the user forgot their password.
 */
export const usePostUsersChangePassword = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.AppCoreStandardResponsesResult,
      PostUsersChangePasswordError,
      PostUsersChangePasswordVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.AppCoreStandardResponsesResult,
    PostUsersChangePasswordError,
    PostUsersChangePasswordVariables
  >({
    mutationFn: (variables: PostUsersChangePasswordVariables) =>
      fetchPostUsersChangePassword({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetUsersUserIdPathParams = {
  userId: string;
};

export type GetUsersUserIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetUsersUserIdVariables = {
  pathParams: GetUsersUserIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Return `CoreUserSimple` representation of user with id `user_id`
 *
 * **The user must be authenticated to use this endpoint**
 */
export const fetchGetUsersUserId = (
  variables: GetUsersUserIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.CoreUser,
    GetUsersUserIdError,
    undefined,
    {},
    {},
    GetUsersUserIdPathParams
  >({ url: "/users/{userId}", method: "get", ...variables, signal });

/**
 * Return `CoreUserSimple` representation of user with id `user_id`
 *
 * **The user must be authenticated to use this endpoint**
 */
export const useGetUsersUserId = <TData = Schemas.CoreUser,>(
  variables: GetUsersUserIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.CoreUser, GetUsersUserIdError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<Schemas.CoreUser, GetUsersUserIdError, TData>({
    queryKey: queryKeyFn({
      path: "/users/{userId}",
      operationId: "getUsersUserId",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetUsersUserId({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type PatchUsersUserIdPathParams = {
  userId: string;
};

export type PatchUsersUserIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PatchUsersUserIdVariables = {
  body?: Schemas.CoreUserUpdateAdmin;
  pathParams: PatchUsersUserIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Update an user, the request should contain a JSON with the fields to change (not necessarily all fields) and their new value
 *
 * **This endpoint is only usable by administrators**
 */
export const fetchPatchUsersUserId = (
  variables: PatchUsersUserIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchUsersUserIdError,
    Schemas.CoreUserUpdateAdmin,
    {},
    {},
    PatchUsersUserIdPathParams
  >({ url: "/users/{userId}", method: "patch", ...variables, signal });

/**
 * Update an user, the request should contain a JSON with the fields to change (not necessarily all fields) and their new value
 *
 * **This endpoint is only usable by administrators**
 */
export const usePatchUsersUserId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchUsersUserIdError,
      PatchUsersUserIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchUsersUserIdError,
    PatchUsersUserIdVariables
  >({
    mutationFn: (variables: PatchUsersUserIdVariables) =>
      fetchPatchUsersUserId({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type PostUsersMeAskDeletionError = Fetcher.ErrorWrapper<undefined>;

export type PostUsersMeAskDeletionVariables = HyperionContext["fetcherOptions"];

/**
 * This endpoint will ask administrators to process to the user deletion.
 * This manual verification is needed to prevent data from being deleting for other users
 */
export const fetchPostUsersMeAskDeletion = (
  variables: PostUsersMeAskDeletionVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<undefined, PostUsersMeAskDeletionError, undefined, {}, {}, {}>({
    url: "/users/me/ask-deletion",
    method: "post",
    ...variables,
    signal,
  });

/**
 * This endpoint will ask administrators to process to the user deletion.
 * This manual verification is needed to prevent data from being deleting for other users
 */
export const usePostUsersMeAskDeletion = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PostUsersMeAskDeletionError,
      PostUsersMeAskDeletionVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PostUsersMeAskDeletionError,
    PostUsersMeAskDeletionVariables
  >({
    mutationFn: (variables: PostUsersMeAskDeletionVariables) =>
      fetchPostUsersMeAskDeletion({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetUsersMeProfilePictureError = Fetcher.ErrorWrapper<undefined>;

export type GetUsersMeProfilePictureVariables =
  HyperionContext["fetcherOptions"];

/**
 * Get the profile picture of the authenticated user.
 */
export const fetchGetUsersMeProfilePicture = (
  variables: GetUsersMeProfilePictureVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    GetUsersMeProfilePictureError,
    undefined,
    {},
    {},
    {}
  >({ url: "/users/me/profile-picture", method: "get", ...variables, signal });

/**
 * Get the profile picture of the authenticated user.
 */
export const useGetUsersMeProfilePicture = <TData = undefined,>(
  variables: GetUsersMeProfilePictureVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, GetUsersMeProfilePictureError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<undefined, GetUsersMeProfilePictureError, TData>({
    queryKey: queryKeyFn({
      path: "/users/me/profile-picture",
      operationId: "getUsersMeProfilePicture",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetUsersMeProfilePicture(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type PostUsersMeProfilePictureError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostUsersMeProfilePictureVariables = {
  body: Schemas.BodyCreateCurrentUserProfilePictureUsersMeProfilePicturePost;
} & HyperionContext["fetcherOptions"];

/**
 * Upload a profile picture for the current user.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const fetchPostUsersMeProfilePicture = (
  variables: PostUsersMeProfilePictureVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.AppCoreStandardResponsesResult,
    PostUsersMeProfilePictureError,
    Schemas.BodyCreateCurrentUserProfilePictureUsersMeProfilePicturePost,
    {},
    {},
    {}
  >({ url: "/users/me/profile-picture", method: "post", ...variables, signal });

/**
 * Upload a profile picture for the current user.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const usePostUsersMeProfilePicture = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.AppCoreStandardResponsesResult,
      PostUsersMeProfilePictureError,
      PostUsersMeProfilePictureVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.AppCoreStandardResponsesResult,
    PostUsersMeProfilePictureError,
    PostUsersMeProfilePictureVariables
  >({
    mutationFn: (variables: PostUsersMeProfilePictureVariables) =>
      fetchPostUsersMeProfilePicture({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetUsersUserIdProfilePicturePathParams = {
  userId: string;
};

export type GetUsersUserIdProfilePictureError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetUsersUserIdProfilePictureVariables = {
  pathParams: GetUsersUserIdProfilePicturePathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Get the profile picture of an user.
 *
 * Unauthenticated users can use this endpoint (needed for some OIDC services)
 */
export const fetchGetUsersUserIdProfilePicture = (
  variables: GetUsersUserIdProfilePictureVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    GetUsersUserIdProfilePictureError,
    undefined,
    {},
    {},
    GetUsersUserIdProfilePicturePathParams
  >({
    url: "/users/{userId}/profile-picture",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get the profile picture of an user.
 *
 * Unauthenticated users can use this endpoint (needed for some OIDC services)
 */
export const useGetUsersUserIdProfilePicture = <TData = undefined,>(
  variables: GetUsersUserIdProfilePictureVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      undefined,
      GetUsersUserIdProfilePictureError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<
    undefined,
    GetUsersUserIdProfilePictureError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/users/{userId}/profile-picture",
      operationId: "getUsersUserIdProfilePicture",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetUsersUserIdProfilePicture(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type GetAdvertAdvertisersError = Fetcher.ErrorWrapper<undefined>;

export type GetAdvertAdvertisersResponse = Schemas.AdvertiserComplete[];

export type GetAdvertAdvertisersVariables = HyperionContext["fetcherOptions"];

/**
 * Get existing advertisers.
 */
export const fetchGetAdvertAdvertisers = (
  variables: GetAdvertAdvertisersVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetAdvertAdvertisersResponse,
    GetAdvertAdvertisersError,
    undefined,
    {},
    {},
    {}
  >({ url: "/advert/advertisers", method: "get", ...variables, signal });

/**
 * Get existing advertisers.
 */
export const useGetAdvertAdvertisers = <TData = GetAdvertAdvertisersResponse,>(
  variables: GetAdvertAdvertisersVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetAdvertAdvertisersResponse,
      GetAdvertAdvertisersError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<
    GetAdvertAdvertisersResponse,
    GetAdvertAdvertisersError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/advert/advertisers",
      operationId: "getAdvertAdvertisers",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetAdvertAdvertisers({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type PostAdvertAdvertisersError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostAdvertAdvertisersVariables = {
  body: Schemas.AdvertiserBase;
} & HyperionContext["fetcherOptions"];

/**
 * Create a new advertiser.
 *
 * Each advertiser is associated with a `manager_group`. Users belonging to this group are able to manage the adverts related to the advertiser.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const fetchPostAdvertAdvertisers = (
  variables: PostAdvertAdvertisersVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.AdvertiserComplete,
    PostAdvertAdvertisersError,
    Schemas.AdvertiserBase,
    {},
    {},
    {}
  >({ url: "/advert/advertisers", method: "post", ...variables, signal });

/**
 * Create a new advertiser.
 *
 * Each advertiser is associated with a `manager_group`. Users belonging to this group are able to manage the adverts related to the advertiser.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const usePostAdvertAdvertisers = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.AdvertiserComplete,
      PostAdvertAdvertisersError,
      PostAdvertAdvertisersVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.AdvertiserComplete,
    PostAdvertAdvertisersError,
    PostAdvertAdvertisersVariables
  >({
    mutationFn: (variables: PostAdvertAdvertisersVariables) =>
      fetchPostAdvertAdvertisers({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type DeleteAdvertAdvertisersAdvertiserIdPathParams = {
  advertiserId: string;
};

export type DeleteAdvertAdvertisersAdvertiserIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type DeleteAdvertAdvertisersAdvertiserIdVariables = {
  pathParams: DeleteAdvertAdvertisersAdvertiserIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Delete an advertiser. All adverts associated with the advertiser will also be deleted from the database.
 *
 * **This endpoint is only usable by administrators**
 */
export const fetchDeleteAdvertAdvertisersAdvertiserId = (
  variables: DeleteAdvertAdvertisersAdvertiserIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteAdvertAdvertisersAdvertiserIdError,
    undefined,
    {},
    {},
    DeleteAdvertAdvertisersAdvertiserIdPathParams
  >({
    url: "/advert/advertisers/{advertiserId}",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * Delete an advertiser. All adverts associated with the advertiser will also be deleted from the database.
 *
 * **This endpoint is only usable by administrators**
 */
export const useDeleteAdvertAdvertisersAdvertiserId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteAdvertAdvertisersAdvertiserIdError,
      DeleteAdvertAdvertisersAdvertiserIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteAdvertAdvertisersAdvertiserIdError,
    DeleteAdvertAdvertisersAdvertiserIdVariables
  >({
    mutationFn: (variables: DeleteAdvertAdvertisersAdvertiserIdVariables) =>
      fetchDeleteAdvertAdvertisersAdvertiserId({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type PatchAdvertAdvertisersAdvertiserIdPathParams = {
  advertiserId: string;
};

export type PatchAdvertAdvertisersAdvertiserIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PatchAdvertAdvertisersAdvertiserIdVariables = {
  body?: Schemas.AdvertiserUpdate;
  pathParams: PatchAdvertAdvertisersAdvertiserIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Update an advertiser
 *
 * **This endpoint is only usable by administrators**
 */
export const fetchPatchAdvertAdvertisersAdvertiserId = (
  variables: PatchAdvertAdvertisersAdvertiserIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchAdvertAdvertisersAdvertiserIdError,
    Schemas.AdvertiserUpdate,
    {},
    {},
    PatchAdvertAdvertisersAdvertiserIdPathParams
  >({
    url: "/advert/advertisers/{advertiserId}",
    method: "patch",
    ...variables,
    signal,
  });

/**
 * Update an advertiser
 *
 * **This endpoint is only usable by administrators**
 */
export const usePatchAdvertAdvertisersAdvertiserId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchAdvertAdvertisersAdvertiserIdError,
      PatchAdvertAdvertisersAdvertiserIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchAdvertAdvertisersAdvertiserIdError,
    PatchAdvertAdvertisersAdvertiserIdVariables
  >({
    mutationFn: (variables: PatchAdvertAdvertisersAdvertiserIdVariables) =>
      fetchPatchAdvertAdvertisersAdvertiserId({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type GetAdvertMeAdvertisersError = Fetcher.ErrorWrapper<undefined>;

export type GetAdvertMeAdvertisersResponse = Schemas.AdvertiserComplete[];

export type GetAdvertMeAdvertisersVariables = HyperionContext["fetcherOptions"];

/**
 * Return all advertisers the current user can manage.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const fetchGetAdvertMeAdvertisers = (
  variables: GetAdvertMeAdvertisersVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetAdvertMeAdvertisersResponse,
    GetAdvertMeAdvertisersError,
    undefined,
    {},
    {},
    {}
  >({ url: "/advert/me/advertisers", method: "get", ...variables, signal });

/**
 * Return all advertisers the current user can manage.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const useGetAdvertMeAdvertisers = <
  TData = GetAdvertMeAdvertisersResponse,
>(
  variables: GetAdvertMeAdvertisersVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetAdvertMeAdvertisersResponse,
      GetAdvertMeAdvertisersError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<
    GetAdvertMeAdvertisersResponse,
    GetAdvertMeAdvertisersError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/advert/me/advertisers",
      operationId: "getAdvertMeAdvertisers",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetAdvertMeAdvertisers({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type GetAdvertAdvertsQueryParams = {
  advertisers?: string[];
};

export type GetAdvertAdvertsError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetAdvertAdvertsResponse = Schemas.AdvertReturnComplete[];

export type GetAdvertAdvertsVariables = {
  queryParams?: GetAdvertAdvertsQueryParams;
} & HyperionContext["fetcherOptions"];

/**
 * Get existing adverts. If advertisers optional parameter is used, search adverts by advertisers
 *
 * **The user must be authenticated to use this endpoint**
 */
export const fetchGetAdvertAdverts = (
  variables: GetAdvertAdvertsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetAdvertAdvertsResponse,
    GetAdvertAdvertsError,
    undefined,
    {},
    GetAdvertAdvertsQueryParams,
    {}
  >({ url: "/advert/adverts", method: "get", ...variables, signal });

/**
 * Get existing adverts. If advertisers optional parameter is used, search adverts by advertisers
 *
 * **The user must be authenticated to use this endpoint**
 */
export const useGetAdvertAdverts = <TData = GetAdvertAdvertsResponse,>(
  variables: GetAdvertAdvertsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetAdvertAdvertsResponse,
      GetAdvertAdvertsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<
    GetAdvertAdvertsResponse,
    GetAdvertAdvertsError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/advert/adverts",
      operationId: "getAdvertAdverts",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetAdvertAdverts({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type PostAdvertAdvertsError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostAdvertAdvertsVariables = {
  body: Schemas.AdvertBase;
} & HyperionContext["fetcherOptions"];

/**
 * Create a new advert
 *
 * **The user must be a member of the advertiser group_manager to use this endpoint**
 */
export const fetchPostAdvertAdverts = (
  variables: PostAdvertAdvertsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.AdvertReturnComplete,
    PostAdvertAdvertsError,
    Schemas.AdvertBase,
    {},
    {},
    {}
  >({ url: "/advert/adverts", method: "post", ...variables, signal });

/**
 * Create a new advert
 *
 * **The user must be a member of the advertiser group_manager to use this endpoint**
 */
export const usePostAdvertAdverts = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.AdvertReturnComplete,
      PostAdvertAdvertsError,
      PostAdvertAdvertsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.AdvertReturnComplete,
    PostAdvertAdvertsError,
    PostAdvertAdvertsVariables
  >({
    mutationFn: (variables: PostAdvertAdvertsVariables) =>
      fetchPostAdvertAdverts({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetAdvertAdvertsAdvertIdPathParams = {
  advertId: string;
};

export type GetAdvertAdvertsAdvertIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetAdvertAdvertsAdvertIdVariables = {
  pathParams: GetAdvertAdvertsAdvertIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Get an advert
 *
 * **The user must be authenticated to use this endpoint**
 */
export const fetchGetAdvertAdvertsAdvertId = (
  variables: GetAdvertAdvertsAdvertIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.AdvertReturnComplete,
    GetAdvertAdvertsAdvertIdError,
    undefined,
    {},
    {},
    GetAdvertAdvertsAdvertIdPathParams
  >({ url: "/advert/adverts/{advertId}", method: "get", ...variables, signal });

/**
 * Get an advert
 *
 * **The user must be authenticated to use this endpoint**
 */
export const useGetAdvertAdvertsAdvertId = <
  TData = Schemas.AdvertReturnComplete,
>(
  variables: GetAdvertAdvertsAdvertIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.AdvertReturnComplete,
      GetAdvertAdvertsAdvertIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<
    Schemas.AdvertReturnComplete,
    GetAdvertAdvertsAdvertIdError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/advert/adverts/{advertId}",
      operationId: "getAdvertAdvertsAdvertId",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetAdvertAdvertsAdvertId(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type PatchAdvertAdvertsAdvertIdPathParams = {
  advertId: string;
};

export type PatchAdvertAdvertsAdvertIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PatchAdvertAdvertsAdvertIdVariables = {
  body?: Schemas.AdvertUpdate;
  pathParams: PatchAdvertAdvertsAdvertIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Edit an advert
 *
 * **The user must be a member of the advertiser group_manager to use this endpoint**
 */
export const fetchPatchAdvertAdvertsAdvertId = (
  variables: PatchAdvertAdvertsAdvertIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchAdvertAdvertsAdvertIdError,
    Schemas.AdvertUpdate,
    {},
    {},
    PatchAdvertAdvertsAdvertIdPathParams
  >({
    url: "/advert/adverts/{advertId}",
    method: "patch",
    ...variables,
    signal,
  });

/**
 * Edit an advert
 *
 * **The user must be a member of the advertiser group_manager to use this endpoint**
 */
export const usePatchAdvertAdvertsAdvertId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchAdvertAdvertsAdvertIdError,
      PatchAdvertAdvertsAdvertIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchAdvertAdvertsAdvertIdError,
    PatchAdvertAdvertsAdvertIdVariables
  >({
    mutationFn: (variables: PatchAdvertAdvertsAdvertIdVariables) =>
      fetchPatchAdvertAdvertsAdvertId({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type DeleteAdvertAdvertsAdvertIdPathParams = {
  advertId: string;
};

export type DeleteAdvertAdvertsAdvertIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type DeleteAdvertAdvertsAdvertIdVariables = {
  pathParams: DeleteAdvertAdvertsAdvertIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Delete an advert
 *
 * **The user must be admin or a member of the advertiser group_manager to use this endpoint**
 */
export const fetchDeleteAdvertAdvertsAdvertId = (
  variables: DeleteAdvertAdvertsAdvertIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteAdvertAdvertsAdvertIdError,
    undefined,
    {},
    {},
    DeleteAdvertAdvertsAdvertIdPathParams
  >({
    url: "/advert/adverts/{advertId}",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * Delete an advert
 *
 * **The user must be admin or a member of the advertiser group_manager to use this endpoint**
 */
export const useDeleteAdvertAdvertsAdvertId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteAdvertAdvertsAdvertIdError,
      DeleteAdvertAdvertsAdvertIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteAdvertAdvertsAdvertIdError,
    DeleteAdvertAdvertsAdvertIdVariables
  >({
    mutationFn: (variables: DeleteAdvertAdvertsAdvertIdVariables) =>
      fetchDeleteAdvertAdvertsAdvertId({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetAdvertAdvertsAdvertIdPicturePathParams = {
  advertId: string;
};

export type GetAdvertAdvertsAdvertIdPictureError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetAdvertAdvertsAdvertIdPictureVariables = {
  pathParams: GetAdvertAdvertsAdvertIdPicturePathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Get the image of an advert
 *
 * **The user must be authenticated to use this endpoint**
 */
export const fetchGetAdvertAdvertsAdvertIdPicture = (
  variables: GetAdvertAdvertsAdvertIdPictureVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    GetAdvertAdvertsAdvertIdPictureError,
    undefined,
    {},
    {},
    GetAdvertAdvertsAdvertIdPicturePathParams
  >({
    url: "/advert/adverts/{advertId}/picture",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get the image of an advert
 *
 * **The user must be authenticated to use this endpoint**
 */
export const useGetAdvertAdvertsAdvertIdPicture = <TData = undefined,>(
  variables: GetAdvertAdvertsAdvertIdPictureVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      undefined,
      GetAdvertAdvertsAdvertIdPictureError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<
    undefined,
    GetAdvertAdvertsAdvertIdPictureError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/advert/adverts/{advertId}/picture",
      operationId: "getAdvertAdvertsAdvertIdPicture",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetAdvertAdvertsAdvertIdPicture(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type PostAdvertAdvertsAdvertIdPicturePathParams = {
  advertId: string;
};

export type PostAdvertAdvertsAdvertIdPictureError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostAdvertAdvertsAdvertIdPictureVariables = {
  body: Schemas.BodyCreateAdvertImageAdvertAdvertsAdvertIdPicturePost;
  pathParams: PostAdvertAdvertsAdvertIdPicturePathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Add an image to an advert
 *
 * **The user must be authenticated to use this endpoint**
 */
export const fetchPostAdvertAdvertsAdvertIdPicture = (
  variables: PostAdvertAdvertsAdvertIdPictureVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.AppCoreStandardResponsesResult,
    PostAdvertAdvertsAdvertIdPictureError,
    Schemas.BodyCreateAdvertImageAdvertAdvertsAdvertIdPicturePost,
    {},
    {},
    PostAdvertAdvertsAdvertIdPicturePathParams
  >({
    url: "/advert/adverts/{advertId}/picture",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Add an image to an advert
 *
 * **The user must be authenticated to use this endpoint**
 */
export const usePostAdvertAdvertsAdvertIdPicture = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.AppCoreStandardResponsesResult,
      PostAdvertAdvertsAdvertIdPictureError,
      PostAdvertAdvertsAdvertIdPictureVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.AppCoreStandardResponsesResult,
    PostAdvertAdvertsAdvertIdPictureError,
    PostAdvertAdvertsAdvertIdPictureVariables
  >({
    mutationFn: (variables: PostAdvertAdvertsAdvertIdPictureVariables) =>
      fetchPostAdvertAdvertsAdvertIdPicture({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type GetAmapProductsError = Fetcher.ErrorWrapper<undefined>;

export type GetAmapProductsResponse =
  Schemas.AppModulesAmapSchemasAmapProductComplete[];

export type GetAmapProductsVariables = HyperionContext["fetcherOptions"];

/**
 * Return all products
 *
 * **The user must be a member of the group AMAP to use this endpoint**
 */
export const fetchGetAmapProducts = (
  variables: GetAmapProductsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetAmapProductsResponse,
    GetAmapProductsError,
    undefined,
    {},
    {},
    {}
  >({ url: "/amap/products", method: "get", ...variables, signal });

/**
 * Return all products
 *
 * **The user must be a member of the group AMAP to use this endpoint**
 */
export const useGetAmapProducts = <TData = GetAmapProductsResponse,>(
  variables: GetAmapProductsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetAmapProductsResponse,
      GetAmapProductsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<
    GetAmapProductsResponse,
    GetAmapProductsError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/amap/products",
      operationId: "getAmapProducts",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetAmapProducts({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type PostAmapProductsError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostAmapProductsVariables = {
  body: Schemas.ProductSimple;
} & HyperionContext["fetcherOptions"];

/**
 * Create a new product
 *
 * **The user must be a member of the group AMAP to use this endpoint**
 */
export const fetchPostAmapProducts = (
  variables: PostAmapProductsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.AppModulesAmapSchemasAmapProductComplete,
    PostAmapProductsError,
    Schemas.ProductSimple,
    {},
    {},
    {}
  >({ url: "/amap/products", method: "post", ...variables, signal });

/**
 * Create a new product
 *
 * **The user must be a member of the group AMAP to use this endpoint**
 */
export const usePostAmapProducts = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.AppModulesAmapSchemasAmapProductComplete,
      PostAmapProductsError,
      PostAmapProductsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.AppModulesAmapSchemasAmapProductComplete,
    PostAmapProductsError,
    PostAmapProductsVariables
  >({
    mutationFn: (variables: PostAmapProductsVariables) =>
      fetchPostAmapProducts({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetAmapProductsProductIdPathParams = {
  productId: string;
};

export type GetAmapProductsProductIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetAmapProductsProductIdVariables = {
  pathParams: GetAmapProductsProductIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Get a specific product
 */
export const fetchGetAmapProductsProductId = (
  variables: GetAmapProductsProductIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.AppModulesAmapSchemasAmapProductComplete,
    GetAmapProductsProductIdError,
    undefined,
    {},
    {},
    GetAmapProductsProductIdPathParams
  >({ url: "/amap/products/{productId}", method: "get", ...variables, signal });

/**
 * Get a specific product
 */
export const useGetAmapProductsProductId = <
  TData = Schemas.AppModulesAmapSchemasAmapProductComplete,
>(
  variables: GetAmapProductsProductIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.AppModulesAmapSchemasAmapProductComplete,
      GetAmapProductsProductIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<
    Schemas.AppModulesAmapSchemasAmapProductComplete,
    GetAmapProductsProductIdError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/amap/products/{productId}",
      operationId: "getAmapProductsProductId",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetAmapProductsProductId(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type PatchAmapProductsProductIdPathParams = {
  productId: string;
};

export type PatchAmapProductsProductIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PatchAmapProductsProductIdVariables = {
  body?: Schemas.AppModulesAmapSchemasAmapProductEdit;
  pathParams: PatchAmapProductsProductIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Edit a product
 *
 * **The user must be a member of the group AMAP to use this endpoint**
 */
export const fetchPatchAmapProductsProductId = (
  variables: PatchAmapProductsProductIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchAmapProductsProductIdError,
    Schemas.AppModulesAmapSchemasAmapProductEdit,
    {},
    {},
    PatchAmapProductsProductIdPathParams
  >({
    url: "/amap/products/{productId}",
    method: "patch",
    ...variables,
    signal,
  });

/**
 * Edit a product
 *
 * **The user must be a member of the group AMAP to use this endpoint**
 */
export const usePatchAmapProductsProductId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchAmapProductsProductIdError,
      PatchAmapProductsProductIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchAmapProductsProductIdError,
    PatchAmapProductsProductIdVariables
  >({
    mutationFn: (variables: PatchAmapProductsProductIdVariables) =>
      fetchPatchAmapProductsProductId({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type DeleteAmapProductsProductIdPathParams = {
  productId: string;
};

export type DeleteAmapProductsProductIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type DeleteAmapProductsProductIdVariables = {
  pathParams: DeleteAmapProductsProductIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Delete a product. A product can not be deleted if it is already used in a delivery.
 *
 * **The user must be a member of the group AMAP to use this endpoint**
 */
export const fetchDeleteAmapProductsProductId = (
  variables: DeleteAmapProductsProductIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteAmapProductsProductIdError,
    undefined,
    {},
    {},
    DeleteAmapProductsProductIdPathParams
  >({
    url: "/amap/products/{productId}",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * Delete a product. A product can not be deleted if it is already used in a delivery.
 *
 * **The user must be a member of the group AMAP to use this endpoint**
 */
export const useDeleteAmapProductsProductId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteAmapProductsProductIdError,
      DeleteAmapProductsProductIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteAmapProductsProductIdError,
    DeleteAmapProductsProductIdVariables
  >({
    mutationFn: (variables: DeleteAmapProductsProductIdVariables) =>
      fetchDeleteAmapProductsProductId({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetAmapDeliveriesError = Fetcher.ErrorWrapper<undefined>;

export type GetAmapDeliveriesResponse = Schemas.DeliveryReturn[];

export type GetAmapDeliveriesVariables = HyperionContext["fetcherOptions"];

/**
 * Get all deliveries.
 */
export const fetchGetAmapDeliveries = (
  variables: GetAmapDeliveriesVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetAmapDeliveriesResponse,
    GetAmapDeliveriesError,
    undefined,
    {},
    {},
    {}
  >({ url: "/amap/deliveries", method: "get", ...variables, signal });

/**
 * Get all deliveries.
 */
export const useGetAmapDeliveries = <TData = GetAmapDeliveriesResponse,>(
  variables: GetAmapDeliveriesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetAmapDeliveriesResponse,
      GetAmapDeliveriesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<
    GetAmapDeliveriesResponse,
    GetAmapDeliveriesError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/amap/deliveries",
      operationId: "getAmapDeliveries",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetAmapDeliveries({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type PostAmapDeliveriesError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostAmapDeliveriesVariables = {
  body: Schemas.DeliveryBase;
} & HyperionContext["fetcherOptions"];

/**
 * Create a new delivery.
 *
 * **The user must be a member of the group AMAP to use this endpoint**
 */
export const fetchPostAmapDeliveries = (
  variables: PostAmapDeliveriesVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.DeliveryReturn,
    PostAmapDeliveriesError,
    Schemas.DeliveryBase,
    {},
    {},
    {}
  >({ url: "/amap/deliveries", method: "post", ...variables, signal });

/**
 * Create a new delivery.
 *
 * **The user must be a member of the group AMAP to use this endpoint**
 */
export const usePostAmapDeliveries = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.DeliveryReturn,
      PostAmapDeliveriesError,
      PostAmapDeliveriesVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.DeliveryReturn,
    PostAmapDeliveriesError,
    PostAmapDeliveriesVariables
  >({
    mutationFn: (variables: PostAmapDeliveriesVariables) =>
      fetchPostAmapDeliveries({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type DeleteAmapDeliveriesDeliveryIdPathParams = {
  deliveryId: string;
};

export type DeleteAmapDeliveriesDeliveryIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type DeleteAmapDeliveriesDeliveryIdVariables = {
  pathParams: DeleteAmapDeliveriesDeliveryIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Delete a delivery.
 *
 * **The user must be a member of the group AMAP to use this endpoint**
 */
export const fetchDeleteAmapDeliveriesDeliveryId = (
  variables: DeleteAmapDeliveriesDeliveryIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteAmapDeliveriesDeliveryIdError,
    undefined,
    {},
    {},
    DeleteAmapDeliveriesDeliveryIdPathParams
  >({
    url: "/amap/deliveries/{deliveryId}",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * Delete a delivery.
 *
 * **The user must be a member of the group AMAP to use this endpoint**
 */
export const useDeleteAmapDeliveriesDeliveryId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteAmapDeliveriesDeliveryIdError,
      DeleteAmapDeliveriesDeliveryIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteAmapDeliveriesDeliveryIdError,
    DeleteAmapDeliveriesDeliveryIdVariables
  >({
    mutationFn: (variables: DeleteAmapDeliveriesDeliveryIdVariables) =>
      fetchDeleteAmapDeliveriesDeliveryId({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type PatchAmapDeliveriesDeliveryIdPathParams = {
  deliveryId: string;
};

export type PatchAmapDeliveriesDeliveryIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PatchAmapDeliveriesDeliveryIdVariables = {
  body?: Schemas.DeliveryUpdate;
  pathParams: PatchAmapDeliveriesDeliveryIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Edit a delivery.
 *
 * **The user must be a member of the group AMAP to use this endpoint**
 */
export const fetchPatchAmapDeliveriesDeliveryId = (
  variables: PatchAmapDeliveriesDeliveryIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchAmapDeliveriesDeliveryIdError,
    Schemas.DeliveryUpdate,
    {},
    {},
    PatchAmapDeliveriesDeliveryIdPathParams
  >({
    url: "/amap/deliveries/{deliveryId}",
    method: "patch",
    ...variables,
    signal,
  });

/**
 * Edit a delivery.
 *
 * **The user must be a member of the group AMAP to use this endpoint**
 */
export const usePatchAmapDeliveriesDeliveryId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchAmapDeliveriesDeliveryIdError,
      PatchAmapDeliveriesDeliveryIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchAmapDeliveriesDeliveryIdError,
    PatchAmapDeliveriesDeliveryIdVariables
  >({
    mutationFn: (variables: PatchAmapDeliveriesDeliveryIdVariables) =>
      fetchPatchAmapDeliveriesDeliveryId({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type PostAmapDeliveriesDeliveryIdProductsPathParams = {
  deliveryId: string;
};

export type PostAmapDeliveriesDeliveryIdProductsError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostAmapDeliveriesDeliveryIdProductsVariables = {
  body: Schemas.DeliveryProductsUpdate;
  pathParams: PostAmapDeliveriesDeliveryIdProductsPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Add `product_id` product to `delivery_id` delivery. This endpoint will only add a membership between the two objects.
 *
 * **The user must be a member of the group AMAP to use this endpoint**
 */
export const fetchPostAmapDeliveriesDeliveryIdProducts = (
  variables: PostAmapDeliveriesDeliveryIdProductsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    void,
    PostAmapDeliveriesDeliveryIdProductsError,
    Schemas.DeliveryProductsUpdate,
    {},
    {},
    PostAmapDeliveriesDeliveryIdProductsPathParams
  >({
    url: "/amap/deliveries/{deliveryId}/products",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Add `product_id` product to `delivery_id` delivery. This endpoint will only add a membership between the two objects.
 *
 * **The user must be a member of the group AMAP to use this endpoint**
 */
export const usePostAmapDeliveriesDeliveryIdProducts = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      void,
      PostAmapDeliveriesDeliveryIdProductsError,
      PostAmapDeliveriesDeliveryIdProductsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    void,
    PostAmapDeliveriesDeliveryIdProductsError,
    PostAmapDeliveriesDeliveryIdProductsVariables
  >({
    mutationFn: (variables: PostAmapDeliveriesDeliveryIdProductsVariables) =>
      fetchPostAmapDeliveriesDeliveryIdProducts({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type DeleteAmapDeliveriesDeliveryIdProductsPathParams = {
  deliveryId: string;
};

export type DeleteAmapDeliveriesDeliveryIdProductsError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type DeleteAmapDeliveriesDeliveryIdProductsVariables = {
  body: Schemas.DeliveryProductsUpdate;
  pathParams: DeleteAmapDeliveriesDeliveryIdProductsPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Remove a given product from a delivery. This won't delete the product nor the delivery.
 *
 * **The user must be a member of the group AMAP to use this endpoint**
 */
export const fetchDeleteAmapDeliveriesDeliveryIdProducts = (
  variables: DeleteAmapDeliveriesDeliveryIdProductsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteAmapDeliveriesDeliveryIdProductsError,
    Schemas.DeliveryProductsUpdate,
    {},
    {},
    DeleteAmapDeliveriesDeliveryIdProductsPathParams
  >({
    url: "/amap/deliveries/{deliveryId}/products",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * Remove a given product from a delivery. This won't delete the product nor the delivery.
 *
 * **The user must be a member of the group AMAP to use this endpoint**
 */
export const useDeleteAmapDeliveriesDeliveryIdProducts = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteAmapDeliveriesDeliveryIdProductsError,
      DeleteAmapDeliveriesDeliveryIdProductsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteAmapDeliveriesDeliveryIdProductsError,
    DeleteAmapDeliveriesDeliveryIdProductsVariables
  >({
    mutationFn: (variables: DeleteAmapDeliveriesDeliveryIdProductsVariables) =>
      fetchDeleteAmapDeliveriesDeliveryIdProducts({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type GetAmapDeliveriesDeliveryIdOrdersPathParams = {
  deliveryId: string;
};

export type GetAmapDeliveriesDeliveryIdOrdersError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetAmapDeliveriesDeliveryIdOrdersResponse = Schemas.OrderReturn[];

export type GetAmapDeliveriesDeliveryIdOrdersVariables = {
  pathParams: GetAmapDeliveriesDeliveryIdOrdersPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Get orders from a delivery.
 *
 * **The user must be a member of the group AMAP to use this endpoint**
 */
export const fetchGetAmapDeliveriesDeliveryIdOrders = (
  variables: GetAmapDeliveriesDeliveryIdOrdersVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetAmapDeliveriesDeliveryIdOrdersResponse,
    GetAmapDeliveriesDeliveryIdOrdersError,
    undefined,
    {},
    {},
    GetAmapDeliveriesDeliveryIdOrdersPathParams
  >({
    url: "/amap/deliveries/{deliveryId}/orders",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get orders from a delivery.
 *
 * **The user must be a member of the group AMAP to use this endpoint**
 */
export const useGetAmapDeliveriesDeliveryIdOrders = <
  TData = GetAmapDeliveriesDeliveryIdOrdersResponse,
>(
  variables: GetAmapDeliveriesDeliveryIdOrdersVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetAmapDeliveriesDeliveryIdOrdersResponse,
      GetAmapDeliveriesDeliveryIdOrdersError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<
    GetAmapDeliveriesDeliveryIdOrdersResponse,
    GetAmapDeliveriesDeliveryIdOrdersError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/amap/deliveries/{deliveryId}/orders",
      operationId: "getAmapDeliveriesDeliveryIdOrders",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetAmapDeliveriesDeliveryIdOrders(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type GetAmapOrdersOrderIdPathParams = {
  orderId: string;
};

export type GetAmapOrdersOrderIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetAmapOrdersOrderIdVariables = {
  pathParams: GetAmapOrdersOrderIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Get content of an order.
 *
 * **The user must be a member of the group AMAP to use this endpoint**
 */
export const fetchGetAmapOrdersOrderId = (
  variables: GetAmapOrdersOrderIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.OrderReturn,
    GetAmapOrdersOrderIdError,
    undefined,
    {},
    {},
    GetAmapOrdersOrderIdPathParams
  >({ url: "/amap/orders/{orderId}", method: "get", ...variables, signal });

/**
 * Get content of an order.
 *
 * **The user must be a member of the group AMAP to use this endpoint**
 */
export const useGetAmapOrdersOrderId = <TData = Schemas.OrderReturn,>(
  variables: GetAmapOrdersOrderIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.OrderReturn,
      GetAmapOrdersOrderIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<
    Schemas.OrderReturn,
    GetAmapOrdersOrderIdError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/amap/orders/{orderId}",
      operationId: "getAmapOrdersOrderId",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetAmapOrdersOrderId({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type PatchAmapOrdersOrderIdPathParams = {
  orderId: string;
};

export type PatchAmapOrdersOrderIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PatchAmapOrdersOrderIdVariables = {
  body?: Schemas.OrderEdit;
  pathParams: PatchAmapOrdersOrderIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Edit an order.
 *
 * **A member of the group AMAP can edit orders of other users**
 */
export const fetchPatchAmapOrdersOrderId = (
  variables: PatchAmapOrdersOrderIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchAmapOrdersOrderIdError,
    Schemas.OrderEdit,
    {},
    {},
    PatchAmapOrdersOrderIdPathParams
  >({ url: "/amap/orders/{orderId}", method: "patch", ...variables, signal });

/**
 * Edit an order.
 *
 * **A member of the group AMAP can edit orders of other users**
 */
export const usePatchAmapOrdersOrderId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchAmapOrdersOrderIdError,
      PatchAmapOrdersOrderIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchAmapOrdersOrderIdError,
    PatchAmapOrdersOrderIdVariables
  >({
    mutationFn: (variables: PatchAmapOrdersOrderIdVariables) =>
      fetchPatchAmapOrdersOrderId({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type DeleteAmapOrdersOrderIdPathParams = {
  orderId: string;
};

export type DeleteAmapOrdersOrderIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type DeleteAmapOrdersOrderIdVariables = {
  pathParams: DeleteAmapOrdersOrderIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Delete an order.
 *
 * **A member of the group AMAP can delete orders of other users**
 */
export const fetchDeleteAmapOrdersOrderId = (
  variables: DeleteAmapOrdersOrderIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteAmapOrdersOrderIdError,
    undefined,
    {},
    {},
    DeleteAmapOrdersOrderIdPathParams
  >({ url: "/amap/orders/{orderId}", method: "delete", ...variables, signal });

/**
 * Delete an order.
 *
 * **A member of the group AMAP can delete orders of other users**
 */
export const useDeleteAmapOrdersOrderId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteAmapOrdersOrderIdError,
      DeleteAmapOrdersOrderIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteAmapOrdersOrderIdError,
    DeleteAmapOrdersOrderIdVariables
  >({
    mutationFn: (variables: DeleteAmapOrdersOrderIdVariables) =>
      fetchDeleteAmapOrdersOrderId({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type PostAmapOrdersError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostAmapOrdersVariables = {
  body: Schemas.OrderBase;
} & HyperionContext["fetcherOptions"];

/**
 * Add an order to a delivery.
 *
 * **A member of the group AMAP can create an order for every user**
 */
export const fetchPostAmapOrders = (
  variables: PostAmapOrdersVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.OrderReturn,
    PostAmapOrdersError,
    Schemas.OrderBase,
    {},
    {},
    {}
  >({ url: "/amap/orders", method: "post", ...variables, signal });

/**
 * Add an order to a delivery.
 *
 * **A member of the group AMAP can create an order for every user**
 */
export const usePostAmapOrders = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.OrderReturn,
      PostAmapOrdersError,
      PostAmapOrdersVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.OrderReturn,
    PostAmapOrdersError,
    PostAmapOrdersVariables
  >({
    mutationFn: (variables: PostAmapOrdersVariables) =>
      fetchPostAmapOrders({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type PostAmapDeliveriesDeliveryIdOpenorderingPathParams = {
  deliveryId: string;
};

export type PostAmapDeliveriesDeliveryIdOpenorderingError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type PostAmapDeliveriesDeliveryIdOpenorderingVariables = {
  pathParams: PostAmapDeliveriesDeliveryIdOpenorderingPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchPostAmapDeliveriesDeliveryIdOpenordering = (
  variables: PostAmapDeliveriesDeliveryIdOpenorderingVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PostAmapDeliveriesDeliveryIdOpenorderingError,
    undefined,
    {},
    {},
    PostAmapDeliveriesDeliveryIdOpenorderingPathParams
  >({
    url: "/amap/deliveries/{deliveryId}/openordering",
    method: "post",
    ...variables,
    signal,
  });

export const usePostAmapDeliveriesDeliveryIdOpenordering = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PostAmapDeliveriesDeliveryIdOpenorderingError,
      PostAmapDeliveriesDeliveryIdOpenorderingVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PostAmapDeliveriesDeliveryIdOpenorderingError,
    PostAmapDeliveriesDeliveryIdOpenorderingVariables
  >({
    mutationFn: (
      variables: PostAmapDeliveriesDeliveryIdOpenorderingVariables,
    ) =>
      fetchPostAmapDeliveriesDeliveryIdOpenordering({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type PostAmapDeliveriesDeliveryIdLockPathParams = {
  deliveryId: string;
};

export type PostAmapDeliveriesDeliveryIdLockError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostAmapDeliveriesDeliveryIdLockVariables = {
  pathParams: PostAmapDeliveriesDeliveryIdLockPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchPostAmapDeliveriesDeliveryIdLock = (
  variables: PostAmapDeliveriesDeliveryIdLockVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PostAmapDeliveriesDeliveryIdLockError,
    undefined,
    {},
    {},
    PostAmapDeliveriesDeliveryIdLockPathParams
  >({
    url: "/amap/deliveries/{deliveryId}/lock",
    method: "post",
    ...variables,
    signal,
  });

export const usePostAmapDeliveriesDeliveryIdLock = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PostAmapDeliveriesDeliveryIdLockError,
      PostAmapDeliveriesDeliveryIdLockVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PostAmapDeliveriesDeliveryIdLockError,
    PostAmapDeliveriesDeliveryIdLockVariables
  >({
    mutationFn: (variables: PostAmapDeliveriesDeliveryIdLockVariables) =>
      fetchPostAmapDeliveriesDeliveryIdLock({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type PostAmapDeliveriesDeliveryIdDeliveredPathParams = {
  deliveryId: string;
};

export type PostAmapDeliveriesDeliveryIdDeliveredError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostAmapDeliveriesDeliveryIdDeliveredVariables = {
  pathParams: PostAmapDeliveriesDeliveryIdDeliveredPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchPostAmapDeliveriesDeliveryIdDelivered = (
  variables: PostAmapDeliveriesDeliveryIdDeliveredVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PostAmapDeliveriesDeliveryIdDeliveredError,
    undefined,
    {},
    {},
    PostAmapDeliveriesDeliveryIdDeliveredPathParams
  >({
    url: "/amap/deliveries/{deliveryId}/delivered",
    method: "post",
    ...variables,
    signal,
  });

export const usePostAmapDeliveriesDeliveryIdDelivered = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PostAmapDeliveriesDeliveryIdDeliveredError,
      PostAmapDeliveriesDeliveryIdDeliveredVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PostAmapDeliveriesDeliveryIdDeliveredError,
    PostAmapDeliveriesDeliveryIdDeliveredVariables
  >({
    mutationFn: (variables: PostAmapDeliveriesDeliveryIdDeliveredVariables) =>
      fetchPostAmapDeliveriesDeliveryIdDelivered({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type PostAmapDeliveriesDeliveryIdArchivePathParams = {
  deliveryId: string;
};

export type PostAmapDeliveriesDeliveryIdArchiveError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostAmapDeliveriesDeliveryIdArchiveVariables = {
  pathParams: PostAmapDeliveriesDeliveryIdArchivePathParams;
} & HyperionContext["fetcherOptions"];

export const fetchPostAmapDeliveriesDeliveryIdArchive = (
  variables: PostAmapDeliveriesDeliveryIdArchiveVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PostAmapDeliveriesDeliveryIdArchiveError,
    undefined,
    {},
    {},
    PostAmapDeliveriesDeliveryIdArchivePathParams
  >({
    url: "/amap/deliveries/{deliveryId}/archive",
    method: "post",
    ...variables,
    signal,
  });

export const usePostAmapDeliveriesDeliveryIdArchive = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PostAmapDeliveriesDeliveryIdArchiveError,
      PostAmapDeliveriesDeliveryIdArchiveVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PostAmapDeliveriesDeliveryIdArchiveError,
    PostAmapDeliveriesDeliveryIdArchiveVariables
  >({
    mutationFn: (variables: PostAmapDeliveriesDeliveryIdArchiveVariables) =>
      fetchPostAmapDeliveriesDeliveryIdArchive({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type GetAmapUsersCashError = Fetcher.ErrorWrapper<undefined>;

export type GetAmapUsersCashResponse = Schemas.CashComplete[];

export type GetAmapUsersCashVariables = HyperionContext["fetcherOptions"];

/**
 * Get cash from all users.
 *
 * **The user must be a member of the group AMAP to use this endpoint**
 */
export const fetchGetAmapUsersCash = (
  variables: GetAmapUsersCashVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetAmapUsersCashResponse,
    GetAmapUsersCashError,
    undefined,
    {},
    {},
    {}
  >({ url: "/amap/users/cash", method: "get", ...variables, signal });

/**
 * Get cash from all users.
 *
 * **The user must be a member of the group AMAP to use this endpoint**
 */
export const useGetAmapUsersCash = <TData = GetAmapUsersCashResponse,>(
  variables: GetAmapUsersCashVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetAmapUsersCashResponse,
      GetAmapUsersCashError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<
    GetAmapUsersCashResponse,
    GetAmapUsersCashError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/amap/users/cash",
      operationId: "getAmapUsersCash",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetAmapUsersCash({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type GetAmapUsersUserIdCashPathParams = {
  userId: string;
};

export type GetAmapUsersUserIdCashError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetAmapUsersUserIdCashVariables = {
  pathParams: GetAmapUsersUserIdCashPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Get cash from a specific user.
 *
 * **The user must be a member of the group AMAP to use this endpoint or can only access the endpoint for its own user_id**
 */
export const fetchGetAmapUsersUserIdCash = (
  variables: GetAmapUsersUserIdCashVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.CashComplete,
    GetAmapUsersUserIdCashError,
    undefined,
    {},
    {},
    GetAmapUsersUserIdCashPathParams
  >({ url: "/amap/users/{userId}/cash", method: "get", ...variables, signal });

/**
 * Get cash from a specific user.
 *
 * **The user must be a member of the group AMAP to use this endpoint or can only access the endpoint for its own user_id**
 */
export const useGetAmapUsersUserIdCash = <TData = Schemas.CashComplete,>(
  variables: GetAmapUsersUserIdCashVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.CashComplete,
      GetAmapUsersUserIdCashError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<
    Schemas.CashComplete,
    GetAmapUsersUserIdCashError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/amap/users/{userId}/cash",
      operationId: "getAmapUsersUserIdCash",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetAmapUsersUserIdCash({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type PostAmapUsersUserIdCashPathParams = {
  userId: string;
};

export type PostAmapUsersUserIdCashError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostAmapUsersUserIdCashVariables = {
  body: Schemas.CashEdit;
  pathParams: PostAmapUsersUserIdCashPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Create cash for an user.
 *
 * **The user must be a member of the group AMAP to use this endpoint**
 */
export const fetchPostAmapUsersUserIdCash = (
  variables: PostAmapUsersUserIdCashVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.CashComplete,
    PostAmapUsersUserIdCashError,
    Schemas.CashEdit,
    {},
    {},
    PostAmapUsersUserIdCashPathParams
  >({ url: "/amap/users/{userId}/cash", method: "post", ...variables, signal });

/**
 * Create cash for an user.
 *
 * **The user must be a member of the group AMAP to use this endpoint**
 */
export const usePostAmapUsersUserIdCash = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.CashComplete,
      PostAmapUsersUserIdCashError,
      PostAmapUsersUserIdCashVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.CashComplete,
    PostAmapUsersUserIdCashError,
    PostAmapUsersUserIdCashVariables
  >({
    mutationFn: (variables: PostAmapUsersUserIdCashVariables) =>
      fetchPostAmapUsersUserIdCash({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type PatchAmapUsersUserIdCashPathParams = {
  userId: string;
};

export type PatchAmapUsersUserIdCashError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PatchAmapUsersUserIdCashVariables = {
  body: Schemas.CashEdit;
  pathParams: PatchAmapUsersUserIdCashPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Edit cash for an user. This will add the balance to the current balance.
 * A negative value can be provided to remove money from the user.
 *
 * **The user must be a member of the group AMAP to use this endpoint**
 */
export const fetchPatchAmapUsersUserIdCash = (
  variables: PatchAmapUsersUserIdCashVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchAmapUsersUserIdCashError,
    Schemas.CashEdit,
    {},
    {},
    PatchAmapUsersUserIdCashPathParams
  >({
    url: "/amap/users/{userId}/cash",
    method: "patch",
    ...variables,
    signal,
  });

/**
 * Edit cash for an user. This will add the balance to the current balance.
 * A negative value can be provided to remove money from the user.
 *
 * **The user must be a member of the group AMAP to use this endpoint**
 */
export const usePatchAmapUsersUserIdCash = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchAmapUsersUserIdCashError,
      PatchAmapUsersUserIdCashVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchAmapUsersUserIdCashError,
    PatchAmapUsersUserIdCashVariables
  >({
    mutationFn: (variables: PatchAmapUsersUserIdCashVariables) =>
      fetchPatchAmapUsersUserIdCash({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetAmapUsersUserIdOrdersPathParams = {
  userId: string;
};

export type GetAmapUsersUserIdOrdersError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetAmapUsersUserIdOrdersResponse = Schemas.OrderReturn[];

export type GetAmapUsersUserIdOrdersVariables = {
  pathParams: GetAmapUsersUserIdOrdersPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Get orders from an user.
 *
 * **The user must be a member of the group AMAP to use this endpoint or can only access the endpoint for its own user_id**
 */
export const fetchGetAmapUsersUserIdOrders = (
  variables: GetAmapUsersUserIdOrdersVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetAmapUsersUserIdOrdersResponse,
    GetAmapUsersUserIdOrdersError,
    undefined,
    {},
    {},
    GetAmapUsersUserIdOrdersPathParams
  >({
    url: "/amap/users/{userId}/orders",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get orders from an user.
 *
 * **The user must be a member of the group AMAP to use this endpoint or can only access the endpoint for its own user_id**
 */
export const useGetAmapUsersUserIdOrders = <
  TData = GetAmapUsersUserIdOrdersResponse,
>(
  variables: GetAmapUsersUserIdOrdersVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetAmapUsersUserIdOrdersResponse,
      GetAmapUsersUserIdOrdersError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<
    GetAmapUsersUserIdOrdersResponse,
    GetAmapUsersUserIdOrdersError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/amap/users/{userId}/orders",
      operationId: "getAmapUsersUserIdOrders",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetAmapUsersUserIdOrders(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type GetAmapInformationError = Fetcher.ErrorWrapper<undefined>;

export type GetAmapInformationVariables = HyperionContext["fetcherOptions"];

/**
 * Return all information
 */
export const fetchGetAmapInformation = (
  variables: GetAmapInformationVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.Information,
    GetAmapInformationError,
    undefined,
    {},
    {},
    {}
  >({ url: "/amap/information", method: "get", ...variables, signal });

/**
 * Return all information
 */
export const useGetAmapInformation = <TData = Schemas.Information,>(
  variables: GetAmapInformationVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.Information,
      GetAmapInformationError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<
    Schemas.Information,
    GetAmapInformationError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/amap/information",
      operationId: "getAmapInformation",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetAmapInformation({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type PatchAmapInformationError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PatchAmapInformationVariables = {
  body?: Schemas.InformationEdit;
} & HyperionContext["fetcherOptions"];

/**
 * Update information
 *
 * **The user must be a member of the group AMAP to use this endpoint**
 */
export const fetchPatchAmapInformation = (
  variables: PatchAmapInformationVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchAmapInformationError,
    Schemas.InformationEdit,
    {},
    {},
    {}
  >({ url: "/amap/information", method: "patch", ...variables, signal });

/**
 * Update information
 *
 * **The user must be a member of the group AMAP to use this endpoint**
 */
export const usePatchAmapInformation = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchAmapInformationError,
      PatchAmapInformationVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchAmapInformationError,
    PatchAmapInformationVariables
  >({
    mutationFn: (variables: PatchAmapInformationVariables) =>
      fetchPatchAmapInformation({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetBookingManagersError = Fetcher.ErrorWrapper<undefined>;

export type GetBookingManagersResponse = Schemas.Manager[];

export type GetBookingManagersVariables = HyperionContext["fetcherOptions"];

/**
 * Get existing managers.
 *
 * **This endpoint is only usable by administrators**
 */
export const fetchGetBookingManagers = (
  variables: GetBookingManagersVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetBookingManagersResponse,
    GetBookingManagersError,
    undefined,
    {},
    {},
    {}
  >({ url: "/booking/managers", method: "get", ...variables, signal });

/**
 * Get existing managers.
 *
 * **This endpoint is only usable by administrators**
 */
export const useGetBookingManagers = <TData = GetBookingManagersResponse,>(
  variables: GetBookingManagersVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetBookingManagersResponse,
      GetBookingManagersError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<
    GetBookingManagersResponse,
    GetBookingManagersError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/booking/managers",
      operationId: "getBookingManagers",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetBookingManagers({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type PostBookingManagersError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostBookingManagersVariables = {
  body: Schemas.ManagerBase;
} & HyperionContext["fetcherOptions"];

/**
 * Create a manager.
 *
 * **This endpoint is only usable by administrators**
 */
export const fetchPostBookingManagers = (
  variables: PostBookingManagersVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.Manager,
    PostBookingManagersError,
    Schemas.ManagerBase,
    {},
    {},
    {}
  >({ url: "/booking/managers", method: "post", ...variables, signal });

/**
 * Create a manager.
 *
 * **This endpoint is only usable by administrators**
 */
export const usePostBookingManagers = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.Manager,
      PostBookingManagersError,
      PostBookingManagersVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.Manager,
    PostBookingManagersError,
    PostBookingManagersVariables
  >({
    mutationFn: (variables: PostBookingManagersVariables) =>
      fetchPostBookingManagers({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type PatchBookingManagersManagerIdPathParams = {
  managerId: string;
};

export type PatchBookingManagersManagerIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PatchBookingManagersManagerIdVariables = {
  body?: Schemas.ManagerUpdate;
  pathParams: PatchBookingManagersManagerIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Update a manager, the request should contain a JSON with the fields to change (not necessarily all fields) and their new value.
 *
 * **This endpoint is only usable by administrators**
 */
export const fetchPatchBookingManagersManagerId = (
  variables: PatchBookingManagersManagerIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchBookingManagersManagerIdError,
    Schemas.ManagerUpdate,
    {},
    {},
    PatchBookingManagersManagerIdPathParams
  >({
    url: "/booking/managers/{managerId}",
    method: "patch",
    ...variables,
    signal,
  });

/**
 * Update a manager, the request should contain a JSON with the fields to change (not necessarily all fields) and their new value.
 *
 * **This endpoint is only usable by administrators**
 */
export const usePatchBookingManagersManagerId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchBookingManagersManagerIdError,
      PatchBookingManagersManagerIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchBookingManagersManagerIdError,
    PatchBookingManagersManagerIdVariables
  >({
    mutationFn: (variables: PatchBookingManagersManagerIdVariables) =>
      fetchPatchBookingManagersManagerId({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type DeleteBookingManagersManagerIdPathParams = {
  managerId: string;
};

export type DeleteBookingManagersManagerIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type DeleteBookingManagersManagerIdVariables = {
  pathParams: DeleteBookingManagersManagerIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Delete a manager only if the manager is not linked to any room
 *
 * **This endpoint is only usable by administrators**
 */
export const fetchDeleteBookingManagersManagerId = (
  variables: DeleteBookingManagersManagerIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteBookingManagersManagerIdError,
    undefined,
    {},
    {},
    DeleteBookingManagersManagerIdPathParams
  >({
    url: "/booking/managers/{managerId}",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * Delete a manager only if the manager is not linked to any room
 *
 * **This endpoint is only usable by administrators**
 */
export const useDeleteBookingManagersManagerId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteBookingManagersManagerIdError,
      DeleteBookingManagersManagerIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteBookingManagersManagerIdError,
    DeleteBookingManagersManagerIdVariables
  >({
    mutationFn: (variables: DeleteBookingManagersManagerIdVariables) =>
      fetchDeleteBookingManagersManagerId({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetBookingManagersUsersMeError = Fetcher.ErrorWrapper<undefined>;

export type GetBookingManagersUsersMeResponse = Schemas.Manager[];

export type GetBookingManagersUsersMeVariables =
  HyperionContext["fetcherOptions"];

/**
 * Return all managers the current user is a member.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const fetchGetBookingManagersUsersMe = (
  variables: GetBookingManagersUsersMeVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetBookingManagersUsersMeResponse,
    GetBookingManagersUsersMeError,
    undefined,
    {},
    {},
    {}
  >({ url: "/booking/managers/users/me", method: "get", ...variables, signal });

/**
 * Return all managers the current user is a member.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const useGetBookingManagersUsersMe = <
  TData = GetBookingManagersUsersMeResponse,
>(
  variables: GetBookingManagersUsersMeVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetBookingManagersUsersMeResponse,
      GetBookingManagersUsersMeError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<
    GetBookingManagersUsersMeResponse,
    GetBookingManagersUsersMeError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/booking/managers/users/me",
      operationId: "getBookingManagersUsersMe",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetBookingManagersUsersMe(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type GetBookingBookingsUsersMeManageError =
  Fetcher.ErrorWrapper<undefined>;

export type GetBookingBookingsUsersMeManageResponse =
  Schemas.BookingReturnApplicant[];

export type GetBookingBookingsUsersMeManageVariables =
  HyperionContext["fetcherOptions"];

/**
 * Return all bookings a user can manage.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const fetchGetBookingBookingsUsersMeManage = (
  variables: GetBookingBookingsUsersMeManageVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetBookingBookingsUsersMeManageResponse,
    GetBookingBookingsUsersMeManageError,
    undefined,
    {},
    {},
    {}
  >({
    url: "/booking/bookings/users/me/manage",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Return all bookings a user can manage.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const useGetBookingBookingsUsersMeManage = <
  TData = GetBookingBookingsUsersMeManageResponse,
>(
  variables: GetBookingBookingsUsersMeManageVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetBookingBookingsUsersMeManageResponse,
      GetBookingBookingsUsersMeManageError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<
    GetBookingBookingsUsersMeManageResponse,
    GetBookingBookingsUsersMeManageError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/booking/bookings/users/me/manage",
      operationId: "getBookingBookingsUsersMeManage",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetBookingBookingsUsersMeManage(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type GetBookingBookingsConfirmedUsersMeManageError =
  Fetcher.ErrorWrapper<undefined>;

export type GetBookingBookingsConfirmedUsersMeManageResponse =
  Schemas.BookingReturnApplicant[];

export type GetBookingBookingsConfirmedUsersMeManageVariables =
  HyperionContext["fetcherOptions"];

/**
 * Return all confirmed bookings a user can manage.
 * **The user must be authenticated to use this endpoint**
 */
export const fetchGetBookingBookingsConfirmedUsersMeManage = (
  variables: GetBookingBookingsConfirmedUsersMeManageVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetBookingBookingsConfirmedUsersMeManageResponse,
    GetBookingBookingsConfirmedUsersMeManageError,
    undefined,
    {},
    {},
    {}
  >({
    url: "/booking/bookings/confirmed/users/me/manage",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Return all confirmed bookings a user can manage.
 * **The user must be authenticated to use this endpoint**
 */
export const useGetBookingBookingsConfirmedUsersMeManage = <
  TData = GetBookingBookingsConfirmedUsersMeManageResponse,
>(
  variables: GetBookingBookingsConfirmedUsersMeManageVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetBookingBookingsConfirmedUsersMeManageResponse,
      GetBookingBookingsConfirmedUsersMeManageError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<
    GetBookingBookingsConfirmedUsersMeManageResponse,
    GetBookingBookingsConfirmedUsersMeManageError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/booking/bookings/confirmed/users/me/manage",
      operationId: "getBookingBookingsConfirmedUsersMeManage",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetBookingBookingsConfirmedUsersMeManage(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type GetBookingBookingsConfirmedError = Fetcher.ErrorWrapper<undefined>;

export type GetBookingBookingsConfirmedResponse =
  Schemas.BookingReturnSimpleApplicant[];

export type GetBookingBookingsConfirmedVariables =
  HyperionContext["fetcherOptions"];

/**
 * Return all confirmed bookings.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const fetchGetBookingBookingsConfirmed = (
  variables: GetBookingBookingsConfirmedVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetBookingBookingsConfirmedResponse,
    GetBookingBookingsConfirmedError,
    undefined,
    {},
    {},
    {}
  >({
    url: "/booking/bookings/confirmed",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Return all confirmed bookings.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const useGetBookingBookingsConfirmed = <
  TData = GetBookingBookingsConfirmedResponse,
>(
  variables: GetBookingBookingsConfirmedVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetBookingBookingsConfirmedResponse,
      GetBookingBookingsConfirmedError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<
    GetBookingBookingsConfirmedResponse,
    GetBookingBookingsConfirmedError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/booking/bookings/confirmed",
      operationId: "getBookingBookingsConfirmed",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetBookingBookingsConfirmed(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type GetBookingBookingsUsersMeError = Fetcher.ErrorWrapper<undefined>;

export type GetBookingBookingsUsersMeResponse = Schemas.BookingReturn[];

export type GetBookingBookingsUsersMeVariables =
  HyperionContext["fetcherOptions"];

/**
 * Get the user bookings.
 *
 * **Only usable by the user**
 */
export const fetchGetBookingBookingsUsersMe = (
  variables: GetBookingBookingsUsersMeVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetBookingBookingsUsersMeResponse,
    GetBookingBookingsUsersMeError,
    undefined,
    {},
    {},
    {}
  >({ url: "/booking/bookings/users/me", method: "get", ...variables, signal });

/**
 * Get the user bookings.
 *
 * **Only usable by the user**
 */
export const useGetBookingBookingsUsersMe = <
  TData = GetBookingBookingsUsersMeResponse,
>(
  variables: GetBookingBookingsUsersMeVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetBookingBookingsUsersMeResponse,
      GetBookingBookingsUsersMeError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<
    GetBookingBookingsUsersMeResponse,
    GetBookingBookingsUsersMeError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/booking/bookings/users/me",
      operationId: "getBookingBookingsUsersMe",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetBookingBookingsUsersMe(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type PostBookingBookingsError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostBookingBookingsVariables = {
  body: Schemas.BookingBase;
} & HyperionContext["fetcherOptions"];

/**
 * Create a booking.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const fetchPostBookingBookings = (
  variables: PostBookingBookingsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.BookingReturn,
    PostBookingBookingsError,
    Schemas.BookingBase,
    {},
    {},
    {}
  >({ url: "/booking/bookings", method: "post", ...variables, signal });

/**
 * Create a booking.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const usePostBookingBookings = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.BookingReturn,
      PostBookingBookingsError,
      PostBookingBookingsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.BookingReturn,
    PostBookingBookingsError,
    PostBookingBookingsVariables
  >({
    mutationFn: (variables: PostBookingBookingsVariables) =>
      fetchPostBookingBookings({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type PatchBookingBookingsBookingIdPathParams = {
  bookingId: string;
};

export type PatchBookingBookingsBookingIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PatchBookingBookingsBookingIdVariables = {
  body?: Schemas.BookingEdit;
  pathParams: PatchBookingBookingsBookingIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Edit a booking.
 *
 * **Only usable by a user in the manager group of the booking or applicant before decision**
 */
export const fetchPatchBookingBookingsBookingId = (
  variables: PatchBookingBookingsBookingIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchBookingBookingsBookingIdError,
    Schemas.BookingEdit,
    {},
    {},
    PatchBookingBookingsBookingIdPathParams
  >({
    url: "/booking/bookings/{bookingId}",
    method: "patch",
    ...variables,
    signal,
  });

/**
 * Edit a booking.
 *
 * **Only usable by a user in the manager group of the booking or applicant before decision**
 */
export const usePatchBookingBookingsBookingId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchBookingBookingsBookingIdError,
      PatchBookingBookingsBookingIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchBookingBookingsBookingIdError,
    PatchBookingBookingsBookingIdVariables
  >({
    mutationFn: (variables: PatchBookingBookingsBookingIdVariables) =>
      fetchPatchBookingBookingsBookingId({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type DeleteBookingBookingsBookingIdPathParams = {
  bookingId: string;
};

export type DeleteBookingBookingsBookingIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type DeleteBookingBookingsBookingIdVariables = {
  pathParams: DeleteBookingBookingsBookingIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Remove a booking.
 *
 * **Only usable by the applicant before decision**
 */
export const fetchDeleteBookingBookingsBookingId = (
  variables: DeleteBookingBookingsBookingIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteBookingBookingsBookingIdError,
    undefined,
    {},
    {},
    DeleteBookingBookingsBookingIdPathParams
  >({
    url: "/booking/bookings/{bookingId}",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * Remove a booking.
 *
 * **Only usable by the applicant before decision**
 */
export const useDeleteBookingBookingsBookingId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteBookingBookingsBookingIdError,
      DeleteBookingBookingsBookingIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteBookingBookingsBookingIdError,
    DeleteBookingBookingsBookingIdVariables
  >({
    mutationFn: (variables: DeleteBookingBookingsBookingIdVariables) =>
      fetchDeleteBookingBookingsBookingId({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type PatchBookingBookingsBookingIdReplyDecisionPathParams = {
  bookingId: string;
  decision: Schemas.Decision;
};

export type PatchBookingBookingsBookingIdReplyDecisionError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type PatchBookingBookingsBookingIdReplyDecisionVariables = {
  pathParams: PatchBookingBookingsBookingIdReplyDecisionPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Give a decision to a booking.
 *
 * **Only usable by a user in the manager group of the booking**
 */
export const fetchPatchBookingBookingsBookingIdReplyDecision = (
  variables: PatchBookingBookingsBookingIdReplyDecisionVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchBookingBookingsBookingIdReplyDecisionError,
    undefined,
    {},
    {},
    PatchBookingBookingsBookingIdReplyDecisionPathParams
  >({
    url: "/booking/bookings/{bookingId}/reply/{decision}",
    method: "patch",
    ...variables,
    signal,
  });

/**
 * Give a decision to a booking.
 *
 * **Only usable by a user in the manager group of the booking**
 */
export const usePatchBookingBookingsBookingIdReplyDecision = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchBookingBookingsBookingIdReplyDecisionError,
      PatchBookingBookingsBookingIdReplyDecisionVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchBookingBookingsBookingIdReplyDecisionError,
    PatchBookingBookingsBookingIdReplyDecisionVariables
  >({
    mutationFn: (
      variables: PatchBookingBookingsBookingIdReplyDecisionVariables,
    ) =>
      fetchPatchBookingBookingsBookingIdReplyDecision({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type GetBookingRoomsError = Fetcher.ErrorWrapper<undefined>;

export type GetBookingRoomsResponse = Schemas.RoomComplete[];

export type GetBookingRoomsVariables = HyperionContext["fetcherOptions"];

/**
 * Get all rooms.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const fetchGetBookingRooms = (
  variables: GetBookingRoomsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetBookingRoomsResponse,
    GetBookingRoomsError,
    undefined,
    {},
    {},
    {}
  >({ url: "/booking/rooms", method: "get", ...variables, signal });

/**
 * Get all rooms.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const useGetBookingRooms = <TData = GetBookingRoomsResponse,>(
  variables: GetBookingRoomsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetBookingRoomsResponse,
      GetBookingRoomsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<
    GetBookingRoomsResponse,
    GetBookingRoomsError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/booking/rooms",
      operationId: "getBookingRooms",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetBookingRooms({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type PostBookingRoomsError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostBookingRoomsVariables = {
  body: Schemas.RoomBase;
} & HyperionContext["fetcherOptions"];

/**
 * Create a new room in database.
 *
 * **This endpoint is only usable by admins**
 */
export const fetchPostBookingRooms = (
  variables: PostBookingRoomsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.RoomComplete,
    PostBookingRoomsError,
    Schemas.RoomBase,
    {},
    {},
    {}
  >({ url: "/booking/rooms", method: "post", ...variables, signal });

/**
 * Create a new room in database.
 *
 * **This endpoint is only usable by admins**
 */
export const usePostBookingRooms = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.RoomComplete,
      PostBookingRoomsError,
      PostBookingRoomsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.RoomComplete,
    PostBookingRoomsError,
    PostBookingRoomsVariables
  >({
    mutationFn: (variables: PostBookingRoomsVariables) =>
      fetchPostBookingRooms({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type PatchBookingRoomsRoomIdPathParams = {
  roomId: string;
};

export type PatchBookingRoomsRoomIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PatchBookingRoomsRoomIdVariables = {
  body: Schemas.RoomBase;
  pathParams: PatchBookingRoomsRoomIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Edit a room.
 *
 * **This endpoint is only usable by admins**
 */
export const fetchPatchBookingRoomsRoomId = (
  variables: PatchBookingRoomsRoomIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchBookingRoomsRoomIdError,
    Schemas.RoomBase,
    {},
    {},
    PatchBookingRoomsRoomIdPathParams
  >({ url: "/booking/rooms/{roomId}", method: "patch", ...variables, signal });

/**
 * Edit a room.
 *
 * **This endpoint is only usable by admins**
 */
export const usePatchBookingRoomsRoomId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchBookingRoomsRoomIdError,
      PatchBookingRoomsRoomIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchBookingRoomsRoomIdError,
    PatchBookingRoomsRoomIdVariables
  >({
    mutationFn: (variables: PatchBookingRoomsRoomIdVariables) =>
      fetchPatchBookingRoomsRoomId({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type DeleteBookingRoomsRoomIdPathParams = {
  roomId: string;
};

export type DeleteBookingRoomsRoomIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type DeleteBookingRoomsRoomIdVariables = {
  pathParams: DeleteBookingRoomsRoomIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Delete a room only if there are not future or ongoing bookings of this room
 *
 * **This endpoint is only usable by admins**
 */
export const fetchDeleteBookingRoomsRoomId = (
  variables: DeleteBookingRoomsRoomIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteBookingRoomsRoomIdError,
    undefined,
    {},
    {},
    DeleteBookingRoomsRoomIdPathParams
  >({ url: "/booking/rooms/{roomId}", method: "delete", ...variables, signal });

/**
 * Delete a room only if there are not future or ongoing bookings of this room
 *
 * **This endpoint is only usable by admins**
 */
export const useDeleteBookingRoomsRoomId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteBookingRoomsRoomIdError,
      DeleteBookingRoomsRoomIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteBookingRoomsRoomIdError,
    DeleteBookingRoomsRoomIdVariables
  >({
    mutationFn: (variables: DeleteBookingRoomsRoomIdVariables) =>
      fetchDeleteBookingRoomsRoomId({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetCalendarEventsError = Fetcher.ErrorWrapper<undefined>;

export type GetCalendarEventsResponse = Schemas.EventReturn[];

export type GetCalendarEventsVariables = HyperionContext["fetcherOptions"];

/**
 * Get all events from the database.
 */
export const fetchGetCalendarEvents = (
  variables: GetCalendarEventsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetCalendarEventsResponse,
    GetCalendarEventsError,
    undefined,
    {},
    {},
    {}
  >({ url: "/calendar/events/", method: "get", ...variables, signal });

/**
 * Get all events from the database.
 */
export const useGetCalendarEvents = <TData = GetCalendarEventsResponse,>(
  variables: GetCalendarEventsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCalendarEventsResponse,
      GetCalendarEventsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<
    GetCalendarEventsResponse,
    GetCalendarEventsError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/calendar/events/",
      operationId: "getCalendarEvents",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetCalendarEvents({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type PostCalendarEventsError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostCalendarEventsVariables = {
  body: Schemas.EventBase;
} & HyperionContext["fetcherOptions"];

/**
 * Add an event to the calendar.
 */
export const fetchPostCalendarEvents = (
  variables: PostCalendarEventsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.EventReturn,
    PostCalendarEventsError,
    Schemas.EventBase,
    {},
    {},
    {}
  >({ url: "/calendar/events/", method: "post", ...variables, signal });

/**
 * Add an event to the calendar.
 */
export const usePostCalendarEvents = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.EventReturn,
      PostCalendarEventsError,
      PostCalendarEventsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.EventReturn,
    PostCalendarEventsError,
    PostCalendarEventsVariables
  >({
    mutationFn: (variables: PostCalendarEventsVariables) =>
      fetchPostCalendarEvents({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetCalendarEventsConfirmedError = Fetcher.ErrorWrapper<undefined>;

export type GetCalendarEventsConfirmedResponse = Schemas.EventComplete[];

export type GetCalendarEventsConfirmedVariables =
  HyperionContext["fetcherOptions"];

/**
 * Get all confirmed events.
 *
 * **Usable by every member**
 */
export const fetchGetCalendarEventsConfirmed = (
  variables: GetCalendarEventsConfirmedVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetCalendarEventsConfirmedResponse,
    GetCalendarEventsConfirmedError,
    undefined,
    {},
    {},
    {}
  >({ url: "/calendar/events/confirmed", method: "get", ...variables, signal });

/**
 * Get all confirmed events.
 *
 * **Usable by every member**
 */
export const useGetCalendarEventsConfirmed = <
  TData = GetCalendarEventsConfirmedResponse,
>(
  variables: GetCalendarEventsConfirmedVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCalendarEventsConfirmedResponse,
      GetCalendarEventsConfirmedError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<
    GetCalendarEventsConfirmedResponse,
    GetCalendarEventsConfirmedError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/calendar/events/confirmed",
      operationId: "getCalendarEventsConfirmed",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetCalendarEventsConfirmed(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type GetCalendarEventsUserApplicantIdPathParams = {
  applicantId: string;
};

export type GetCalendarEventsUserApplicantIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetCalendarEventsUserApplicantIdResponse = Schemas.EventReturn[];

export type GetCalendarEventsUserApplicantIdVariables = {
  pathParams: GetCalendarEventsUserApplicantIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Get one user bookings.
 *
 * **Usable by the user or admins**
 */
export const fetchGetCalendarEventsUserApplicantId = (
  variables: GetCalendarEventsUserApplicantIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetCalendarEventsUserApplicantIdResponse,
    GetCalendarEventsUserApplicantIdError,
    undefined,
    {},
    {},
    GetCalendarEventsUserApplicantIdPathParams
  >({
    url: "/calendar/events/user/{applicantId}",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get one user bookings.
 *
 * **Usable by the user or admins**
 */
export const useGetCalendarEventsUserApplicantId = <
  TData = GetCalendarEventsUserApplicantIdResponse,
>(
  variables: GetCalendarEventsUserApplicantIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCalendarEventsUserApplicantIdResponse,
      GetCalendarEventsUserApplicantIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<
    GetCalendarEventsUserApplicantIdResponse,
    GetCalendarEventsUserApplicantIdError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/calendar/events/user/{applicantId}",
      operationId: "getCalendarEventsUserApplicantId",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetCalendarEventsUserApplicantId(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type GetCalendarEventsEventIdPathParams = {
  eventId: string;
};

export type GetCalendarEventsEventIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetCalendarEventsEventIdVariables = {
  pathParams: GetCalendarEventsEventIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Get an event's information by its id.
 */
export const fetchGetCalendarEventsEventId = (
  variables: GetCalendarEventsEventIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.EventComplete,
    GetCalendarEventsEventIdError,
    undefined,
    {},
    {},
    GetCalendarEventsEventIdPathParams
  >({ url: "/calendar/events/{eventId}", method: "get", ...variables, signal });

/**
 * Get an event's information by its id.
 */
export const useGetCalendarEventsEventId = <TData = Schemas.EventComplete,>(
  variables: GetCalendarEventsEventIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.EventComplete,
      GetCalendarEventsEventIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<
    Schemas.EventComplete,
    GetCalendarEventsEventIdError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/calendar/events/{eventId}",
      operationId: "getCalendarEventsEventId",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetCalendarEventsEventId(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type PatchCalendarEventsEventIdPathParams = {
  eventId: string;
};

export type PatchCalendarEventsEventIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PatchCalendarEventsEventIdVariables = {
  body?: Schemas.EventEdit;
  pathParams: PatchCalendarEventsEventIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Edit an event.
 *
 * **Only usable by admins or applicant before decision**
 */
export const fetchPatchCalendarEventsEventId = (
  variables: PatchCalendarEventsEventIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchCalendarEventsEventIdError,
    Schemas.EventEdit,
    {},
    {},
    PatchCalendarEventsEventIdPathParams
  >({
    url: "/calendar/events/{eventId}",
    method: "patch",
    ...variables,
    signal,
  });

/**
 * Edit an event.
 *
 * **Only usable by admins or applicant before decision**
 */
export const usePatchCalendarEventsEventId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchCalendarEventsEventIdError,
      PatchCalendarEventsEventIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchCalendarEventsEventIdError,
    PatchCalendarEventsEventIdVariables
  >({
    mutationFn: (variables: PatchCalendarEventsEventIdVariables) =>
      fetchPatchCalendarEventsEventId({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type DeleteCalendarEventsEventIdPathParams = {
  eventId: void;
};

export type DeleteCalendarEventsEventIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type DeleteCalendarEventsEventIdVariables = {
  pathParams: DeleteCalendarEventsEventIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Remove an event.
 *
 * **Only usable by admins or applicant before decision**
 */
export const fetchDeleteCalendarEventsEventId = (
  variables: DeleteCalendarEventsEventIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteCalendarEventsEventIdError,
    undefined,
    {},
    {},
    DeleteCalendarEventsEventIdPathParams
  >({
    url: "/calendar/events/{eventId}",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * Remove an event.
 *
 * **Only usable by admins or applicant before decision**
 */
export const useDeleteCalendarEventsEventId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteCalendarEventsEventIdError,
      DeleteCalendarEventsEventIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteCalendarEventsEventIdError,
    DeleteCalendarEventsEventIdVariables
  >({
    mutationFn: (variables: DeleteCalendarEventsEventIdVariables) =>
      fetchDeleteCalendarEventsEventId({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetCalendarEventsEventIdApplicantPathParams = {
  eventId: string;
};

export type GetCalendarEventsEventIdApplicantError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetCalendarEventsEventIdApplicantVariables = {
  pathParams: GetCalendarEventsEventIdApplicantPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchGetCalendarEventsEventIdApplicant = (
  variables: GetCalendarEventsEventIdApplicantVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.EventApplicant,
    GetCalendarEventsEventIdApplicantError,
    undefined,
    {},
    {},
    GetCalendarEventsEventIdApplicantPathParams
  >({
    url: "/calendar/events/{eventId}/applicant",
    method: "get",
    ...variables,
    signal,
  });

export const useGetCalendarEventsEventIdApplicant = <
  TData = Schemas.EventApplicant,
>(
  variables: GetCalendarEventsEventIdApplicantVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.EventApplicant,
      GetCalendarEventsEventIdApplicantError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<
    Schemas.EventApplicant,
    GetCalendarEventsEventIdApplicantError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/calendar/events/{eventId}/applicant",
      operationId: "getCalendarEventsEventIdApplicant",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetCalendarEventsEventIdApplicant(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type PatchCalendarEventsEventIdReplyDecisionPathParams = {
  eventId: string;
  decision: Schemas.Decision;
};

export type PatchCalendarEventsEventIdReplyDecisionError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type PatchCalendarEventsEventIdReplyDecisionVariables = {
  pathParams: PatchCalendarEventsEventIdReplyDecisionPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Give a decision to an event.
 *
 * **Only usable by admins**
 */
export const fetchPatchCalendarEventsEventIdReplyDecision = (
  variables: PatchCalendarEventsEventIdReplyDecisionVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchCalendarEventsEventIdReplyDecisionError,
    undefined,
    {},
    {},
    PatchCalendarEventsEventIdReplyDecisionPathParams
  >({
    url: "/calendar/events/{eventId}/reply/{decision}",
    method: "patch",
    ...variables,
    signal,
  });

/**
 * Give a decision to an event.
 *
 * **Only usable by admins**
 */
export const usePatchCalendarEventsEventIdReplyDecision = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchCalendarEventsEventIdReplyDecisionError,
      PatchCalendarEventsEventIdReplyDecisionVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchCalendarEventsEventIdReplyDecisionError,
    PatchCalendarEventsEventIdReplyDecisionVariables
  >({
    mutationFn: (variables: PatchCalendarEventsEventIdReplyDecisionVariables) =>
      fetchPatchCalendarEventsEventIdReplyDecision({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type PostCalendarIcalCreateError = Fetcher.ErrorWrapper<undefined>;

export type PostCalendarIcalCreateVariables = HyperionContext["fetcherOptions"];

/**
 * Create manually the icalendar file
 *
 * **Only usable by global admins**
 */
export const fetchPostCalendarIcalCreate = (
  variables: PostCalendarIcalCreateVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<undefined, PostCalendarIcalCreateError, undefined, {}, {}, {}>({
    url: "/calendar/ical/create",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Create manually the icalendar file
 *
 * **Only usable by global admins**
 */
export const usePostCalendarIcalCreate = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PostCalendarIcalCreateError,
      PostCalendarIcalCreateVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PostCalendarIcalCreateError,
    PostCalendarIcalCreateVariables
  >({
    mutationFn: (variables: PostCalendarIcalCreateVariables) =>
      fetchPostCalendarIcalCreate({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetCalendarIcalError = Fetcher.ErrorWrapper<undefined>;

export type GetCalendarIcalVariables = HyperionContext["fetcherOptions"];

/**
 * Get the icalendar file corresponding to the event in the database.
 */
export const fetchGetCalendarIcal = (
  variables: GetCalendarIcalVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<undefined, GetCalendarIcalError, undefined, {}, {}, {}>({
    url: "/calendar/ical",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get the icalendar file corresponding to the event in the database.
 */
export const useGetCalendarIcal = <TData = undefined,>(
  variables: GetCalendarIcalVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, GetCalendarIcalError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<undefined, GetCalendarIcalError, TData>({
    queryKey: queryKeyFn({
      path: "/calendar/ical",
      operationId: "getCalendarIcal",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetCalendarIcal({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type GetCampaignSectionsError = Fetcher.ErrorWrapper<undefined>;

export type GetCampaignSectionsResponse = Schemas.SectionComplete[];

export type GetCampaignSectionsVariables = HyperionContext["fetcherOptions"];

/**
 * Return sections in the database as a list of `schemas_campaign.SectionBase`
 *
 * **The user must be a member of a group authorized to vote (voters) or a member of the group CAA to use this endpoint**
 */
export const fetchGetCampaignSections = (
  variables: GetCampaignSectionsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetCampaignSectionsResponse,
    GetCampaignSectionsError,
    undefined,
    {},
    {},
    {}
  >({ url: "/campaign/sections", method: "get", ...variables, signal });

/**
 * Return sections in the database as a list of `schemas_campaign.SectionBase`
 *
 * **The user must be a member of a group authorized to vote (voters) or a member of the group CAA to use this endpoint**
 */
export const useGetCampaignSections = <TData = GetCampaignSectionsResponse,>(
  variables: GetCampaignSectionsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCampaignSectionsResponse,
      GetCampaignSectionsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<
    GetCampaignSectionsResponse,
    GetCampaignSectionsError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/campaign/sections",
      operationId: "getCampaignSections",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetCampaignSections({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type PostCampaignSectionsError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostCampaignSectionsVariables = {
  body: Schemas.SectionBase;
} & HyperionContext["fetcherOptions"];

/**
 * Add a section.
 *
 * This endpoint can only be used in 'waiting' status.
 *
 * **The user must be a member of the group CAA to use this endpoint**
 */
export const fetchPostCampaignSections = (
  variables: PostCampaignSectionsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.SectionComplete,
    PostCampaignSectionsError,
    Schemas.SectionBase,
    {},
    {},
    {}
  >({ url: "/campaign/sections", method: "post", ...variables, signal });

/**
 * Add a section.
 *
 * This endpoint can only be used in 'waiting' status.
 *
 * **The user must be a member of the group CAA to use this endpoint**
 */
export const usePostCampaignSections = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.SectionComplete,
      PostCampaignSectionsError,
      PostCampaignSectionsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.SectionComplete,
    PostCampaignSectionsError,
    PostCampaignSectionsVariables
  >({
    mutationFn: (variables: PostCampaignSectionsVariables) =>
      fetchPostCampaignSections({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type DeleteCampaignSectionsSectionIdPathParams = {
  sectionId: string;
};

export type DeleteCampaignSectionsSectionIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type DeleteCampaignSectionsSectionIdVariables = {
  pathParams: DeleteCampaignSectionsSectionIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Delete a section.
 *
 * This endpoint can only be used in 'waiting' status.
 *
 * **The user must be a member of the group CAA to use this endpoint**
 */
export const fetchDeleteCampaignSectionsSectionId = (
  variables: DeleteCampaignSectionsSectionIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteCampaignSectionsSectionIdError,
    undefined,
    {},
    {},
    DeleteCampaignSectionsSectionIdPathParams
  >({
    url: "/campaign/sections/{sectionId}",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * Delete a section.
 *
 * This endpoint can only be used in 'waiting' status.
 *
 * **The user must be a member of the group CAA to use this endpoint**
 */
export const useDeleteCampaignSectionsSectionId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteCampaignSectionsSectionIdError,
      DeleteCampaignSectionsSectionIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteCampaignSectionsSectionIdError,
    DeleteCampaignSectionsSectionIdVariables
  >({
    mutationFn: (variables: DeleteCampaignSectionsSectionIdVariables) =>
      fetchDeleteCampaignSectionsSectionId({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetCampaignListsError = Fetcher.ErrorWrapper<undefined>;

export type GetCampaignListsResponse = Schemas.ListReturn[];

export type GetCampaignListsVariables = HyperionContext["fetcherOptions"];

/**
 * Return campaign lists registered for the vote.
 *
 * **The user must be a member of a group authorized to vote (voters) or a member of the group CAA to use this endpoint**
 */
export const fetchGetCampaignLists = (
  variables: GetCampaignListsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetCampaignListsResponse,
    GetCampaignListsError,
    undefined,
    {},
    {},
    {}
  >({ url: "/campaign/lists", method: "get", ...variables, signal });

/**
 * Return campaign lists registered for the vote.
 *
 * **The user must be a member of a group authorized to vote (voters) or a member of the group CAA to use this endpoint**
 */
export const useGetCampaignLists = <TData = GetCampaignListsResponse,>(
  variables: GetCampaignListsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCampaignListsResponse,
      GetCampaignListsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<
    GetCampaignListsResponse,
    GetCampaignListsError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/campaign/lists",
      operationId: "getCampaignLists",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetCampaignLists({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type PostCampaignListsError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostCampaignListsVariables = {
  body: Schemas.ListBase;
} & HyperionContext["fetcherOptions"];

/**
 * Add a campaign list to a section.
 *
 * This endpoint can only be used in 'waiting' status.
 *
 * **The user must be a member of the group CAA to use this endpoint**
 */
export const fetchPostCampaignLists = (
  variables: PostCampaignListsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.ListReturn,
    PostCampaignListsError,
    Schemas.ListBase,
    {},
    {},
    {}
  >({ url: "/campaign/lists", method: "post", ...variables, signal });

/**
 * Add a campaign list to a section.
 *
 * This endpoint can only be used in 'waiting' status.
 *
 * **The user must be a member of the group CAA to use this endpoint**
 */
export const usePostCampaignLists = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.ListReturn,
      PostCampaignListsError,
      PostCampaignListsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.ListReturn,
    PostCampaignListsError,
    PostCampaignListsVariables
  >({
    mutationFn: (variables: PostCampaignListsVariables) =>
      fetchPostCampaignLists({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type DeleteCampaignListsListIdPathParams = {
  listId: string;
};

export type DeleteCampaignListsListIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type DeleteCampaignListsListIdVariables = {
  pathParams: DeleteCampaignListsListIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Delete the campaign list with the given id.
 *
 * This endpoint can only be used in 'waiting' status.
 *
 * **The user must be a member of the group CAA to use this endpoint**
 */
export const fetchDeleteCampaignListsListId = (
  variables: DeleteCampaignListsListIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteCampaignListsListIdError,
    undefined,
    {},
    {},
    DeleteCampaignListsListIdPathParams
  >({
    url: "/campaign/lists/{listId}",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * Delete the campaign list with the given id.
 *
 * This endpoint can only be used in 'waiting' status.
 *
 * **The user must be a member of the group CAA to use this endpoint**
 */
export const useDeleteCampaignListsListId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteCampaignListsListIdError,
      DeleteCampaignListsListIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteCampaignListsListIdError,
    DeleteCampaignListsListIdVariables
  >({
    mutationFn: (variables: DeleteCampaignListsListIdVariables) =>
      fetchDeleteCampaignListsListId({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type PatchCampaignListsListIdPathParams = {
  listId: string;
};

export type PatchCampaignListsListIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PatchCampaignListsListIdVariables = {
  body?: Schemas.ListEdit;
  pathParams: PatchCampaignListsListIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Update the campaign list with the given id.
 *
 * This endpoint can only be used in 'waiting' status.
 *
 * **The user must be a member of the group CAA to use this endpoint**
 */
export const fetchPatchCampaignListsListId = (
  variables: PatchCampaignListsListIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchCampaignListsListIdError,
    Schemas.ListEdit,
    {},
    {},
    PatchCampaignListsListIdPathParams
  >({ url: "/campaign/lists/{listId}", method: "patch", ...variables, signal });

/**
 * Update the campaign list with the given id.
 *
 * This endpoint can only be used in 'waiting' status.
 *
 * **The user must be a member of the group CAA to use this endpoint**
 */
export const usePatchCampaignListsListId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchCampaignListsListIdError,
      PatchCampaignListsListIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchCampaignListsListIdError,
    PatchCampaignListsListIdVariables
  >({
    mutationFn: (variables: PatchCampaignListsListIdVariables) =>
      fetchPatchCampaignListsListId({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type DeleteCampaignListsQueryParams = {
  list_type?: Schemas.ListType | null;
};

export type DeleteCampaignListsError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type DeleteCampaignListsVariables = {
  queryParams?: DeleteCampaignListsQueryParams;
} & HyperionContext["fetcherOptions"];

/**
 * Delete the all lists by type.
 *
 * This endpoint can only be used in 'waiting' status.
 *
 * **The user must be a member of the group CAA to use this endpoint**
 */
export const fetchDeleteCampaignLists = (
  variables: DeleteCampaignListsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteCampaignListsError,
    undefined,
    {},
    DeleteCampaignListsQueryParams,
    {}
  >({ url: "/campaign/lists/", method: "delete", ...variables, signal });

/**
 * Delete the all lists by type.
 *
 * This endpoint can only be used in 'waiting' status.
 *
 * **The user must be a member of the group CAA to use this endpoint**
 */
export const useDeleteCampaignLists = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteCampaignListsError,
      DeleteCampaignListsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteCampaignListsError,
    DeleteCampaignListsVariables
  >({
    mutationFn: (variables: DeleteCampaignListsVariables) =>
      fetchDeleteCampaignLists({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetCampaignVotersError = Fetcher.ErrorWrapper<undefined>;

export type GetCampaignVotersResponse = Schemas.VoterGroup[];

export type GetCampaignVotersVariables = HyperionContext["fetcherOptions"];

/**
 * Return the voters (groups allowed to vote) for the current campaign.
 */
export const fetchGetCampaignVoters = (
  variables: GetCampaignVotersVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetCampaignVotersResponse,
    GetCampaignVotersError,
    undefined,
    {},
    {},
    {}
  >({ url: "/campaign/voters", method: "get", ...variables, signal });

/**
 * Return the voters (groups allowed to vote) for the current campaign.
 */
export const useGetCampaignVoters = <TData = GetCampaignVotersResponse,>(
  variables: GetCampaignVotersVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCampaignVotersResponse,
      GetCampaignVotersError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<
    GetCampaignVotersResponse,
    GetCampaignVotersError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/campaign/voters",
      operationId: "getCampaignVoters",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetCampaignVoters({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type PostCampaignVotersError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostCampaignVotersVariables = {
  body: Schemas.VoterGroup;
} & HyperionContext["fetcherOptions"];

/**
 * Add voters (groups allowed to vote) for this campaign
 *
 * **The user must be a member of the group CAA to use this endpoint**
 */
export const fetchPostCampaignVoters = (
  variables: PostCampaignVotersVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.VoterGroup,
    PostCampaignVotersError,
    Schemas.VoterGroup,
    {},
    {},
    {}
  >({ url: "/campaign/voters", method: "post", ...variables, signal });

/**
 * Add voters (groups allowed to vote) for this campaign
 *
 * **The user must be a member of the group CAA to use this endpoint**
 */
export const usePostCampaignVoters = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.VoterGroup,
      PostCampaignVotersError,
      PostCampaignVotersVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.VoterGroup,
    PostCampaignVotersError,
    PostCampaignVotersVariables
  >({
    mutationFn: (variables: PostCampaignVotersVariables) =>
      fetchPostCampaignVoters({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type DeleteCampaignVotersError = Fetcher.ErrorWrapper<undefined>;

export type DeleteCampaignVotersVariables = HyperionContext["fetcherOptions"];

/**
 * Remove voters (groups allowed to vote)
 *
 * **The user must be a member of the group CAA to use this endpoint**
 */
export const fetchDeleteCampaignVoters = (
  variables: DeleteCampaignVotersVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<undefined, DeleteCampaignVotersError, undefined, {}, {}, {}>({
    url: "/campaign/voters",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * Remove voters (groups allowed to vote)
 *
 * **The user must be a member of the group CAA to use this endpoint**
 */
export const useDeleteCampaignVoters = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteCampaignVotersError,
      DeleteCampaignVotersVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteCampaignVotersError,
    DeleteCampaignVotersVariables
  >({
    mutationFn: (variables: DeleteCampaignVotersVariables) =>
      fetchDeleteCampaignVoters({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type DeleteCampaignVotersGroupIdPathParams = {
  groupId: string;
};

export type DeleteCampaignVotersGroupIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type DeleteCampaignVotersGroupIdVariables = {
  pathParams: DeleteCampaignVotersGroupIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Remove a voter by its group id
 *
 * **The user must be a member of the group CAA to use this endpoint**
 */
export const fetchDeleteCampaignVotersGroupId = (
  variables: DeleteCampaignVotersGroupIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteCampaignVotersGroupIdError,
    undefined,
    {},
    {},
    DeleteCampaignVotersGroupIdPathParams
  >({
    url: "/campaign/voters/{groupId}",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * Remove a voter by its group id
 *
 * **The user must be a member of the group CAA to use this endpoint**
 */
export const useDeleteCampaignVotersGroupId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteCampaignVotersGroupIdError,
      DeleteCampaignVotersGroupIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteCampaignVotersGroupIdError,
    DeleteCampaignVotersGroupIdVariables
  >({
    mutationFn: (variables: DeleteCampaignVotersGroupIdVariables) =>
      fetchDeleteCampaignVotersGroupId({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type PostCampaignStatusOpenError = Fetcher.ErrorWrapper<undefined>;

export type PostCampaignStatusOpenVariables = HyperionContext["fetcherOptions"];

/**
 * If the status is 'waiting', change it to 'voting' and create the blank lists.
 *
 * > WARNING: this operation can not be reversed.
 * > When the status is 'open', all users can vote and sections and lists can no longer be edited.
 *
 * **The user must be a member of the group CAA to use this endpoint**
 */
export const fetchPostCampaignStatusOpen = (
  variables: PostCampaignStatusOpenVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<undefined, PostCampaignStatusOpenError, undefined, {}, {}, {}>({
    url: "/campaign/status/open",
    method: "post",
    ...variables,
    signal,
  });

/**
 * If the status is 'waiting', change it to 'voting' and create the blank lists.
 *
 * > WARNING: this operation can not be reversed.
 * > When the status is 'open', all users can vote and sections and lists can no longer be edited.
 *
 * **The user must be a member of the group CAA to use this endpoint**
 */
export const usePostCampaignStatusOpen = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PostCampaignStatusOpenError,
      PostCampaignStatusOpenVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PostCampaignStatusOpenError,
    PostCampaignStatusOpenVariables
  >({
    mutationFn: (variables: PostCampaignStatusOpenVariables) =>
      fetchPostCampaignStatusOpen({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type PostCampaignStatusCloseError = Fetcher.ErrorWrapper<undefined>;

export type PostCampaignStatusCloseVariables =
  HyperionContext["fetcherOptions"];

/**
 * If the status is 'open', change it to 'closed'.
 *
 * > WARNING: this operation can not be reversed.
 * > When the status is 'closed', users are no longer able to vote.
 *
 * **The user must be a member of the group CAA to use this endpoint**
 */
export const fetchPostCampaignStatusClose = (
  variables: PostCampaignStatusCloseVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<undefined, PostCampaignStatusCloseError, undefined, {}, {}, {}>(
    { url: "/campaign/status/close", method: "post", ...variables, signal },
  );

/**
 * If the status is 'open', change it to 'closed'.
 *
 * > WARNING: this operation can not be reversed.
 * > When the status is 'closed', users are no longer able to vote.
 *
 * **The user must be a member of the group CAA to use this endpoint**
 */
export const usePostCampaignStatusClose = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PostCampaignStatusCloseError,
      PostCampaignStatusCloseVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PostCampaignStatusCloseError,
    PostCampaignStatusCloseVariables
  >({
    mutationFn: (variables: PostCampaignStatusCloseVariables) =>
      fetchPostCampaignStatusClose({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type PostCampaignStatusCountingError = Fetcher.ErrorWrapper<undefined>;

export type PostCampaignStatusCountingVariables =
  HyperionContext["fetcherOptions"];

/**
 * If the status is 'closed', change it to 'counting'.
 *
 * > WARNING: this operation can not be reversed.
 * > When the status is 'counting', administrators can see the results of the vote.
 *
 * **The user must be a member of the group CAA to use this endpoint**
 */
export const fetchPostCampaignStatusCounting = (
  variables: PostCampaignStatusCountingVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PostCampaignStatusCountingError,
    undefined,
    {},
    {},
    {}
  >({ url: "/campaign/status/counting", method: "post", ...variables, signal });

/**
 * If the status is 'closed', change it to 'counting'.
 *
 * > WARNING: this operation can not be reversed.
 * > When the status is 'counting', administrators can see the results of the vote.
 *
 * **The user must be a member of the group CAA to use this endpoint**
 */
export const usePostCampaignStatusCounting = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PostCampaignStatusCountingError,
      PostCampaignStatusCountingVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PostCampaignStatusCountingError,
    PostCampaignStatusCountingVariables
  >({
    mutationFn: (variables: PostCampaignStatusCountingVariables) =>
      fetchPostCampaignStatusCounting({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type PostCampaignStatusPublishedError = Fetcher.ErrorWrapper<undefined>;

export type PostCampaignStatusPublishedVariables =
  HyperionContext["fetcherOptions"];

/**
 * If the status is 'counting', change it to 'published'.
 *
 * > WARNING: this operation can not be reversed.
 * > When the status is 'published', everyone can see the results of the vote.
 *
 * **The user must be a member of the group CAA to use this endpoint**
 */
export const fetchPostCampaignStatusPublished = (
  variables: PostCampaignStatusPublishedVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PostCampaignStatusPublishedError,
    undefined,
    {},
    {},
    {}
  >({
    url: "/campaign/status/published",
    method: "post",
    ...variables,
    signal,
  });

/**
 * If the status is 'counting', change it to 'published'.
 *
 * > WARNING: this operation can not be reversed.
 * > When the status is 'published', everyone can see the results of the vote.
 *
 * **The user must be a member of the group CAA to use this endpoint**
 */
export const usePostCampaignStatusPublished = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PostCampaignStatusPublishedError,
      PostCampaignStatusPublishedVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PostCampaignStatusPublishedError,
    PostCampaignStatusPublishedVariables
  >({
    mutationFn: (variables: PostCampaignStatusPublishedVariables) =>
      fetchPostCampaignStatusPublished({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type PostCampaignStatusResetError = Fetcher.ErrorWrapper<undefined>;

export type PostCampaignStatusResetVariables =
  HyperionContext["fetcherOptions"];

/**
 * Reset the vote. Can only be used if the current status is counting ou published.
 *
 * > WARNING: This will delete all votes then put the module to Waiting status. This will also delete blank lists.
 *
 * **The user must be a member of the group CAA to use this endpoint**
 */
export const fetchPostCampaignStatusReset = (
  variables: PostCampaignStatusResetVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<undefined, PostCampaignStatusResetError, undefined, {}, {}, {}>(
    { url: "/campaign/status/reset", method: "post", ...variables, signal },
  );

/**
 * Reset the vote. Can only be used if the current status is counting ou published.
 *
 * > WARNING: This will delete all votes then put the module to Waiting status. This will also delete blank lists.
 *
 * **The user must be a member of the group CAA to use this endpoint**
 */
export const usePostCampaignStatusReset = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PostCampaignStatusResetError,
      PostCampaignStatusResetVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PostCampaignStatusResetError,
    PostCampaignStatusResetVariables
  >({
    mutationFn: (variables: PostCampaignStatusResetVariables) =>
      fetchPostCampaignStatusReset({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetCampaignVotesError = Fetcher.ErrorWrapper<undefined>;

export type GetCampaignVotesResponse = string[];

export type GetCampaignVotesVariables = HyperionContext["fetcherOptions"];

/**
 * Return the list of id of sections an user has already voted for.
 *
 * **The user must be a member of a group authorized to vote (voters) to use this endpoint**
 */
export const fetchGetCampaignVotes = (
  variables: GetCampaignVotesVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetCampaignVotesResponse,
    GetCampaignVotesError,
    undefined,
    {},
    {},
    {}
  >({ url: "/campaign/votes", method: "get", ...variables, signal });

/**
 * Return the list of id of sections an user has already voted for.
 *
 * **The user must be a member of a group authorized to vote (voters) to use this endpoint**
 */
export const useGetCampaignVotes = <TData = GetCampaignVotesResponse,>(
  variables: GetCampaignVotesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCampaignVotesResponse,
      GetCampaignVotesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<
    GetCampaignVotesResponse,
    GetCampaignVotesError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/campaign/votes",
      operationId: "getCampaignVotes",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetCampaignVotes({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type PostCampaignVotesError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostCampaignVotesVariables = {
  body: Schemas.VoteBase;
} & HyperionContext["fetcherOptions"];

/**
 * Add a vote for a given campaign list.
 *
 * An user can only vote for one list per section.
 *
 * **The user must be a member of a group authorized to vote (voters) to use this endpoint**
 */
export const fetchPostCampaignVotes = (
  variables: PostCampaignVotesVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PostCampaignVotesError,
    Schemas.VoteBase,
    {},
    {},
    {}
  >({ url: "/campaign/votes", method: "post", ...variables, signal });

/**
 * Add a vote for a given campaign list.
 *
 * An user can only vote for one list per section.
 *
 * **The user must be a member of a group authorized to vote (voters) to use this endpoint**
 */
export const usePostCampaignVotes = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PostCampaignVotesError,
      PostCampaignVotesVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PostCampaignVotesError,
    PostCampaignVotesVariables
  >({
    mutationFn: (variables: PostCampaignVotesVariables) =>
      fetchPostCampaignVotes({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetCampaignResultsError = Fetcher.ErrorWrapper<undefined>;

export type GetCampaignResultsResponse =
  Schemas.AppModulesCampaignSchemasCampaignResult[];

export type GetCampaignResultsVariables = HyperionContext["fetcherOptions"];

/**
 * Return the results of the vote.
 *
 * **The user must be a member of a group authorized to vote (voters) or a member of the group CAA to use this endpoint**
 */
export const fetchGetCampaignResults = (
  variables: GetCampaignResultsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetCampaignResultsResponse,
    GetCampaignResultsError,
    undefined,
    {},
    {},
    {}
  >({ url: "/campaign/results", method: "get", ...variables, signal });

/**
 * Return the results of the vote.
 *
 * **The user must be a member of a group authorized to vote (voters) or a member of the group CAA to use this endpoint**
 */
export const useGetCampaignResults = <TData = GetCampaignResultsResponse,>(
  variables: GetCampaignResultsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCampaignResultsResponse,
      GetCampaignResultsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<
    GetCampaignResultsResponse,
    GetCampaignResultsError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/campaign/results",
      operationId: "getCampaignResults",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetCampaignResults({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type GetCampaignStatusError = Fetcher.ErrorWrapper<undefined>;

export type GetCampaignStatusVariables = HyperionContext["fetcherOptions"];

/**
 * Get the current status of the vote.
 *
 * **The user must be a member of a group authorized to vote (voters) or a member of the group CAA to use this endpoint**
 */
export const fetchGetCampaignStatus = (
  variables: GetCampaignStatusVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.VoteStatus,
    GetCampaignStatusError,
    undefined,
    {},
    {},
    {}
  >({ url: "/campaign/status", method: "get", ...variables, signal });

/**
 * Get the current status of the vote.
 *
 * **The user must be a member of a group authorized to vote (voters) or a member of the group CAA to use this endpoint**
 */
export const useGetCampaignStatus = <TData = Schemas.VoteStatus,>(
  variables: GetCampaignStatusVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.VoteStatus,
      GetCampaignStatusError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<Schemas.VoteStatus, GetCampaignStatusError, TData>(
    {
      queryKey: queryKeyFn({
        path: "/campaign/status",
        operationId: "getCampaignStatus",
        variables,
      }),
      queryFn: ({ signal }) =>
        fetchGetCampaignStatus({ ...fetcherOptions, ...variables }, signal),
      ...options,
      ...queryOptions,
    },
  );
};

export type GetCampaignStatsSectionIdPathParams = {
  sectionId: string;
};

export type GetCampaignStatsSectionIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetCampaignStatsSectionIdVariables = {
  pathParams: GetCampaignStatsSectionIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Get stats about a given section.
 *
 * **The user must be a member of the group CAA to use this endpoint**
 */
export const fetchGetCampaignStatsSectionId = (
  variables: GetCampaignStatsSectionIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.VoteStats,
    GetCampaignStatsSectionIdError,
    undefined,
    {},
    {},
    GetCampaignStatsSectionIdPathParams
  >({
    url: "/campaign/stats/{sectionId}",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get stats about a given section.
 *
 * **The user must be a member of the group CAA to use this endpoint**
 */
export const useGetCampaignStatsSectionId = <TData = Schemas.VoteStats,>(
  variables: GetCampaignStatsSectionIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.VoteStats,
      GetCampaignStatsSectionIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<
    Schemas.VoteStats,
    GetCampaignStatsSectionIdError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/campaign/stats/{sectionId}",
      operationId: "getCampaignStatsSectionId",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetCampaignStatsSectionId(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type PostCampaignListsListIdLogoPathParams = {
  listId: string;
};

export type PostCampaignListsListIdLogoError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostCampaignListsListIdLogoVariables = {
  body: Schemas.BodyCreateCampaignsLogoCampaignListsListIdLogoPost;
  pathParams: PostCampaignListsListIdLogoPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Upload a logo for a campaign list.
 *
 * **The user must be a member of the group CAA to use this endpoint**
 */
export const fetchPostCampaignListsListIdLogo = (
  variables: PostCampaignListsListIdLogoVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.AppCoreStandardResponsesResult,
    PostCampaignListsListIdLogoError,
    Schemas.BodyCreateCampaignsLogoCampaignListsListIdLogoPost,
    {},
    {},
    PostCampaignListsListIdLogoPathParams
  >({
    url: "/campaign/lists/{listId}/logo",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Upload a logo for a campaign list.
 *
 * **The user must be a member of the group CAA to use this endpoint**
 */
export const usePostCampaignListsListIdLogo = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.AppCoreStandardResponsesResult,
      PostCampaignListsListIdLogoError,
      PostCampaignListsListIdLogoVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.AppCoreStandardResponsesResult,
    PostCampaignListsListIdLogoError,
    PostCampaignListsListIdLogoVariables
  >({
    mutationFn: (variables: PostCampaignListsListIdLogoVariables) =>
      fetchPostCampaignListsListIdLogo({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetCampaignListsListIdLogoPathParams = {
  listId: string;
};

export type GetCampaignListsListIdLogoError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetCampaignListsListIdLogoVariables = {
  pathParams: GetCampaignListsListIdLogoPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Get the logo of a campaign list.
 * **The user must be a member of a group authorized to vote (voters) or a member of the group CAA to use this endpoint**
 */
export const fetchGetCampaignListsListIdLogo = (
  variables: GetCampaignListsListIdLogoVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    GetCampaignListsListIdLogoError,
    undefined,
    {},
    {},
    GetCampaignListsListIdLogoPathParams
  >({
    url: "/campaign/lists/{listId}/logo",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get the logo of a campaign list.
 * **The user must be a member of a group authorized to vote (voters) or a member of the group CAA to use this endpoint**
 */
export const useGetCampaignListsListIdLogo = <TData = undefined,>(
  variables: GetCampaignListsListIdLogoVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      undefined,
      GetCampaignListsListIdLogoError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<undefined, GetCampaignListsListIdLogoError, TData>(
    {
      queryKey: queryKeyFn({
        path: "/campaign/lists/{listId}/logo",
        operationId: "getCampaignListsListIdLogo",
        variables,
      }),
      queryFn: ({ signal }) =>
        fetchGetCampaignListsListIdLogo(
          { ...fetcherOptions, ...variables },
          signal,
        ),
      ...options,
      ...queryOptions,
    },
  );
};

export type GetCdrSellersError = Fetcher.ErrorWrapper<undefined>;

export type GetCdrSellersResponse = Schemas.SellerComplete[];

export type GetCdrSellersVariables = HyperionContext["fetcherOptions"];

export const fetchGetCdrSellers = (
  variables: GetCdrSellersVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetCdrSellersResponse,
    GetCdrSellersError,
    undefined,
    {},
    {},
    {}
  >({ url: "/cdr/sellers/", method: "get", ...variables, signal });

export const useGetCdrSellers = <TData = GetCdrSellersResponse,>(
  variables: GetCdrSellersVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCdrSellersResponse,
      GetCdrSellersError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<GetCdrSellersResponse, GetCdrSellersError, TData>({
    queryKey: queryKeyFn({
      path: "/cdr/sellers/",
      operationId: "getCdrSellers",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetCdrSellers({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type PostCdrSellersError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostCdrSellersVariables = {
  body: Schemas.SellerBase;
} & HyperionContext["fetcherOptions"];

export const fetchPostCdrSellers = (
  variables: PostCdrSellersVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.SellerComplete,
    PostCdrSellersError,
    Schemas.SellerBase,
    {},
    {},
    {}
  >({ url: "/cdr/sellers/", method: "post", ...variables, signal });

export const usePostCdrSellers = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.SellerComplete,
      PostCdrSellersError,
      PostCdrSellersVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.SellerComplete,
    PostCdrSellersError,
    PostCdrSellersVariables
  >({
    mutationFn: (variables: PostCdrSellersVariables) =>
      fetchPostCdrSellers({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetCdrUsersMeSellersError = Fetcher.ErrorWrapper<undefined>;

export type GetCdrUsersMeSellersResponse = Schemas.SellerComplete[];

export type GetCdrUsersMeSellersVariables = HyperionContext["fetcherOptions"];

export const fetchGetCdrUsersMeSellers = (
  variables: GetCdrUsersMeSellersVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetCdrUsersMeSellersResponse,
    GetCdrUsersMeSellersError,
    undefined,
    {},
    {},
    {}
  >({ url: "/cdr/users/me/sellers/", method: "get", ...variables, signal });

export const useGetCdrUsersMeSellers = <TData = GetCdrUsersMeSellersResponse,>(
  variables: GetCdrUsersMeSellersVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCdrUsersMeSellersResponse,
      GetCdrUsersMeSellersError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<
    GetCdrUsersMeSellersResponse,
    GetCdrUsersMeSellersError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/cdr/users/me/sellers/",
      operationId: "getCdrUsersMeSellers",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetCdrUsersMeSellers({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type GetCdrOnlineSellersError = Fetcher.ErrorWrapper<undefined>;

export type GetCdrOnlineSellersResponse = Schemas.SellerComplete[];

export type GetCdrOnlineSellersVariables = HyperionContext["fetcherOptions"];

export const fetchGetCdrOnlineSellers = (
  variables: GetCdrOnlineSellersVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetCdrOnlineSellersResponse,
    GetCdrOnlineSellersError,
    undefined,
    {},
    {},
    {}
  >({ url: "/cdr/online/sellers/", method: "get", ...variables, signal });

export const useGetCdrOnlineSellers = <TData = GetCdrOnlineSellersResponse,>(
  variables: GetCdrOnlineSellersVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCdrOnlineSellersResponse,
      GetCdrOnlineSellersError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<
    GetCdrOnlineSellersResponse,
    GetCdrOnlineSellersError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/cdr/online/sellers/",
      operationId: "getCdrOnlineSellers",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetCdrOnlineSellers({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type PatchCdrSellersSellerIdPathParams = {
  /**
   * @format uuid
   */
  sellerId: string;
};

export type PatchCdrSellersSellerIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PatchCdrSellersSellerIdVariables = {
  body?: Schemas.SellerEdit;
  pathParams: PatchCdrSellersSellerIdPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchPatchCdrSellersSellerId = (
  variables: PatchCdrSellersSellerIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchCdrSellersSellerIdError,
    Schemas.SellerEdit,
    {},
    {},
    PatchCdrSellersSellerIdPathParams
  >({ url: "/cdr/sellers/{sellerId}/", method: "patch", ...variables, signal });

export const usePatchCdrSellersSellerId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchCdrSellersSellerIdError,
      PatchCdrSellersSellerIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchCdrSellersSellerIdError,
    PatchCdrSellersSellerIdVariables
  >({
    mutationFn: (variables: PatchCdrSellersSellerIdVariables) =>
      fetchPatchCdrSellersSellerId({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type DeleteCdrSellersSellerIdPathParams = {
  /**
   * @format uuid
   */
  sellerId: string;
};

export type DeleteCdrSellersSellerIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type DeleteCdrSellersSellerIdVariables = {
  pathParams: DeleteCdrSellersSellerIdPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchDeleteCdrSellersSellerId = (
  variables: DeleteCdrSellersSellerIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteCdrSellersSellerIdError,
    undefined,
    {},
    {},
    DeleteCdrSellersSellerIdPathParams
  >({
    url: "/cdr/sellers/{sellerId}/",
    method: "delete",
    ...variables,
    signal,
  });

export const useDeleteCdrSellersSellerId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteCdrSellersSellerIdError,
      DeleteCdrSellersSellerIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteCdrSellersSellerIdError,
    DeleteCdrSellersSellerIdVariables
  >({
    mutationFn: (variables: DeleteCdrSellersSellerIdVariables) =>
      fetchDeleteCdrSellersSellerId({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetCdrSellersSellerIdProductsPathParams = {
  /**
   * @format uuid
   */
  sellerId: string;
};

export type GetCdrSellersSellerIdProductsError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetCdrSellersSellerIdProductsResponse =
  Schemas.AppModulesCdrSchemasCdrProductComplete[];

export type GetCdrSellersSellerIdProductsVariables = {
  pathParams: GetCdrSellersSellerIdProductsPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchGetCdrSellersSellerIdProducts = (
  variables: GetCdrSellersSellerIdProductsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetCdrSellersSellerIdProductsResponse,
    GetCdrSellersSellerIdProductsError,
    undefined,
    {},
    {},
    GetCdrSellersSellerIdProductsPathParams
  >({
    url: "/cdr/sellers/{sellerId}/products/",
    method: "get",
    ...variables,
    signal,
  });

export const useGetCdrSellersSellerIdProducts = <
  TData = GetCdrSellersSellerIdProductsResponse,
>(
  variables: GetCdrSellersSellerIdProductsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCdrSellersSellerIdProductsResponse,
      GetCdrSellersSellerIdProductsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<
    GetCdrSellersSellerIdProductsResponse,
    GetCdrSellersSellerIdProductsError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/cdr/sellers/{sellerId}/products/",
      operationId: "getCdrSellersSellerIdProducts",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetCdrSellersSellerIdProducts(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type PostCdrSellersSellerIdProductsPathParams = {
  /**
   * @format uuid
   */
  sellerId: string;
};

export type PostCdrSellersSellerIdProductsError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostCdrSellersSellerIdProductsVariables = {
  body: Schemas.ProductBase;
  pathParams: PostCdrSellersSellerIdProductsPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchPostCdrSellersSellerIdProducts = (
  variables: PostCdrSellersSellerIdProductsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.AppModulesCdrSchemasCdrProductComplete,
    PostCdrSellersSellerIdProductsError,
    Schemas.ProductBase,
    {},
    {},
    PostCdrSellersSellerIdProductsPathParams
  >({
    url: "/cdr/sellers/{sellerId}/products/",
    method: "post",
    ...variables,
    signal,
  });

export const usePostCdrSellersSellerIdProducts = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.AppModulesCdrSchemasCdrProductComplete,
      PostCdrSellersSellerIdProductsError,
      PostCdrSellersSellerIdProductsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.AppModulesCdrSchemasCdrProductComplete,
    PostCdrSellersSellerIdProductsError,
    PostCdrSellersSellerIdProductsVariables
  >({
    mutationFn: (variables: PostCdrSellersSellerIdProductsVariables) =>
      fetchPostCdrSellersSellerIdProducts({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetCdrOnlineSellersSellerIdProductsPathParams = {
  /**
   * @format uuid
   */
  sellerId: string;
};

export type GetCdrOnlineSellersSellerIdProductsError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetCdrOnlineSellersSellerIdProductsResponse =
  Schemas.AppModulesCdrSchemasCdrProductComplete[];

export type GetCdrOnlineSellersSellerIdProductsVariables = {
  pathParams: GetCdrOnlineSellersSellerIdProductsPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchGetCdrOnlineSellersSellerIdProducts = (
  variables: GetCdrOnlineSellersSellerIdProductsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetCdrOnlineSellersSellerIdProductsResponse,
    GetCdrOnlineSellersSellerIdProductsError,
    undefined,
    {},
    {},
    GetCdrOnlineSellersSellerIdProductsPathParams
  >({
    url: "/cdr/online/sellers/{sellerId}/products/",
    method: "get",
    ...variables,
    signal,
  });

export const useGetCdrOnlineSellersSellerIdProducts = <
  TData = GetCdrOnlineSellersSellerIdProductsResponse,
>(
  variables: GetCdrOnlineSellersSellerIdProductsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCdrOnlineSellersSellerIdProductsResponse,
      GetCdrOnlineSellersSellerIdProductsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<
    GetCdrOnlineSellersSellerIdProductsResponse,
    GetCdrOnlineSellersSellerIdProductsError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/cdr/online/sellers/{sellerId}/products/",
      operationId: "getCdrOnlineSellersSellerIdProducts",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetCdrOnlineSellersSellerIdProducts(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type PostCdrSellersSellerIdProductsProductIdDocumentConstraintDocumentIdPathParams =
  {
    /**
     * @format uuid
     */
    sellerId: string;
    /**
     * @format uuid
     */
    productId: string;
    /**
     * @format uuid
     */
    documentId: string;
  };

export type PostCdrSellersSellerIdProductsProductIdDocumentConstraintDocumentIdError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type PostCdrSellersSellerIdProductsProductIdDocumentConstraintDocumentIdVariables =
  {
    pathParams: PostCdrSellersSellerIdProductsProductIdDocumentConstraintDocumentIdPathParams;
  } & HyperionContext["fetcherOptions"];

export const fetchPostCdrSellersSellerIdProductsProductIdDocumentConstraintDocumentId =
  (
    variables: PostCdrSellersSellerIdProductsProductIdDocumentConstraintDocumentIdVariables,
    signal?: AbortSignal,
  ) =>
    hyperionFetch<
      Schemas.AppModulesCdrSchemasCdrProductComplete,
      PostCdrSellersSellerIdProductsProductIdDocumentConstraintDocumentIdError,
      undefined,
      {},
      {},
      PostCdrSellersSellerIdProductsProductIdDocumentConstraintDocumentIdPathParams
    >({
      url: "/cdr/sellers/{sellerId}/products/{productId}/document_constraint/{documentId}",
      method: "post",
      ...variables,
      signal,
    });

export const usePostCdrSellersSellerIdProductsProductIdDocumentConstraintDocumentId =
  (
    options?: Omit<
      reactQuery.UseMutationOptions<
        Schemas.AppModulesCdrSchemasCdrProductComplete,
        PostCdrSellersSellerIdProductsProductIdDocumentConstraintDocumentIdError,
        PostCdrSellersSellerIdProductsProductIdDocumentConstraintDocumentIdVariables
      >,
      "mutationFn"
    >,
  ) => {
    const { fetcherOptions } = useHyperionContext();
    return reactQuery.useMutation<
      Schemas.AppModulesCdrSchemasCdrProductComplete,
      PostCdrSellersSellerIdProductsProductIdDocumentConstraintDocumentIdError,
      PostCdrSellersSellerIdProductsProductIdDocumentConstraintDocumentIdVariables
    >({
      mutationFn: (
        variables: PostCdrSellersSellerIdProductsProductIdDocumentConstraintDocumentIdVariables,
      ) =>
        fetchPostCdrSellersSellerIdProductsProductIdDocumentConstraintDocumentId(
          { ...fetcherOptions, ...variables },
        ),
      ...options,
    });
  };

export type DeleteCdrSellersSellerIdProductsProductIdDocumentConstraintDocumentIdPathParams =
  {
    /**
     * @format uuid
     */
    sellerId: string;
    /**
     * @format uuid
     */
    productId: string;
    /**
     * @format uuid
     */
    documentId: string;
  };

export type DeleteCdrSellersSellerIdProductsProductIdDocumentConstraintDocumentIdError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type DeleteCdrSellersSellerIdProductsProductIdDocumentConstraintDocumentIdVariables =
  {
    pathParams: DeleteCdrSellersSellerIdProductsProductIdDocumentConstraintDocumentIdPathParams;
  } & HyperionContext["fetcherOptions"];

export const fetchDeleteCdrSellersSellerIdProductsProductIdDocumentConstraintDocumentId =
  (
    variables: DeleteCdrSellersSellerIdProductsProductIdDocumentConstraintDocumentIdVariables,
    signal?: AbortSignal,
  ) =>
    hyperionFetch<
      undefined,
      DeleteCdrSellersSellerIdProductsProductIdDocumentConstraintDocumentIdError,
      undefined,
      {},
      {},
      DeleteCdrSellersSellerIdProductsProductIdDocumentConstraintDocumentIdPathParams
    >({
      url: "/cdr/sellers/{sellerId}/products/{productId}/document_constraint/{documentId}",
      method: "delete",
      ...variables,
      signal,
    });

export const useDeleteCdrSellersSellerIdProductsProductIdDocumentConstraintDocumentId =
  (
    options?: Omit<
      reactQuery.UseMutationOptions<
        undefined,
        DeleteCdrSellersSellerIdProductsProductIdDocumentConstraintDocumentIdError,
        DeleteCdrSellersSellerIdProductsProductIdDocumentConstraintDocumentIdVariables
      >,
      "mutationFn"
    >,
  ) => {
    const { fetcherOptions } = useHyperionContext();
    return reactQuery.useMutation<
      undefined,
      DeleteCdrSellersSellerIdProductsProductIdDocumentConstraintDocumentIdError,
      DeleteCdrSellersSellerIdProductsProductIdDocumentConstraintDocumentIdVariables
    >({
      mutationFn: (
        variables: DeleteCdrSellersSellerIdProductsProductIdDocumentConstraintDocumentIdVariables,
      ) =>
        fetchDeleteCdrSellersSellerIdProductsProductIdDocumentConstraintDocumentId(
          { ...fetcherOptions, ...variables },
        ),
      ...options,
    });
  };

export type PostCdrSellersSellerIdProductsProductIdProductConstraintConstraintIdPathParams =
  {
    /**
     * @format uuid
     */
    sellerId: string;
    /**
     * @format uuid
     */
    productId: string;
    /**
     * @format uuid
     */
    constraintId: string;
  };

export type PostCdrSellersSellerIdProductsProductIdProductConstraintConstraintIdError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type PostCdrSellersSellerIdProductsProductIdProductConstraintConstraintIdVariables =
  {
    pathParams: PostCdrSellersSellerIdProductsProductIdProductConstraintConstraintIdPathParams;
  } & HyperionContext["fetcherOptions"];

export const fetchPostCdrSellersSellerIdProductsProductIdProductConstraintConstraintId =
  (
    variables: PostCdrSellersSellerIdProductsProductIdProductConstraintConstraintIdVariables,
    signal?: AbortSignal,
  ) =>
    hyperionFetch<
      Schemas.AppModulesCdrSchemasCdrProductComplete,
      PostCdrSellersSellerIdProductsProductIdProductConstraintConstraintIdError,
      undefined,
      {},
      {},
      PostCdrSellersSellerIdProductsProductIdProductConstraintConstraintIdPathParams
    >({
      url: "/cdr/sellers/{sellerId}/products/{productId}/product_constraint/{constraintId}",
      method: "post",
      ...variables,
      signal,
    });

export const usePostCdrSellersSellerIdProductsProductIdProductConstraintConstraintId =
  (
    options?: Omit<
      reactQuery.UseMutationOptions<
        Schemas.AppModulesCdrSchemasCdrProductComplete,
        PostCdrSellersSellerIdProductsProductIdProductConstraintConstraintIdError,
        PostCdrSellersSellerIdProductsProductIdProductConstraintConstraintIdVariables
      >,
      "mutationFn"
    >,
  ) => {
    const { fetcherOptions } = useHyperionContext();
    return reactQuery.useMutation<
      Schemas.AppModulesCdrSchemasCdrProductComplete,
      PostCdrSellersSellerIdProductsProductIdProductConstraintConstraintIdError,
      PostCdrSellersSellerIdProductsProductIdProductConstraintConstraintIdVariables
    >({
      mutationFn: (
        variables: PostCdrSellersSellerIdProductsProductIdProductConstraintConstraintIdVariables,
      ) =>
        fetchPostCdrSellersSellerIdProductsProductIdProductConstraintConstraintId(
          { ...fetcherOptions, ...variables },
        ),
      ...options,
    });
  };

export type DeleteCdrSellersSellerIdProductsProductIdProductConstraintConstraintIdPathParams =
  {
    /**
     * @format uuid
     */
    sellerId: string;
    /**
     * @format uuid
     */
    productId: string;
    /**
     * @format uuid
     */
    constraintId: string;
  };

export type DeleteCdrSellersSellerIdProductsProductIdProductConstraintConstraintIdError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type DeleteCdrSellersSellerIdProductsProductIdProductConstraintConstraintIdVariables =
  {
    pathParams: DeleteCdrSellersSellerIdProductsProductIdProductConstraintConstraintIdPathParams;
  } & HyperionContext["fetcherOptions"];

export const fetchDeleteCdrSellersSellerIdProductsProductIdProductConstraintConstraintId =
  (
    variables: DeleteCdrSellersSellerIdProductsProductIdProductConstraintConstraintIdVariables,
    signal?: AbortSignal,
  ) =>
    hyperionFetch<
      undefined,
      DeleteCdrSellersSellerIdProductsProductIdProductConstraintConstraintIdError,
      undefined,
      {},
      {},
      DeleteCdrSellersSellerIdProductsProductIdProductConstraintConstraintIdPathParams
    >({
      url: "/cdr/sellers/{sellerId}/products/{productId}/product_constraint/{constraintId}",
      method: "delete",
      ...variables,
      signal,
    });

export const useDeleteCdrSellersSellerIdProductsProductIdProductConstraintConstraintId =
  (
    options?: Omit<
      reactQuery.UseMutationOptions<
        undefined,
        DeleteCdrSellersSellerIdProductsProductIdProductConstraintConstraintIdError,
        DeleteCdrSellersSellerIdProductsProductIdProductConstraintConstraintIdVariables
      >,
      "mutationFn"
    >,
  ) => {
    const { fetcherOptions } = useHyperionContext();
    return reactQuery.useMutation<
      undefined,
      DeleteCdrSellersSellerIdProductsProductIdProductConstraintConstraintIdError,
      DeleteCdrSellersSellerIdProductsProductIdProductConstraintConstraintIdVariables
    >({
      mutationFn: (
        variables: DeleteCdrSellersSellerIdProductsProductIdProductConstraintConstraintIdVariables,
      ) =>
        fetchDeleteCdrSellersSellerIdProductsProductIdProductConstraintConstraintId(
          { ...fetcherOptions, ...variables },
        ),
      ...options,
    });
  };

export type PatchCdrSellersSellerIdProductsProductIdPathParams = {
  /**
   * @format uuid
   */
  sellerId: string;
  /**
   * @format uuid
   */
  productId: string;
};

export type PatchCdrSellersSellerIdProductsProductIdError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type PatchCdrSellersSellerIdProductsProductIdVariables = {
  body?: Schemas.AppModulesCdrSchemasCdrProductEdit;
  pathParams: PatchCdrSellersSellerIdProductsProductIdPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchPatchCdrSellersSellerIdProductsProductId = (
  variables: PatchCdrSellersSellerIdProductsProductIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchCdrSellersSellerIdProductsProductIdError,
    Schemas.AppModulesCdrSchemasCdrProductEdit,
    {},
    {},
    PatchCdrSellersSellerIdProductsProductIdPathParams
  >({
    url: "/cdr/sellers/{sellerId}/products/{productId}/",
    method: "patch",
    ...variables,
    signal,
  });

export const usePatchCdrSellersSellerIdProductsProductId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchCdrSellersSellerIdProductsProductIdError,
      PatchCdrSellersSellerIdProductsProductIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchCdrSellersSellerIdProductsProductIdError,
    PatchCdrSellersSellerIdProductsProductIdVariables
  >({
    mutationFn: (
      variables: PatchCdrSellersSellerIdProductsProductIdVariables,
    ) =>
      fetchPatchCdrSellersSellerIdProductsProductId({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type DeleteCdrSellersSellerIdProductsProductIdPathParams = {
  /**
   * @format uuid
   */
  sellerId: string;
  /**
   * @format uuid
   */
  productId: string;
};

export type DeleteCdrSellersSellerIdProductsProductIdError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type DeleteCdrSellersSellerIdProductsProductIdVariables = {
  pathParams: DeleteCdrSellersSellerIdProductsProductIdPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchDeleteCdrSellersSellerIdProductsProductId = (
  variables: DeleteCdrSellersSellerIdProductsProductIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteCdrSellersSellerIdProductsProductIdError,
    undefined,
    {},
    {},
    DeleteCdrSellersSellerIdProductsProductIdPathParams
  >({
    url: "/cdr/sellers/{sellerId}/products/{productId}/",
    method: "delete",
    ...variables,
    signal,
  });

export const useDeleteCdrSellersSellerIdProductsProductId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteCdrSellersSellerIdProductsProductIdError,
      DeleteCdrSellersSellerIdProductsProductIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteCdrSellersSellerIdProductsProductIdError,
    DeleteCdrSellersSellerIdProductsProductIdVariables
  >({
    mutationFn: (
      variables: DeleteCdrSellersSellerIdProductsProductIdVariables,
    ) =>
      fetchDeleteCdrSellersSellerIdProductsProductId({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type PostCdrSellersSellerIdProductsProductIdVariantsPathParams = {
  /**
   * @format uuid
   */
  sellerId: string;
  /**
   * @format uuid
   */
  productId: string;
};

export type PostCdrSellersSellerIdProductsProductIdVariantsError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type PostCdrSellersSellerIdProductsProductIdVariantsVariables = {
  body: Schemas.ProductVariantBase;
  pathParams: PostCdrSellersSellerIdProductsProductIdVariantsPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchPostCdrSellersSellerIdProductsProductIdVariants = (
  variables: PostCdrSellersSellerIdProductsProductIdVariantsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.ProductVariantComplete,
    PostCdrSellersSellerIdProductsProductIdVariantsError,
    Schemas.ProductVariantBase,
    {},
    {},
    PostCdrSellersSellerIdProductsProductIdVariantsPathParams
  >({
    url: "/cdr/sellers/{sellerId}/products/{productId}/variants/",
    method: "post",
    ...variables,
    signal,
  });

export const usePostCdrSellersSellerIdProductsProductIdVariants = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.ProductVariantComplete,
      PostCdrSellersSellerIdProductsProductIdVariantsError,
      PostCdrSellersSellerIdProductsProductIdVariantsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.ProductVariantComplete,
    PostCdrSellersSellerIdProductsProductIdVariantsError,
    PostCdrSellersSellerIdProductsProductIdVariantsVariables
  >({
    mutationFn: (
      variables: PostCdrSellersSellerIdProductsProductIdVariantsVariables,
    ) =>
      fetchPostCdrSellersSellerIdProductsProductIdVariants({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type PatchCdrSellersSellerIdProductsProductIdVariantsVariantIdPathParams =
  {
    /**
     * @format uuid
     */
    sellerId: string;
    /**
     * @format uuid
     */
    productId: string;
    /**
     * @format uuid
     */
    variantId: string;
  };

export type PatchCdrSellersSellerIdProductsProductIdVariantsVariantIdError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type PatchCdrSellersSellerIdProductsProductIdVariantsVariantIdVariables =
  {
    body?: Schemas.ProductVariantEdit;
    pathParams: PatchCdrSellersSellerIdProductsProductIdVariantsVariantIdPathParams;
  } & HyperionContext["fetcherOptions"];

export const fetchPatchCdrSellersSellerIdProductsProductIdVariantsVariantId = (
  variables: PatchCdrSellersSellerIdProductsProductIdVariantsVariantIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchCdrSellersSellerIdProductsProductIdVariantsVariantIdError,
    Schemas.ProductVariantEdit,
    {},
    {},
    PatchCdrSellersSellerIdProductsProductIdVariantsVariantIdPathParams
  >({
    url: "/cdr/sellers/{sellerId}/products/{productId}/variants/{variantId}/",
    method: "patch",
    ...variables,
    signal,
  });

export const usePatchCdrSellersSellerIdProductsProductIdVariantsVariantId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchCdrSellersSellerIdProductsProductIdVariantsVariantIdError,
      PatchCdrSellersSellerIdProductsProductIdVariantsVariantIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchCdrSellersSellerIdProductsProductIdVariantsVariantIdError,
    PatchCdrSellersSellerIdProductsProductIdVariantsVariantIdVariables
  >({
    mutationFn: (
      variables: PatchCdrSellersSellerIdProductsProductIdVariantsVariantIdVariables,
    ) =>
      fetchPatchCdrSellersSellerIdProductsProductIdVariantsVariantId({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type DeleteCdrSellersSellerIdProductsProductIdVariantsVariantIdPathParams =
  {
    /**
     * @format uuid
     */
    sellerId: string;
    /**
     * @format uuid
     */
    productId: string;
    /**
     * @format uuid
     */
    variantId: string;
  };

export type DeleteCdrSellersSellerIdProductsProductIdVariantsVariantIdError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type DeleteCdrSellersSellerIdProductsProductIdVariantsVariantIdVariables =
  {
    pathParams: DeleteCdrSellersSellerIdProductsProductIdVariantsVariantIdPathParams;
  } & HyperionContext["fetcherOptions"];

export const fetchDeleteCdrSellersSellerIdProductsProductIdVariantsVariantId = (
  variables: DeleteCdrSellersSellerIdProductsProductIdVariantsVariantIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteCdrSellersSellerIdProductsProductIdVariantsVariantIdError,
    undefined,
    {},
    {},
    DeleteCdrSellersSellerIdProductsProductIdVariantsVariantIdPathParams
  >({
    url: "/cdr/sellers/{sellerId}/products/{productId}/variants/{variantId}/",
    method: "delete",
    ...variables,
    signal,
  });

export const useDeleteCdrSellersSellerIdProductsProductIdVariantsVariantId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteCdrSellersSellerIdProductsProductIdVariantsVariantIdError,
      DeleteCdrSellersSellerIdProductsProductIdVariantsVariantIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteCdrSellersSellerIdProductsProductIdVariantsVariantIdError,
    DeleteCdrSellersSellerIdProductsProductIdVariantsVariantIdVariables
  >({
    mutationFn: (
      variables: DeleteCdrSellersSellerIdProductsProductIdVariantsVariantIdVariables,
    ) =>
      fetchDeleteCdrSellersSellerIdProductsProductIdVariantsVariantId({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type PostCdrProductsProductIdVariantsVariantIdCurriculumCurriculumIdPathParams =
  {
    /**
     * @format uuid
     */
    productId: string;
    /**
     * @format uuid
     */
    variantId: string;
    /**
     * @format uuid
     */
    curriculumId: string;
  };

export type PostCdrProductsProductIdVariantsVariantIdCurriculumCurriculumIdQueryParams =
  {
    /**
     * @format uuid
     */
    seller_id: string;
  };

export type PostCdrProductsProductIdVariantsVariantIdCurriculumCurriculumIdError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type PostCdrProductsProductIdVariantsVariantIdCurriculumCurriculumIdVariables =
  {
    pathParams: PostCdrProductsProductIdVariantsVariantIdCurriculumCurriculumIdPathParams;
    queryParams: PostCdrProductsProductIdVariantsVariantIdCurriculumCurriculumIdQueryParams;
  } & HyperionContext["fetcherOptions"];

export const fetchPostCdrProductsProductIdVariantsVariantIdCurriculumCurriculumId =
  (
    variables: PostCdrProductsProductIdVariantsVariantIdCurriculumCurriculumIdVariables,
    signal?: AbortSignal,
  ) =>
    hyperionFetch<
      Schemas.ProductVariantComplete,
      PostCdrProductsProductIdVariantsVariantIdCurriculumCurriculumIdError,
      undefined,
      {},
      PostCdrProductsProductIdVariantsVariantIdCurriculumCurriculumIdQueryParams,
      PostCdrProductsProductIdVariantsVariantIdCurriculumCurriculumIdPathParams
    >({
      url: "/cdr/products/{productId}/variants/{variantId}/curriculum/{curriculumId}",
      method: "post",
      ...variables,
      signal,
    });

export const usePostCdrProductsProductIdVariantsVariantIdCurriculumCurriculumId =
  (
    options?: Omit<
      reactQuery.UseMutationOptions<
        Schemas.ProductVariantComplete,
        PostCdrProductsProductIdVariantsVariantIdCurriculumCurriculumIdError,
        PostCdrProductsProductIdVariantsVariantIdCurriculumCurriculumIdVariables
      >,
      "mutationFn"
    >,
  ) => {
    const { fetcherOptions } = useHyperionContext();
    return reactQuery.useMutation<
      Schemas.ProductVariantComplete,
      PostCdrProductsProductIdVariantsVariantIdCurriculumCurriculumIdError,
      PostCdrProductsProductIdVariantsVariantIdCurriculumCurriculumIdVariables
    >({
      mutationFn: (
        variables: PostCdrProductsProductIdVariantsVariantIdCurriculumCurriculumIdVariables,
      ) =>
        fetchPostCdrProductsProductIdVariantsVariantIdCurriculumCurriculumId({
          ...fetcherOptions,
          ...variables,
        }),
      ...options,
    });
  };

export type DeleteCdrSellersSellerIdProductsProductIdVariantsVariantIdCurriculumCurriculumIdPathParams =
  {
    /**
     * @format uuid
     */
    sellerId: string;
    /**
     * @format uuid
     */
    productId: string;
    /**
     * @format uuid
     */
    variantId: string;
    /**
     * @format uuid
     */
    curriculumId: string;
  };

export type DeleteCdrSellersSellerIdProductsProductIdVariantsVariantIdCurriculumCurriculumIdError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type DeleteCdrSellersSellerIdProductsProductIdVariantsVariantIdCurriculumCurriculumIdVariables =
  {
    pathParams: DeleteCdrSellersSellerIdProductsProductIdVariantsVariantIdCurriculumCurriculumIdPathParams;
  } & HyperionContext["fetcherOptions"];

export const fetchDeleteCdrSellersSellerIdProductsProductIdVariantsVariantIdCurriculumCurriculumId =
  (
    variables: DeleteCdrSellersSellerIdProductsProductIdVariantsVariantIdCurriculumCurriculumIdVariables,
    signal?: AbortSignal,
  ) =>
    hyperionFetch<
      undefined,
      DeleteCdrSellersSellerIdProductsProductIdVariantsVariantIdCurriculumCurriculumIdError,
      undefined,
      {},
      {},
      DeleteCdrSellersSellerIdProductsProductIdVariantsVariantIdCurriculumCurriculumIdPathParams
    >({
      url: "/cdr/sellers/{sellerId}//products/{productId}/variants/{variantId}/curriculum/{curriculumId}",
      method: "delete",
      ...variables,
      signal,
    });

export const useDeleteCdrSellersSellerIdProductsProductIdVariantsVariantIdCurriculumCurriculumId =
  (
    options?: Omit<
      reactQuery.UseMutationOptions<
        undefined,
        DeleteCdrSellersSellerIdProductsProductIdVariantsVariantIdCurriculumCurriculumIdError,
        DeleteCdrSellersSellerIdProductsProductIdVariantsVariantIdCurriculumCurriculumIdVariables
      >,
      "mutationFn"
    >,
  ) => {
    const { fetcherOptions } = useHyperionContext();
    return reactQuery.useMutation<
      undefined,
      DeleteCdrSellersSellerIdProductsProductIdVariantsVariantIdCurriculumCurriculumIdError,
      DeleteCdrSellersSellerIdProductsProductIdVariantsVariantIdCurriculumCurriculumIdVariables
    >({
      mutationFn: (
        variables: DeleteCdrSellersSellerIdProductsProductIdVariantsVariantIdCurriculumCurriculumIdVariables,
      ) =>
        fetchDeleteCdrSellersSellerIdProductsProductIdVariantsVariantIdCurriculumCurriculumId(
          { ...fetcherOptions, ...variables },
        ),
      ...options,
    });
  };

export type GetCdrSellersSellerIdDocumentsPathParams = {
  /**
   * @format uuid
   */
  sellerId: string;
};

export type GetCdrSellersSellerIdDocumentsError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetCdrSellersSellerIdDocumentsResponse = Schemas.DocumentComplete[];

export type GetCdrSellersSellerIdDocumentsVariables = {
  pathParams: GetCdrSellersSellerIdDocumentsPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchGetCdrSellersSellerIdDocuments = (
  variables: GetCdrSellersSellerIdDocumentsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetCdrSellersSellerIdDocumentsResponse,
    GetCdrSellersSellerIdDocumentsError,
    undefined,
    {},
    {},
    GetCdrSellersSellerIdDocumentsPathParams
  >({
    url: "/cdr/sellers/{sellerId}/documents/",
    method: "get",
    ...variables,
    signal,
  });

export const useGetCdrSellersSellerIdDocuments = <
  TData = GetCdrSellersSellerIdDocumentsResponse,
>(
  variables: GetCdrSellersSellerIdDocumentsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCdrSellersSellerIdDocumentsResponse,
      GetCdrSellersSellerIdDocumentsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<
    GetCdrSellersSellerIdDocumentsResponse,
    GetCdrSellersSellerIdDocumentsError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/cdr/sellers/{sellerId}/documents/",
      operationId: "getCdrSellersSellerIdDocuments",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetCdrSellersSellerIdDocuments(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type PostCdrSellersSellerIdDocumentsPathParams = {
  /**
   * @format uuid
   */
  sellerId: string;
};

export type PostCdrSellersSellerIdDocumentsError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostCdrSellersSellerIdDocumentsVariables = {
  body: Schemas.DocumentBase;
  pathParams: PostCdrSellersSellerIdDocumentsPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchPostCdrSellersSellerIdDocuments = (
  variables: PostCdrSellersSellerIdDocumentsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.DocumentComplete,
    PostCdrSellersSellerIdDocumentsError,
    Schemas.DocumentBase,
    {},
    {},
    PostCdrSellersSellerIdDocumentsPathParams
  >({
    url: "/cdr/sellers/{sellerId}/documents/",
    method: "post",
    ...variables,
    signal,
  });

export const usePostCdrSellersSellerIdDocuments = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.DocumentComplete,
      PostCdrSellersSellerIdDocumentsError,
      PostCdrSellersSellerIdDocumentsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.DocumentComplete,
    PostCdrSellersSellerIdDocumentsError,
    PostCdrSellersSellerIdDocumentsVariables
  >({
    mutationFn: (variables: PostCdrSellersSellerIdDocumentsVariables) =>
      fetchPostCdrSellersSellerIdDocuments({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type DeleteCdrSellersSellerIdDocumentsDocumentIdPathParams = {
  /**
   * @format uuid
   */
  sellerId: string;
  /**
   * @format uuid
   */
  documentId: string;
};

export type DeleteCdrSellersSellerIdDocumentsDocumentIdError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type DeleteCdrSellersSellerIdDocumentsDocumentIdVariables = {
  pathParams: DeleteCdrSellersSellerIdDocumentsDocumentIdPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchDeleteCdrSellersSellerIdDocumentsDocumentId = (
  variables: DeleteCdrSellersSellerIdDocumentsDocumentIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteCdrSellersSellerIdDocumentsDocumentIdError,
    undefined,
    {},
    {},
    DeleteCdrSellersSellerIdDocumentsDocumentIdPathParams
  >({
    url: "/cdr/sellers/{sellerId}/documents/{documentId}/",
    method: "delete",
    ...variables,
    signal,
  });

export const useDeleteCdrSellersSellerIdDocumentsDocumentId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteCdrSellersSellerIdDocumentsDocumentIdError,
      DeleteCdrSellersSellerIdDocumentsDocumentIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteCdrSellersSellerIdDocumentsDocumentIdError,
    DeleteCdrSellersSellerIdDocumentsDocumentIdVariables
  >({
    mutationFn: (
      variables: DeleteCdrSellersSellerIdDocumentsDocumentIdVariables,
    ) =>
      fetchDeleteCdrSellersSellerIdDocumentsDocumentId({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type GetCdrUsersUserIdPurchasesPathParams = {
  /**
   * @format uuid
   */
  userId: string;
};

export type GetCdrUsersUserIdPurchasesError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetCdrUsersUserIdPurchasesResponse = Schemas.PurchaseComplete[];

export type GetCdrUsersUserIdPurchasesVariables = {
  pathParams: GetCdrUsersUserIdPurchasesPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchGetCdrUsersUserIdPurchases = (
  variables: GetCdrUsersUserIdPurchasesVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetCdrUsersUserIdPurchasesResponse,
    GetCdrUsersUserIdPurchasesError,
    undefined,
    {},
    {},
    GetCdrUsersUserIdPurchasesPathParams
  >({
    url: "/cdr/users/{userId}/purchases/",
    method: "get",
    ...variables,
    signal,
  });

export const useGetCdrUsersUserIdPurchases = <
  TData = GetCdrUsersUserIdPurchasesResponse,
>(
  variables: GetCdrUsersUserIdPurchasesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCdrUsersUserIdPurchasesResponse,
      GetCdrUsersUserIdPurchasesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<
    GetCdrUsersUserIdPurchasesResponse,
    GetCdrUsersUserIdPurchasesError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/cdr/users/{userId}/purchases/",
      operationId: "getCdrUsersUserIdPurchases",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetCdrUsersUserIdPurchases(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type PostCdrUsersUserIdPurchasesProductVariantIdPathParams = {
  /**
   * @format uuid
   */
  userId: string;
  /**
   * @format uuid
   */
  productVariantId: string;
};

export type PostCdrUsersUserIdPurchasesProductVariantIdError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type PostCdrUsersUserIdPurchasesProductVariantIdVariables = {
  body: Schemas.PurchaseBase;
  pathParams: PostCdrUsersUserIdPurchasesProductVariantIdPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchPostCdrUsersUserIdPurchasesProductVariantId = (
  variables: PostCdrUsersUserIdPurchasesProductVariantIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.PurchaseComplete,
    PostCdrUsersUserIdPurchasesProductVariantIdError,
    Schemas.PurchaseBase,
    {},
    {},
    PostCdrUsersUserIdPurchasesProductVariantIdPathParams
  >({
    url: "/cdr/users/{userId}/purchases/{productVariantId}",
    method: "post",
    ...variables,
    signal,
  });

export const usePostCdrUsersUserIdPurchasesProductVariantId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.PurchaseComplete,
      PostCdrUsersUserIdPurchasesProductVariantIdError,
      PostCdrUsersUserIdPurchasesProductVariantIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.PurchaseComplete,
    PostCdrUsersUserIdPurchasesProductVariantIdError,
    PostCdrUsersUserIdPurchasesProductVariantIdVariables
  >({
    mutationFn: (
      variables: PostCdrUsersUserIdPurchasesProductVariantIdVariables,
    ) =>
      fetchPostCdrUsersUserIdPurchasesProductVariantId({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type PatchCdrUsersUserIdPurchasesProductVariantIdPathParams = {
  /**
   * @format uuid
   */
  userId: string;
  /**
   * @format uuid
   */
  productVariantId: string;
};

export type PatchCdrUsersUserIdPurchasesProductVariantIdError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type PatchCdrUsersUserIdPurchasesProductVariantIdVariables = {
  body?: Schemas.PurchaseEdit;
  pathParams: PatchCdrUsersUserIdPurchasesProductVariantIdPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchPatchCdrUsersUserIdPurchasesProductVariantId = (
  variables: PatchCdrUsersUserIdPurchasesProductVariantIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchCdrUsersUserIdPurchasesProductVariantIdError,
    Schemas.PurchaseEdit,
    {},
    {},
    PatchCdrUsersUserIdPurchasesProductVariantIdPathParams
  >({
    url: "/cdr/users/{userId}/purchases/{productVariantId}/",
    method: "patch",
    ...variables,
    signal,
  });

export const usePatchCdrUsersUserIdPurchasesProductVariantId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchCdrUsersUserIdPurchasesProductVariantIdError,
      PatchCdrUsersUserIdPurchasesProductVariantIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchCdrUsersUserIdPurchasesProductVariantIdError,
    PatchCdrUsersUserIdPurchasesProductVariantIdVariables
  >({
    mutationFn: (
      variables: PatchCdrUsersUserIdPurchasesProductVariantIdVariables,
    ) =>
      fetchPatchCdrUsersUserIdPurchasesProductVariantId({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type DeleteCdrUsersUserIdPurchasesProductVariantIdPathParams = {
  /**
   * @format uuid
   */
  userId: string;
  /**
   * @format uuid
   */
  productVariantId: string;
};

export type DeleteCdrUsersUserIdPurchasesProductVariantIdError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type DeleteCdrUsersUserIdPurchasesProductVariantIdVariables = {
  pathParams: DeleteCdrUsersUserIdPurchasesProductVariantIdPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchDeleteCdrUsersUserIdPurchasesProductVariantId = (
  variables: DeleteCdrUsersUserIdPurchasesProductVariantIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteCdrUsersUserIdPurchasesProductVariantIdError,
    undefined,
    {},
    {},
    DeleteCdrUsersUserIdPurchasesProductVariantIdPathParams
  >({
    url: "/cdr/users/{userId}/purchases/{productVariantId}/",
    method: "delete",
    ...variables,
    signal,
  });

export const useDeleteCdrUsersUserIdPurchasesProductVariantId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteCdrUsersUserIdPurchasesProductVariantIdError,
      DeleteCdrUsersUserIdPurchasesProductVariantIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteCdrUsersUserIdPurchasesProductVariantIdError,
    DeleteCdrUsersUserIdPurchasesProductVariantIdVariables
  >({
    mutationFn: (
      variables: DeleteCdrUsersUserIdPurchasesProductVariantIdVariables,
    ) =>
      fetchDeleteCdrUsersUserIdPurchasesProductVariantId({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type PatchCdrUsersUserIdPurchasesProductVariantIdPaidPathParams = {
  /**
   * @format uuid
   */
  userId: string;
  /**
   * @format uuid
   */
  productVariantId: string;
};

export type PatchCdrUsersUserIdPurchasesProductVariantIdPaidQueryParams = {
  paid: boolean;
};

export type PatchCdrUsersUserIdPurchasesProductVariantIdPaidError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type PatchCdrUsersUserIdPurchasesProductVariantIdPaidVariables = {
  pathParams: PatchCdrUsersUserIdPurchasesProductVariantIdPaidPathParams;
  queryParams: PatchCdrUsersUserIdPurchasesProductVariantIdPaidQueryParams;
} & HyperionContext["fetcherOptions"];

export const fetchPatchCdrUsersUserIdPurchasesProductVariantIdPaid = (
  variables: PatchCdrUsersUserIdPurchasesProductVariantIdPaidVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchCdrUsersUserIdPurchasesProductVariantIdPaidError,
    undefined,
    {},
    PatchCdrUsersUserIdPurchasesProductVariantIdPaidQueryParams,
    PatchCdrUsersUserIdPurchasesProductVariantIdPaidPathParams
  >({
    url: "/cdr/users/{userId}/purchases/{productVariantId}/paid/",
    method: "patch",
    ...variables,
    signal,
  });

export const usePatchCdrUsersUserIdPurchasesProductVariantIdPaid = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchCdrUsersUserIdPurchasesProductVariantIdPaidError,
      PatchCdrUsersUserIdPurchasesProductVariantIdPaidVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchCdrUsersUserIdPurchasesProductVariantIdPaidError,
    PatchCdrUsersUserIdPurchasesProductVariantIdPaidVariables
  >({
    mutationFn: (
      variables: PatchCdrUsersUserIdPurchasesProductVariantIdPaidVariables,
    ) =>
      fetchPatchCdrUsersUserIdPurchasesProductVariantIdPaid({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type GetCdrUsersUserIdSignaturesPathParams = {
  /**
   * @format uuid
   */
  userId: string;
};

export type GetCdrUsersUserIdSignaturesError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetCdrUsersUserIdSignaturesResponse = Schemas.SignatureComplete[];

export type GetCdrUsersUserIdSignaturesVariables = {
  pathParams: GetCdrUsersUserIdSignaturesPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchGetCdrUsersUserIdSignatures = (
  variables: GetCdrUsersUserIdSignaturesVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetCdrUsersUserIdSignaturesResponse,
    GetCdrUsersUserIdSignaturesError,
    undefined,
    {},
    {},
    GetCdrUsersUserIdSignaturesPathParams
  >({
    url: "/cdr/users/{userId}/signatures/",
    method: "get",
    ...variables,
    signal,
  });

export const useGetCdrUsersUserIdSignatures = <
  TData = GetCdrUsersUserIdSignaturesResponse,
>(
  variables: GetCdrUsersUserIdSignaturesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCdrUsersUserIdSignaturesResponse,
      GetCdrUsersUserIdSignaturesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<
    GetCdrUsersUserIdSignaturesResponse,
    GetCdrUsersUserIdSignaturesError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/cdr/users/{userId}/signatures/",
      operationId: "getCdrUsersUserIdSignatures",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetCdrUsersUserIdSignatures(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type PostCdrUsersUserIdSignaturesDocumentIdPathParams = {
  /**
   * @format uuid
   */
  userId: string;
  /**
   * @format uuid
   */
  documentId: string;
};

export type PostCdrUsersUserIdSignaturesDocumentIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostCdrUsersUserIdSignaturesDocumentIdVariables = {
  body: Schemas.SignatureBase;
  pathParams: PostCdrUsersUserIdSignaturesDocumentIdPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchPostCdrUsersUserIdSignaturesDocumentId = (
  variables: PostCdrUsersUserIdSignaturesDocumentIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.SignatureComplete,
    PostCdrUsersUserIdSignaturesDocumentIdError,
    Schemas.SignatureBase,
    {},
    {},
    PostCdrUsersUserIdSignaturesDocumentIdPathParams
  >({
    url: "/cdr/users/{userId}/signatures/{documentId}",
    method: "post",
    ...variables,
    signal,
  });

export const usePostCdrUsersUserIdSignaturesDocumentId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.SignatureComplete,
      PostCdrUsersUserIdSignaturesDocumentIdError,
      PostCdrUsersUserIdSignaturesDocumentIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.SignatureComplete,
    PostCdrUsersUserIdSignaturesDocumentIdError,
    PostCdrUsersUserIdSignaturesDocumentIdVariables
  >({
    mutationFn: (variables: PostCdrUsersUserIdSignaturesDocumentIdVariables) =>
      fetchPostCdrUsersUserIdSignaturesDocumentId({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type DeleteCdrUsersUserIdSignaturesDocumentIdPathParams = {
  /**
   * @format uuid
   */
  userId: string;
  /**
   * @format uuid
   */
  documentId: string;
};

export type DeleteCdrUsersUserIdSignaturesDocumentIdError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type DeleteCdrUsersUserIdSignaturesDocumentIdVariables = {
  pathParams: DeleteCdrUsersUserIdSignaturesDocumentIdPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchDeleteCdrUsersUserIdSignaturesDocumentId = (
  variables: DeleteCdrUsersUserIdSignaturesDocumentIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteCdrUsersUserIdSignaturesDocumentIdError,
    undefined,
    {},
    {},
    DeleteCdrUsersUserIdSignaturesDocumentIdPathParams
  >({
    url: "/cdr/users/{userId}/signatures/{documentId}/",
    method: "delete",
    ...variables,
    signal,
  });

export const useDeleteCdrUsersUserIdSignaturesDocumentId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteCdrUsersUserIdSignaturesDocumentIdError,
      DeleteCdrUsersUserIdSignaturesDocumentIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteCdrUsersUserIdSignaturesDocumentIdError,
    DeleteCdrUsersUserIdSignaturesDocumentIdVariables
  >({
    mutationFn: (
      variables: DeleteCdrUsersUserIdSignaturesDocumentIdVariables,
    ) =>
      fetchDeleteCdrUsersUserIdSignaturesDocumentId({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type GetCdrCurriculumsError = Fetcher.ErrorWrapper<undefined>;

export type GetCdrCurriculumsResponse = Schemas.CurriculumComplete[];

export type GetCdrCurriculumsVariables = HyperionContext["fetcherOptions"];

export const fetchGetCdrCurriculums = (
  variables: GetCdrCurriculumsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetCdrCurriculumsResponse,
    GetCdrCurriculumsError,
    undefined,
    {},
    {},
    {}
  >({ url: "/cdr/curriculums/", method: "get", ...variables, signal });

export const useGetCdrCurriculums = <TData = GetCdrCurriculumsResponse,>(
  variables: GetCdrCurriculumsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCdrCurriculumsResponse,
      GetCdrCurriculumsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<
    GetCdrCurriculumsResponse,
    GetCdrCurriculumsError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/cdr/curriculums/",
      operationId: "getCdrCurriculums",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetCdrCurriculums({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type PostCdrCurriculumsError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostCdrCurriculumsVariables = {
  body: Schemas.CurriculumBase;
} & HyperionContext["fetcherOptions"];

export const fetchPostCdrCurriculums = (
  variables: PostCdrCurriculumsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.CurriculumComplete,
    PostCdrCurriculumsError,
    Schemas.CurriculumBase,
    {},
    {},
    {}
  >({ url: "/cdr/curriculums/", method: "post", ...variables, signal });

export const usePostCdrCurriculums = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.CurriculumComplete,
      PostCdrCurriculumsError,
      PostCdrCurriculumsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.CurriculumComplete,
    PostCdrCurriculumsError,
    PostCdrCurriculumsVariables
  >({
    mutationFn: (variables: PostCdrCurriculumsVariables) =>
      fetchPostCdrCurriculums({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type DeleteCdrCurriculumsCurriculumIdPathParams = {
  /**
   * @format uuid
   */
  curriculumId: string;
};

export type DeleteCdrCurriculumsCurriculumIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type DeleteCdrCurriculumsCurriculumIdVariables = {
  pathParams: DeleteCdrCurriculumsCurriculumIdPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchDeleteCdrCurriculumsCurriculumId = (
  variables: DeleteCdrCurriculumsCurriculumIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteCdrCurriculumsCurriculumIdError,
    undefined,
    {},
    {},
    DeleteCdrCurriculumsCurriculumIdPathParams
  >({
    url: "/cdr/curriculums/{curriculumId}/",
    method: "delete",
    ...variables,
    signal,
  });

export const useDeleteCdrCurriculumsCurriculumId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteCdrCurriculumsCurriculumIdError,
      DeleteCdrCurriculumsCurriculumIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteCdrCurriculumsCurriculumIdError,
    DeleteCdrCurriculumsCurriculumIdVariables
  >({
    mutationFn: (variables: DeleteCdrCurriculumsCurriculumIdVariables) =>
      fetchDeleteCdrCurriculumsCurriculumId({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type DeleteCdrUsersUserIdCurriculumsCurriculumIdPathParams = {
  /**
   * @format uuid
   */
  userId: string;
  /**
   * @format uuid
   */
  curriculumId: string;
};

export type DeleteCdrUsersUserIdCurriculumsCurriculumIdError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type DeleteCdrUsersUserIdCurriculumsCurriculumIdVariables = {
  pathParams: DeleteCdrUsersUserIdCurriculumsCurriculumIdPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchDeleteCdrUsersUserIdCurriculumsCurriculumId = (
  variables: DeleteCdrUsersUserIdCurriculumsCurriculumIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteCdrUsersUserIdCurriculumsCurriculumIdError,
    undefined,
    {},
    {},
    DeleteCdrUsersUserIdCurriculumsCurriculumIdPathParams
  >({
    url: "/cdr/users/{userId}/curriculums/{curriculumId}/",
    method: "delete",
    ...variables,
    signal,
  });

export const useDeleteCdrUsersUserIdCurriculumsCurriculumId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteCdrUsersUserIdCurriculumsCurriculumIdError,
      DeleteCdrUsersUserIdCurriculumsCurriculumIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteCdrUsersUserIdCurriculumsCurriculumIdError,
    DeleteCdrUsersUserIdCurriculumsCurriculumIdVariables
  >({
    mutationFn: (
      variables: DeleteCdrUsersUserIdCurriculumsCurriculumIdVariables,
    ) =>
      fetchDeleteCdrUsersUserIdCurriculumsCurriculumId({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type GetCdrUsersUserIdPaymentsPathParams = {
  /**
   * @format uuid
   */
  userId: string;
};

export type GetCdrUsersUserIdPaymentsError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetCdrUsersUserIdPaymentsResponse = Schemas.PaymentComplete[];

export type GetCdrUsersUserIdPaymentsVariables = {
  pathParams: GetCdrUsersUserIdPaymentsPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchGetCdrUsersUserIdPayments = (
  variables: GetCdrUsersUserIdPaymentsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetCdrUsersUserIdPaymentsResponse,
    GetCdrUsersUserIdPaymentsError,
    undefined,
    {},
    {},
    GetCdrUsersUserIdPaymentsPathParams
  >({
    url: "/cdr/users/{userId}/payments/",
    method: "get",
    ...variables,
    signal,
  });

export const useGetCdrUsersUserIdPayments = <
  TData = GetCdrUsersUserIdPaymentsResponse,
>(
  variables: GetCdrUsersUserIdPaymentsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCdrUsersUserIdPaymentsResponse,
      GetCdrUsersUserIdPaymentsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<
    GetCdrUsersUserIdPaymentsResponse,
    GetCdrUsersUserIdPaymentsError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/cdr/users/{userId}/payments/",
      operationId: "getCdrUsersUserIdPayments",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetCdrUsersUserIdPayments(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type PostCdrPaymentsError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostCdrPaymentsVariables = {
  body: Schemas.PaymentBase;
} & HyperionContext["fetcherOptions"];

export const fetchPostCdrPayments = (
  variables: PostCdrPaymentsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.PaymentComplete,
    PostCdrPaymentsError,
    Schemas.PaymentBase,
    {},
    {},
    {}
  >({ url: "/cdr/payments/", method: "post", ...variables, signal });

export const usePostCdrPayments = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.PaymentComplete,
      PostCdrPaymentsError,
      PostCdrPaymentsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.PaymentComplete,
    PostCdrPaymentsError,
    PostCdrPaymentsVariables
  >({
    mutationFn: (variables: PostCdrPaymentsVariables) =>
      fetchPostCdrPayments({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type DeleteCdrPaymentsPaymentIdPathParams = {
  /**
   * @format uuid
   */
  paymentId: string;
};

export type DeleteCdrPaymentsPaymentIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type DeleteCdrPaymentsPaymentIdVariables = {
  pathParams: DeleteCdrPaymentsPaymentIdPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchDeleteCdrPaymentsPaymentId = (
  variables: DeleteCdrPaymentsPaymentIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteCdrPaymentsPaymentIdError,
    undefined,
    {},
    {},
    DeleteCdrPaymentsPaymentIdPathParams
  >({
    url: "/cdr/payments/{paymentId}/",
    method: "delete",
    ...variables,
    signal,
  });

export const useDeleteCdrPaymentsPaymentId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteCdrPaymentsPaymentIdError,
      DeleteCdrPaymentsPaymentIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteCdrPaymentsPaymentIdError,
    DeleteCdrPaymentsPaymentIdVariables
  >({
    mutationFn: (variables: DeleteCdrPaymentsPaymentIdVariables) =>
      fetchDeleteCdrPaymentsPaymentId({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetCdrUsersUserIdMembershipsPathParams = {
  /**
   * @format uuid
   */
  userId: string;
};

export type GetCdrUsersUserIdMembershipsError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetCdrUsersUserIdMembershipsResponse =
  Schemas.AppModulesCdrSchemasCdrMembershipComplete[];

export type GetCdrUsersUserIdMembershipsVariables = {
  pathParams: GetCdrUsersUserIdMembershipsPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchGetCdrUsersUserIdMemberships = (
  variables: GetCdrUsersUserIdMembershipsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetCdrUsersUserIdMembershipsResponse,
    GetCdrUsersUserIdMembershipsError,
    undefined,
    {},
    {},
    GetCdrUsersUserIdMembershipsPathParams
  >({
    url: "/cdr/users/{userId}/memberships/",
    method: "get",
    ...variables,
    signal,
  });

export const useGetCdrUsersUserIdMemberships = <
  TData = GetCdrUsersUserIdMembershipsResponse,
>(
  variables: GetCdrUsersUserIdMembershipsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCdrUsersUserIdMembershipsResponse,
      GetCdrUsersUserIdMembershipsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<
    GetCdrUsersUserIdMembershipsResponse,
    GetCdrUsersUserIdMembershipsError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/cdr/users/{userId}/memberships/",
      operationId: "getCdrUsersUserIdMemberships",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetCdrUsersUserIdMemberships(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type PostCdrMembershipsError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostCdrMembershipsVariables = {
  body: Schemas.AppModulesCdrSchemasCdrMembershipBase;
} & HyperionContext["fetcherOptions"];

export const fetchPostCdrMemberships = (
  variables: PostCdrMembershipsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.AppModulesCdrSchemasCdrMembershipComplete,
    PostCdrMembershipsError,
    Schemas.AppModulesCdrSchemasCdrMembershipBase,
    {},
    {},
    {}
  >({ url: "/cdr/memberships/", method: "post", ...variables, signal });

export const usePostCdrMemberships = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.AppModulesCdrSchemasCdrMembershipComplete,
      PostCdrMembershipsError,
      PostCdrMembershipsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.AppModulesCdrSchemasCdrMembershipComplete,
    PostCdrMembershipsError,
    PostCdrMembershipsVariables
  >({
    mutationFn: (variables: PostCdrMembershipsVariables) =>
      fetchPostCdrMemberships({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type DeleteCdrMembershipsMembershipIdPathParams = {
  /**
   * @format uuid
   */
  membershipId: string;
};

export type DeleteCdrMembershipsMembershipIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type DeleteCdrMembershipsMembershipIdVariables = {
  pathParams: DeleteCdrMembershipsMembershipIdPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchDeleteCdrMembershipsMembershipId = (
  variables: DeleteCdrMembershipsMembershipIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteCdrMembershipsMembershipIdError,
    undefined,
    {},
    {},
    DeleteCdrMembershipsMembershipIdPathParams
  >({
    url: "/cdr/memberships/{membershipId}/",
    method: "delete",
    ...variables,
    signal,
  });

export const useDeleteCdrMembershipsMembershipId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteCdrMembershipsMembershipIdError,
      DeleteCdrMembershipsMembershipIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteCdrMembershipsMembershipIdError,
    DeleteCdrMembershipsMembershipIdVariables
  >({
    mutationFn: (variables: DeleteCdrMembershipsMembershipIdVariables) =>
      fetchDeleteCdrMembershipsMembershipId({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type GetCdrStatusError = Fetcher.ErrorWrapper<undefined>;

export type GetCdrStatusVariables = HyperionContext["fetcherOptions"];

export const fetchGetCdrStatus = (
  variables: GetCdrStatusVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<Schemas.Status, GetCdrStatusError, undefined, {}, {}, {}>({
    url: "/cdr/status/",
    method: "get",
    ...variables,
    signal,
  });

export const useGetCdrStatus = <TData = Schemas.Status,>(
  variables: GetCdrStatusVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.Status, GetCdrStatusError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<Schemas.Status, GetCdrStatusError, TData>({
    queryKey: queryKeyFn({
      path: "/cdr/status/",
      operationId: "getCdrStatus",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetCdrStatus({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type PatchCdrStatusError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PatchCdrStatusVariables = {
  body?: Schemas.Status;
} & HyperionContext["fetcherOptions"];

export const fetchPatchCdrStatus = (
  variables: PatchCdrStatusVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<undefined, PatchCdrStatusError, Schemas.Status, {}, {}, {}>({
    url: "/cdr/status/",
    method: "patch",
    ...variables,
    signal,
  });

export const usePatchCdrStatus = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchCdrStatusError,
      PatchCdrStatusVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchCdrStatusError,
    PatchCdrStatusVariables
  >({
    mutationFn: (variables: PatchCdrStatusVariables) =>
      fetchPatchCdrStatus({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetCinemaSessionsError = Fetcher.ErrorWrapper<undefined>;

export type GetCinemaSessionsResponse = Schemas.CineSessionComplete[];

export type GetCinemaSessionsVariables = HyperionContext["fetcherOptions"];

export const fetchGetCinemaSessions = (
  variables: GetCinemaSessionsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetCinemaSessionsResponse,
    GetCinemaSessionsError,
    undefined,
    {},
    {},
    {}
  >({ url: "/cinema/sessions", method: "get", ...variables, signal });

export const useGetCinemaSessions = <TData = GetCinemaSessionsResponse,>(
  variables: GetCinemaSessionsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCinemaSessionsResponse,
      GetCinemaSessionsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<
    GetCinemaSessionsResponse,
    GetCinemaSessionsError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/cinema/sessions",
      operationId: "getCinemaSessions",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetCinemaSessions({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type PostCinemaSessionsError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostCinemaSessionsVariables = {
  body: Schemas.CineSessionBase;
} & HyperionContext["fetcherOptions"];

export const fetchPostCinemaSessions = (
  variables: PostCinemaSessionsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.CineSessionComplete,
    PostCinemaSessionsError,
    Schemas.CineSessionBase,
    {},
    {},
    {}
  >({ url: "/cinema/sessions", method: "post", ...variables, signal });

export const usePostCinemaSessions = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.CineSessionComplete,
      PostCinemaSessionsError,
      PostCinemaSessionsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.CineSessionComplete,
    PostCinemaSessionsError,
    PostCinemaSessionsVariables
  >({
    mutationFn: (variables: PostCinemaSessionsVariables) =>
      fetchPostCinemaSessions({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type PatchCinemaSessionsSessionIdPathParams = {
  sessionId: string;
};

export type PatchCinemaSessionsSessionIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PatchCinemaSessionsSessionIdVariables = {
  body?: Schemas.CineSessionUpdate;
  pathParams: PatchCinemaSessionsSessionIdPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchPatchCinemaSessionsSessionId = (
  variables: PatchCinemaSessionsSessionIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    void,
    PatchCinemaSessionsSessionIdError,
    Schemas.CineSessionUpdate,
    {},
    {},
    PatchCinemaSessionsSessionIdPathParams
  >({
    url: "/cinema/sessions/{sessionId}",
    method: "patch",
    ...variables,
    signal,
  });

export const usePatchCinemaSessionsSessionId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      void,
      PatchCinemaSessionsSessionIdError,
      PatchCinemaSessionsSessionIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    void,
    PatchCinemaSessionsSessionIdError,
    PatchCinemaSessionsSessionIdVariables
  >({
    mutationFn: (variables: PatchCinemaSessionsSessionIdVariables) =>
      fetchPatchCinemaSessionsSessionId({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type DeleteCinemaSessionsSessionIdPathParams = {
  sessionId: string;
};

export type DeleteCinemaSessionsSessionIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type DeleteCinemaSessionsSessionIdVariables = {
  pathParams: DeleteCinemaSessionsSessionIdPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchDeleteCinemaSessionsSessionId = (
  variables: DeleteCinemaSessionsSessionIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteCinemaSessionsSessionIdError,
    undefined,
    {},
    {},
    DeleteCinemaSessionsSessionIdPathParams
  >({
    url: "/cinema/sessions/{sessionId}",
    method: "delete",
    ...variables,
    signal,
  });

export const useDeleteCinemaSessionsSessionId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteCinemaSessionsSessionIdError,
      DeleteCinemaSessionsSessionIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteCinemaSessionsSessionIdError,
    DeleteCinemaSessionsSessionIdVariables
  >({
    mutationFn: (variables: DeleteCinemaSessionsSessionIdVariables) =>
      fetchDeleteCinemaSessionsSessionId({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type PostCinemaSessionsSessionIdPosterPathParams = {
  sessionId: string;
};

export type PostCinemaSessionsSessionIdPosterError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostCinemaSessionsSessionIdPosterVariables = {
  body: Schemas.BodyCreateCampaignsLogoCinemaSessionsSessionIdPosterPost;
  pathParams: PostCinemaSessionsSessionIdPosterPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchPostCinemaSessionsSessionIdPoster = (
  variables: PostCinemaSessionsSessionIdPosterVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.AppCoreStandardResponsesResult,
    PostCinemaSessionsSessionIdPosterError,
    Schemas.BodyCreateCampaignsLogoCinemaSessionsSessionIdPosterPost,
    {},
    {},
    PostCinemaSessionsSessionIdPosterPathParams
  >({
    url: "/cinema/sessions/{sessionId}/poster",
    method: "post",
    ...variables,
    signal,
  });

export const usePostCinemaSessionsSessionIdPoster = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.AppCoreStandardResponsesResult,
      PostCinemaSessionsSessionIdPosterError,
      PostCinemaSessionsSessionIdPosterVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.AppCoreStandardResponsesResult,
    PostCinemaSessionsSessionIdPosterError,
    PostCinemaSessionsSessionIdPosterVariables
  >({
    mutationFn: (variables: PostCinemaSessionsSessionIdPosterVariables) =>
      fetchPostCinemaSessionsSessionIdPoster({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type GetCinemaSessionsSessionIdPosterPathParams = {
  sessionId: string;
};

export type GetCinemaSessionsSessionIdPosterError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetCinemaSessionsSessionIdPosterVariables = {
  pathParams: GetCinemaSessionsSessionIdPosterPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchGetCinemaSessionsSessionIdPoster = (
  variables: GetCinemaSessionsSessionIdPosterVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    GetCinemaSessionsSessionIdPosterError,
    undefined,
    {},
    {},
    GetCinemaSessionsSessionIdPosterPathParams
  >({
    url: "/cinema/sessions/{sessionId}/poster",
    method: "get",
    ...variables,
    signal,
  });

export const useGetCinemaSessionsSessionIdPoster = <TData = undefined,>(
  variables: GetCinemaSessionsSessionIdPosterVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      undefined,
      GetCinemaSessionsSessionIdPosterError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<
    undefined,
    GetCinemaSessionsSessionIdPosterError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/cinema/sessions/{sessionId}/poster",
      operationId: "getCinemaSessionsSessionIdPoster",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetCinemaSessionsSessionIdPoster(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type GetFlappybirdScoresQueryParams = {
  /**
   * @default 0
   */
  skip?: number;
  /**
   * @default 10
   */
  limit?: number;
};

export type GetFlappybirdScoresError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetFlappybirdScoresResponse = Schemas.FlappyBirdScoreInDB[];

export type GetFlappybirdScoresVariables = {
  queryParams?: GetFlappybirdScoresQueryParams;
} & HyperionContext["fetcherOptions"];

/**
 * Return the leaderboard score of the skip...limit
 */
export const fetchGetFlappybirdScores = (
  variables: GetFlappybirdScoresVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetFlappybirdScoresResponse,
    GetFlappybirdScoresError,
    undefined,
    {},
    GetFlappybirdScoresQueryParams,
    {}
  >({ url: "/flappybird/scores", method: "get", ...variables, signal });

/**
 * Return the leaderboard score of the skip...limit
 */
export const useGetFlappybirdScores = <TData = GetFlappybirdScoresResponse,>(
  variables: GetFlappybirdScoresVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetFlappybirdScoresResponse,
      GetFlappybirdScoresError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<
    GetFlappybirdScoresResponse,
    GetFlappybirdScoresError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/flappybird/scores",
      operationId: "getFlappybirdScores",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetFlappybirdScores({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type PostFlappybirdScoresError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostFlappybirdScoresVariables = {
  body: Schemas.FlappyBirdScoreBase;
} & HyperionContext["fetcherOptions"];

export const fetchPostFlappybirdScores = (
  variables: PostFlappybirdScoresVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.FlappyBirdScoreBase,
    PostFlappybirdScoresError,
    Schemas.FlappyBirdScoreBase,
    {},
    {},
    {}
  >({ url: "/flappybird/scores", method: "post", ...variables, signal });

export const usePostFlappybirdScores = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.FlappyBirdScoreBase,
      PostFlappybirdScoresError,
      PostFlappybirdScoresVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.FlappyBirdScoreBase,
    PostFlappybirdScoresError,
    PostFlappybirdScoresVariables
  >({
    mutationFn: (variables: PostFlappybirdScoresVariables) =>
      fetchPostFlappybirdScores({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetFlappybirdScoresMeError = Fetcher.ErrorWrapper<undefined>;

export type GetFlappybirdScoresMeVariables = HyperionContext["fetcherOptions"];

export const fetchGetFlappybirdScoresMe = (
  variables: GetFlappybirdScoresMeVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.FlappyBirdScoreCompleteFeedBack,
    GetFlappybirdScoresMeError,
    undefined,
    {},
    {},
    {}
  >({ url: "/flappybird/scores/me", method: "get", ...variables, signal });

export const useGetFlappybirdScoresMe = <
  TData = Schemas.FlappyBirdScoreCompleteFeedBack,
>(
  variables: GetFlappybirdScoresMeVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.FlappyBirdScoreCompleteFeedBack,
      GetFlappybirdScoresMeError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<
    Schemas.FlappyBirdScoreCompleteFeedBack,
    GetFlappybirdScoresMeError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/flappybird/scores/me",
      operationId: "getFlappybirdScoresMe",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetFlappybirdScoresMe({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type GetLoansLoanersError = Fetcher.ErrorWrapper<undefined>;

export type GetLoansLoanersResponse = Schemas.Loaner[];

export type GetLoansLoanersVariables = HyperionContext["fetcherOptions"];

/**
 * Get existing loaners.
 *
 * **This endpoint is only usable by administrators**
 */
export const fetchGetLoansLoaners = (
  variables: GetLoansLoanersVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetLoansLoanersResponse,
    GetLoansLoanersError,
    undefined,
    {},
    {},
    {}
  >({ url: "/loans/loaners/", method: "get", ...variables, signal });

/**
 * Get existing loaners.
 *
 * **This endpoint is only usable by administrators**
 */
export const useGetLoansLoaners = <TData = GetLoansLoanersResponse,>(
  variables: GetLoansLoanersVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetLoansLoanersResponse,
      GetLoansLoanersError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<
    GetLoansLoanersResponse,
    GetLoansLoanersError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/loans/loaners/",
      operationId: "getLoansLoaners",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetLoansLoaners({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type PostLoansLoanersError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostLoansLoanersVariables = {
  body: Schemas.LoanerBase;
} & HyperionContext["fetcherOptions"];

/**
 * Create a new loaner.
 *
 * Each loaner is associated with a `manager_group`. Users belonging to this group are able to manage the loaner items and loans.
 *
 * **This endpoint is only usable by administrators**
 */
export const fetchPostLoansLoaners = (
  variables: PostLoansLoanersVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.Loaner,
    PostLoansLoanersError,
    Schemas.LoanerBase,
    {},
    {},
    {}
  >({ url: "/loans/loaners/", method: "post", ...variables, signal });

/**
 * Create a new loaner.
 *
 * Each loaner is associated with a `manager_group`. Users belonging to this group are able to manage the loaner items and loans.
 *
 * **This endpoint is only usable by administrators**
 */
export const usePostLoansLoaners = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.Loaner,
      PostLoansLoanersError,
      PostLoansLoanersVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.Loaner,
    PostLoansLoanersError,
    PostLoansLoanersVariables
  >({
    mutationFn: (variables: PostLoansLoanersVariables) =>
      fetchPostLoansLoaners({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type DeleteLoansLoanersLoanerIdPathParams = {
  loanerId: string;
};

export type DeleteLoansLoanersLoanerIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type DeleteLoansLoanersLoanerIdVariables = {
  pathParams: DeleteLoansLoanersLoanerIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Delete a loaner. All items and loans associated with the loaner will also be deleted from the database.
 *
 * **This endpoint is only usable by administrators**
 */
export const fetchDeleteLoansLoanersLoanerId = (
  variables: DeleteLoansLoanersLoanerIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteLoansLoanersLoanerIdError,
    undefined,
    {},
    {},
    DeleteLoansLoanersLoanerIdPathParams
  >({
    url: "/loans/loaners/{loanerId}",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * Delete a loaner. All items and loans associated with the loaner will also be deleted from the database.
 *
 * **This endpoint is only usable by administrators**
 */
export const useDeleteLoansLoanersLoanerId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteLoansLoanersLoanerIdError,
      DeleteLoansLoanersLoanerIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteLoansLoanersLoanerIdError,
    DeleteLoansLoanersLoanerIdVariables
  >({
    mutationFn: (variables: DeleteLoansLoanersLoanerIdVariables) =>
      fetchDeleteLoansLoanersLoanerId({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type PatchLoansLoanersLoanerIdPathParams = {
  loanerId: string;
};

export type PatchLoansLoanersLoanerIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PatchLoansLoanersLoanerIdVariables = {
  body?: Schemas.LoanerUpdate;
  pathParams: PatchLoansLoanersLoanerIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Update a loaner, the request should contain a JSON with the fields to change (not necessarily all fields) and their new value.
 *
 * **This endpoint is only usable by administrators**
 */
export const fetchPatchLoansLoanersLoanerId = (
  variables: PatchLoansLoanersLoanerIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchLoansLoanersLoanerIdError,
    Schemas.LoanerUpdate,
    {},
    {},
    PatchLoansLoanersLoanerIdPathParams
  >({
    url: "/loans/loaners/{loanerId}",
    method: "patch",
    ...variables,
    signal,
  });

/**
 * Update a loaner, the request should contain a JSON with the fields to change (not necessarily all fields) and their new value.
 *
 * **This endpoint is only usable by administrators**
 */
export const usePatchLoansLoanersLoanerId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchLoansLoanersLoanerIdError,
      PatchLoansLoanersLoanerIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchLoansLoanersLoanerIdError,
    PatchLoansLoanersLoanerIdVariables
  >({
    mutationFn: (variables: PatchLoansLoanersLoanerIdVariables) =>
      fetchPatchLoansLoanersLoanerId({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetLoansLoanersLoanerIdLoansPathParams = {
  loanerId: string;
};

export type GetLoansLoanersLoanerIdLoansQueryParams = {
  returned?: boolean | null;
};

export type GetLoansLoanersLoanerIdLoansError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetLoansLoanersLoanerIdLoansResponse = Schemas.Loan[];

export type GetLoansLoanersLoanerIdLoansVariables = {
  pathParams: GetLoansLoanersLoanerIdLoansPathParams;
  queryParams?: GetLoansLoanersLoanerIdLoansQueryParams;
} & HyperionContext["fetcherOptions"];

/**
 * Return all loans from a given group.
 *
 *
 * The query string `returned` can be used to get only return or non returned loans. By default, all loans are returned.
 *
 *
 * **The user must be a member of the loaner group_manager to use this endpoint**
 */
export const fetchGetLoansLoanersLoanerIdLoans = (
  variables: GetLoansLoanersLoanerIdLoansVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetLoansLoanersLoanerIdLoansResponse,
    GetLoansLoanersLoanerIdLoansError,
    undefined,
    {},
    GetLoansLoanersLoanerIdLoansQueryParams,
    GetLoansLoanersLoanerIdLoansPathParams
  >({
    url: "/loans/loaners/{loanerId}/loans",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Return all loans from a given group.
 *
 *
 * The query string `returned` can be used to get only return or non returned loans. By default, all loans are returned.
 *
 *
 * **The user must be a member of the loaner group_manager to use this endpoint**
 */
export const useGetLoansLoanersLoanerIdLoans = <
  TData = GetLoansLoanersLoanerIdLoansResponse,
>(
  variables: GetLoansLoanersLoanerIdLoansVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetLoansLoanersLoanerIdLoansResponse,
      GetLoansLoanersLoanerIdLoansError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<
    GetLoansLoanersLoanerIdLoansResponse,
    GetLoansLoanersLoanerIdLoansError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/loans/loaners/{loanerId}/loans",
      operationId: "getLoansLoanersLoanerIdLoans",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetLoansLoanersLoanerIdLoans(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type GetLoansLoanersLoanerIdItemsPathParams = {
  loanerId: string;
};

export type GetLoansLoanersLoanerIdItemsError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetLoansLoanersLoanerIdItemsResponse = Schemas.Item[];

export type GetLoansLoanersLoanerIdItemsVariables = {
  pathParams: GetLoansLoanersLoanerIdItemsPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Return all items of a loaner.
 *
 * **The user must be a member of the loaner group_manager to use this endpoint**
 */
export const fetchGetLoansLoanersLoanerIdItems = (
  variables: GetLoansLoanersLoanerIdItemsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetLoansLoanersLoanerIdItemsResponse,
    GetLoansLoanersLoanerIdItemsError,
    undefined,
    {},
    {},
    GetLoansLoanersLoanerIdItemsPathParams
  >({
    url: "/loans/loaners/{loanerId}/items",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Return all items of a loaner.
 *
 * **The user must be a member of the loaner group_manager to use this endpoint**
 */
export const useGetLoansLoanersLoanerIdItems = <
  TData = GetLoansLoanersLoanerIdItemsResponse,
>(
  variables: GetLoansLoanersLoanerIdItemsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetLoansLoanersLoanerIdItemsResponse,
      GetLoansLoanersLoanerIdItemsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<
    GetLoansLoanersLoanerIdItemsResponse,
    GetLoansLoanersLoanerIdItemsError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/loans/loaners/{loanerId}/items",
      operationId: "getLoansLoanersLoanerIdItems",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetLoansLoanersLoanerIdItems(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type PostLoansLoanersLoanerIdItemsPathParams = {
  loanerId: string;
};

export type PostLoansLoanersLoanerIdItemsError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostLoansLoanersLoanerIdItemsVariables = {
  body: Schemas.ItemBase;
  pathParams: PostLoansLoanersLoanerIdItemsPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Create a new item for a loaner. A given loaner can not have more than one item with the same `name`.
 *
 * **The user must be a member of the loaner group_manager to use this endpoint**
 */
export const fetchPostLoansLoanersLoanerIdItems = (
  variables: PostLoansLoanersLoanerIdItemsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.Item,
    PostLoansLoanersLoanerIdItemsError,
    Schemas.ItemBase,
    {},
    {},
    PostLoansLoanersLoanerIdItemsPathParams
  >({
    url: "/loans/loaners/{loanerId}/items",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Create a new item for a loaner. A given loaner can not have more than one item with the same `name`.
 *
 * **The user must be a member of the loaner group_manager to use this endpoint**
 */
export const usePostLoansLoanersLoanerIdItems = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.Item,
      PostLoansLoanersLoanerIdItemsError,
      PostLoansLoanersLoanerIdItemsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.Item,
    PostLoansLoanersLoanerIdItemsError,
    PostLoansLoanersLoanerIdItemsVariables
  >({
    mutationFn: (variables: PostLoansLoanersLoanerIdItemsVariables) =>
      fetchPostLoansLoanersLoanerIdItems({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type PatchLoansLoanersLoanerIdItemsItemIdPathParams = {
  loanerId: string;
  itemId: string;
};

export type PatchLoansLoanersLoanerIdItemsItemIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PatchLoansLoanersLoanerIdItemsItemIdVariables = {
  body?: Schemas.ItemUpdate;
  pathParams: PatchLoansLoanersLoanerIdItemsItemIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Update a loaner's item.
 *
 * **The user must be a member of the loaner group_manager to use this endpoint**
 */
export const fetchPatchLoansLoanersLoanerIdItemsItemId = (
  variables: PatchLoansLoanersLoanerIdItemsItemIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchLoansLoanersLoanerIdItemsItemIdError,
    Schemas.ItemUpdate,
    {},
    {},
    PatchLoansLoanersLoanerIdItemsItemIdPathParams
  >({
    url: "/loans/loaners/{loanerId}/items/{itemId}",
    method: "patch",
    ...variables,
    signal,
  });

/**
 * Update a loaner's item.
 *
 * **The user must be a member of the loaner group_manager to use this endpoint**
 */
export const usePatchLoansLoanersLoanerIdItemsItemId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchLoansLoanersLoanerIdItemsItemIdError,
      PatchLoansLoanersLoanerIdItemsItemIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchLoansLoanersLoanerIdItemsItemIdError,
    PatchLoansLoanersLoanerIdItemsItemIdVariables
  >({
    mutationFn: (variables: PatchLoansLoanersLoanerIdItemsItemIdVariables) =>
      fetchPatchLoansLoanersLoanerIdItemsItemId({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type DeleteLoansLoanersLoanerIdItemsItemIdPathParams = {
  loanerId: string;
  itemId: string;
};

export type DeleteLoansLoanersLoanerIdItemsItemIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type DeleteLoansLoanersLoanerIdItemsItemIdVariables = {
  pathParams: DeleteLoansLoanersLoanerIdItemsItemIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Delete a loaner's item.
 * This will remove the item from all loans but won't delete any loan.
 *
 * **The user must be a member of the loaner group_manager to use this endpoint**
 */
export const fetchDeleteLoansLoanersLoanerIdItemsItemId = (
  variables: DeleteLoansLoanersLoanerIdItemsItemIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteLoansLoanersLoanerIdItemsItemIdError,
    undefined,
    {},
    {},
    DeleteLoansLoanersLoanerIdItemsItemIdPathParams
  >({
    url: "/loans/loaners/{loanerId}/items/{itemId}",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * Delete a loaner's item.
 * This will remove the item from all loans but won't delete any loan.
 *
 * **The user must be a member of the loaner group_manager to use this endpoint**
 */
export const useDeleteLoansLoanersLoanerIdItemsItemId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteLoansLoanersLoanerIdItemsItemIdError,
      DeleteLoansLoanersLoanerIdItemsItemIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteLoansLoanersLoanerIdItemsItemIdError,
    DeleteLoansLoanersLoanerIdItemsItemIdVariables
  >({
    mutationFn: (variables: DeleteLoansLoanersLoanerIdItemsItemIdVariables) =>
      fetchDeleteLoansLoanersLoanerIdItemsItemId({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type GetLoansUsersMeQueryParams = {
  returned?: boolean | null;
};

export type GetLoansUsersMeError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetLoansUsersMeResponse = Schemas.Loan[];

export type GetLoansUsersMeVariables = {
  queryParams?: GetLoansUsersMeQueryParams;
} & HyperionContext["fetcherOptions"];

/**
 * Return all loans from the current user.
 *
 * The query string `returned` can be used to get only returned or non returned loans. By default, all loans are returned.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const fetchGetLoansUsersMe = (
  variables: GetLoansUsersMeVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetLoansUsersMeResponse,
    GetLoansUsersMeError,
    undefined,
    {},
    GetLoansUsersMeQueryParams,
    {}
  >({ url: "/loans/users/me", method: "get", ...variables, signal });

/**
 * Return all loans from the current user.
 *
 * The query string `returned` can be used to get only returned or non returned loans. By default, all loans are returned.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const useGetLoansUsersMe = <TData = GetLoansUsersMeResponse,>(
  variables: GetLoansUsersMeVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetLoansUsersMeResponse,
      GetLoansUsersMeError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<
    GetLoansUsersMeResponse,
    GetLoansUsersMeError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/loans/users/me",
      operationId: "getLoansUsersMe",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetLoansUsersMe({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type GetLoansUsersMeLoanersError = Fetcher.ErrorWrapper<undefined>;

export type GetLoansUsersMeLoanersResponse = Schemas.Loaner[];

export type GetLoansUsersMeLoanersVariables = HyperionContext["fetcherOptions"];

/**
 * Return all loaners the current user can manage.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const fetchGetLoansUsersMeLoaners = (
  variables: GetLoansUsersMeLoanersVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetLoansUsersMeLoanersResponse,
    GetLoansUsersMeLoanersError,
    undefined,
    {},
    {},
    {}
  >({ url: "/loans/users/me/loaners", method: "get", ...variables, signal });

/**
 * Return all loaners the current user can manage.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const useGetLoansUsersMeLoaners = <
  TData = GetLoansUsersMeLoanersResponse,
>(
  variables: GetLoansUsersMeLoanersVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetLoansUsersMeLoanersResponse,
      GetLoansUsersMeLoanersError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<
    GetLoansUsersMeLoanersResponse,
    GetLoansUsersMeLoanersError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/loans/users/me/loaners",
      operationId: "getLoansUsersMeLoaners",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetLoansUsersMeLoaners({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type PostLoansError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostLoansVariables = {
  body: Schemas.LoanCreation;
} & HyperionContext["fetcherOptions"];

/**
 * Create a new loan in database and add the requested items
 *
 * **The user must be a member of the loaner group_manager to use this endpoint**
 */
export const fetchPostLoans = (
  variables: PostLoansVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<Schemas.Loan, PostLoansError, Schemas.LoanCreation, {}, {}, {}>(
    { url: "/loans/", method: "post", ...variables, signal },
  );

/**
 * Create a new loan in database and add the requested items
 *
 * **The user must be a member of the loaner group_manager to use this endpoint**
 */
export const usePostLoans = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.Loan,
      PostLoansError,
      PostLoansVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.Loan,
    PostLoansError,
    PostLoansVariables
  >({
    mutationFn: (variables: PostLoansVariables) =>
      fetchPostLoans({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type PatchLoansLoanIdPathParams = {
  loanId: string;
};

export type PatchLoansLoanIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PatchLoansLoanIdVariables = {
  body?: Schemas.LoanUpdate;
  pathParams: PatchLoansLoanIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Update a loan and its items.
 *
 * As the endpoint can update the loan items, it will send back
 * the new representation of the loan `Loan` including the new items relationships
 *
 * **The user must be a member of the loaner group_manager to use this endpoint**
 */
export const fetchPatchLoansLoanId = (
  variables: PatchLoansLoanIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchLoansLoanIdError,
    Schemas.LoanUpdate,
    {},
    {},
    PatchLoansLoanIdPathParams
  >({ url: "/loans/{loanId}", method: "patch", ...variables, signal });

/**
 * Update a loan and its items.
 *
 * As the endpoint can update the loan items, it will send back
 * the new representation of the loan `Loan` including the new items relationships
 *
 * **The user must be a member of the loaner group_manager to use this endpoint**
 */
export const usePatchLoansLoanId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchLoansLoanIdError,
      PatchLoansLoanIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchLoansLoanIdError,
    PatchLoansLoanIdVariables
  >({
    mutationFn: (variables: PatchLoansLoanIdVariables) =>
      fetchPatchLoansLoanId({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type DeleteLoansLoanIdPathParams = {
  loanId: string;
};

export type DeleteLoansLoanIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type DeleteLoansLoanIdVariables = {
  pathParams: DeleteLoansLoanIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Delete a loan
 * This will remove the loan but won't delete any loaner items.
 *
 * **The user must be a member of the loaner group_manager to use this endpoint**
 */
export const fetchDeleteLoansLoanId = (
  variables: DeleteLoansLoanIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteLoansLoanIdError,
    undefined,
    {},
    {},
    DeleteLoansLoanIdPathParams
  >({ url: "/loans/{loanId}", method: "delete", ...variables, signal });

/**
 * Delete a loan
 * This will remove the loan but won't delete any loaner items.
 *
 * **The user must be a member of the loaner group_manager to use this endpoint**
 */
export const useDeleteLoansLoanId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteLoansLoanIdError,
      DeleteLoansLoanIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteLoansLoanIdError,
    DeleteLoansLoanIdVariables
  >({
    mutationFn: (variables: DeleteLoansLoanIdVariables) =>
      fetchDeleteLoansLoanId({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type PostLoansLoanIdReturnPathParams = {
  loanId: string;
};

export type PostLoansLoanIdReturnError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostLoansLoanIdReturnVariables = {
  pathParams: PostLoansLoanIdReturnPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Mark a loan as returned. This will update items availability.
 *
 * **The user must be a member of the loaner group_manager to use this endpoint**
 */
export const fetchPostLoansLoanIdReturn = (
  variables: PostLoansLoanIdReturnVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PostLoansLoanIdReturnError,
    undefined,
    {},
    {},
    PostLoansLoanIdReturnPathParams
  >({ url: "/loans/{loanId}/return", method: "post", ...variables, signal });

/**
 * Mark a loan as returned. This will update items availability.
 *
 * **The user must be a member of the loaner group_manager to use this endpoint**
 */
export const usePostLoansLoanIdReturn = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PostLoansLoanIdReturnError,
      PostLoansLoanIdReturnVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PostLoansLoanIdReturnError,
    PostLoansLoanIdReturnVariables
  >({
    mutationFn: (variables: PostLoansLoanIdReturnVariables) =>
      fetchPostLoansLoanIdReturn({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type PostLoansLoanIdExtendPathParams = {
  loanId: string;
};

export type PostLoansLoanIdExtendError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostLoansLoanIdExtendVariables = {
  body?: Schemas.LoanExtend;
  pathParams: PostLoansLoanIdExtendPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * A new `end` date or an extended `duration` can be provided. If the two are provided, only `end` will be used.
 *
 * **The user must be a member of the loaner group_manager to use this endpoint**
 */
export const fetchPostLoansLoanIdExtend = (
  variables: PostLoansLoanIdExtendVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PostLoansLoanIdExtendError,
    Schemas.LoanExtend,
    {},
    {},
    PostLoansLoanIdExtendPathParams
  >({ url: "/loans/{loanId}/extend", method: "post", ...variables, signal });

/**
 * A new `end` date or an extended `duration` can be provided. If the two are provided, only `end` will be used.
 *
 * **The user must be a member of the loaner group_manager to use this endpoint**
 */
export const usePostLoansLoanIdExtend = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PostLoansLoanIdExtendError,
      PostLoansLoanIdExtendVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PostLoansLoanIdExtendError,
    PostLoansLoanIdExtendVariables
  >({
    mutationFn: (variables: PostLoansLoanIdExtendVariables) =>
      fetchPostLoansLoanIdExtend({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetPhPaperIdPdfPathParams = {
  /**
   * @format uuid
   */
  paperId: string;
};

export type GetPhPaperIdPdfError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetPhPaperIdPdfVariables = {
  pathParams: GetPhPaperIdPdfPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchGetPhPaperIdPdf = (
  variables: GetPhPaperIdPdfVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    GetPhPaperIdPdfError,
    undefined,
    {},
    {},
    GetPhPaperIdPdfPathParams
  >({ url: "/ph/{paperId}/pdf", method: "get", ...variables, signal });

export const useGetPhPaperIdPdf = <TData = undefined,>(
  variables: GetPhPaperIdPdfVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, GetPhPaperIdPdfError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<undefined, GetPhPaperIdPdfError, TData>({
    queryKey: queryKeyFn({
      path: "/ph/{paperId}/pdf",
      operationId: "getPhPaperIdPdf",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetPhPaperIdPdf({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type PostPhPaperIdPdfPathParams = {
  /**
   * @format uuid
   */
  paperId: string;
};

export type PostPhPaperIdPdfError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostPhPaperIdPdfVariables = {
  body: Schemas.BodyCreatePaperPdfAndCoverPhPaperIdPdfPost;
  pathParams: PostPhPaperIdPdfPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchPostPhPaperIdPdf = (
  variables: PostPhPaperIdPdfVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    void,
    PostPhPaperIdPdfError,
    Schemas.BodyCreatePaperPdfAndCoverPhPaperIdPdfPost,
    {},
    {},
    PostPhPaperIdPdfPathParams
  >({ url: "/ph/{paperId}/pdf", method: "post", ...variables, signal });

export const usePostPhPaperIdPdf = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      void,
      PostPhPaperIdPdfError,
      PostPhPaperIdPdfVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    void,
    PostPhPaperIdPdfError,
    PostPhPaperIdPdfVariables
  >({
    mutationFn: (variables: PostPhPaperIdPdfVariables) =>
      fetchPostPhPaperIdPdf({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetPhError = Fetcher.ErrorWrapper<undefined>;

export type GetPhResponse = Schemas.PaperComplete[];

export type GetPhVariables = HyperionContext["fetcherOptions"];

/**
 * Return all editions until now, sorted from the latest to the oldest
 */
export const fetchGetPh = (variables: GetPhVariables, signal?: AbortSignal) =>
  hyperionFetch<GetPhResponse, GetPhError, undefined, {}, {}, {}>({
    url: "/ph/",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Return all editions until now, sorted from the latest to the oldest
 */
export const useGetPh = <TData = GetPhResponse,>(
  variables: GetPhVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<GetPhResponse, GetPhError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<GetPhResponse, GetPhError, TData>({
    queryKey: queryKeyFn({ path: "/ph/", operationId: "getPh", variables }),
    queryFn: ({ signal }) =>
      fetchGetPh({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type PostPhError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostPhVariables = {
  body: Schemas.PaperBase;
} & HyperionContext["fetcherOptions"];

/**
 * Create a new paper.
 */
export const fetchPostPh = (variables: PostPhVariables, signal?: AbortSignal) =>
  hyperionFetch<
    Schemas.PaperComplete,
    PostPhError,
    Schemas.PaperBase,
    {},
    {},
    {}
  >({ url: "/ph/", method: "post", ...variables, signal });

/**
 * Create a new paper.
 */
export const usePostPh = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.PaperComplete,
      PostPhError,
      PostPhVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.PaperComplete,
    PostPhError,
    PostPhVariables
  >({
    mutationFn: (variables: PostPhVariables) =>
      fetchPostPh({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetPhAdminError = Fetcher.ErrorWrapper<undefined>;

export type GetPhAdminResponse = Schemas.PaperComplete[];

export type GetPhAdminVariables = HyperionContext["fetcherOptions"];

/**
 * Return all editions, sorted from the latest to the oldest
 */
export const fetchGetPhAdmin = (
  variables: GetPhAdminVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<GetPhAdminResponse, GetPhAdminError, undefined, {}, {}, {}>({
    url: "/ph/admin",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Return all editions, sorted from the latest to the oldest
 */
export const useGetPhAdmin = <TData = GetPhAdminResponse,>(
  variables: GetPhAdminVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<GetPhAdminResponse, GetPhAdminError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<GetPhAdminResponse, GetPhAdminError, TData>({
    queryKey: queryKeyFn({
      path: "/ph/admin",
      operationId: "getPhAdmin",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetPhAdmin({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type GetPhPaperIdCoverPathParams = {
  /**
   * @format uuid
   */
  paperId: string;
};

export type GetPhPaperIdCoverError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetPhPaperIdCoverVariables = {
  pathParams: GetPhPaperIdCoverPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchGetPhPaperIdCover = (
  variables: GetPhPaperIdCoverVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    void,
    GetPhPaperIdCoverError,
    undefined,
    {},
    {},
    GetPhPaperIdCoverPathParams
  >({ url: "/ph/{paperId}/cover", method: "get", ...variables, signal });

export const useGetPhPaperIdCover = <TData = void,>(
  variables: GetPhPaperIdCoverVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<void, GetPhPaperIdCoverError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<void, GetPhPaperIdCoverError, TData>({
    queryKey: queryKeyFn({
      path: "/ph/{paperId}/cover",
      operationId: "getPhPaperIdCover",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetPhPaperIdCover({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type PatchPhPaperIdPathParams = {
  /**
   * @format uuid
   */
  paperId: string;
};

export type PatchPhPaperIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PatchPhPaperIdVariables = {
  body?: Schemas.PaperUpdate;
  pathParams: PatchPhPaperIdPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchPatchPhPaperId = (
  variables: PatchPhPaperIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchPhPaperIdError,
    Schemas.PaperUpdate,
    {},
    {},
    PatchPhPaperIdPathParams
  >({ url: "/ph/{paperId}", method: "patch", ...variables, signal });

export const usePatchPhPaperId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchPhPaperIdError,
      PatchPhPaperIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchPhPaperIdError,
    PatchPhPaperIdVariables
  >({
    mutationFn: (variables: PatchPhPaperIdVariables) =>
      fetchPatchPhPaperId({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type DeletePhPaperIdPathParams = {
  /**
   * @format uuid
   */
  paperId: string;
};

export type DeletePhPaperIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type DeletePhPaperIdVariables = {
  pathParams: DeletePhPaperIdPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchDeletePhPaperId = (
  variables: DeletePhPaperIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeletePhPaperIdError,
    undefined,
    {},
    {},
    DeletePhPaperIdPathParams
  >({ url: "/ph/{paperId}", method: "delete", ...variables, signal });

export const useDeletePhPaperId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeletePhPaperIdError,
      DeletePhPaperIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeletePhPaperIdError,
    DeletePhPaperIdVariables
  >({
    mutationFn: (variables: DeletePhPaperIdVariables) =>
      fetchDeletePhPaperId({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetPhonebookAssociationsError = Fetcher.ErrorWrapper<undefined>;

export type GetPhonebookAssociationsResponse = Schemas.AssociationComplete[];

export type GetPhonebookAssociationsVariables =
  HyperionContext["fetcherOptions"];

/**
 * Return all associations from database as a list of AssociationComplete schemas
 */
export const fetchGetPhonebookAssociations = (
  variables: GetPhonebookAssociationsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetPhonebookAssociationsResponse,
    GetPhonebookAssociationsError,
    undefined,
    {},
    {},
    {}
  >({ url: "/phonebook/associations/", method: "get", ...variables, signal });

/**
 * Return all associations from database as a list of AssociationComplete schemas
 */
export const useGetPhonebookAssociations = <
  TData = GetPhonebookAssociationsResponse,
>(
  variables: GetPhonebookAssociationsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetPhonebookAssociationsResponse,
      GetPhonebookAssociationsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<
    GetPhonebookAssociationsResponse,
    GetPhonebookAssociationsError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/phonebook/associations/",
      operationId: "getPhonebookAssociations",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetPhonebookAssociations(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type PostPhonebookAssociationsError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostPhonebookAssociationsVariables = {
  body: Schemas.AssociationBase;
} & HyperionContext["fetcherOptions"];

/**
 * Create a new Association by giving an AssociationBase scheme
 *
 * **This endpoint is only usable by CAA, BDE**
 */
export const fetchPostPhonebookAssociations = (
  variables: PostPhonebookAssociationsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.AssociationComplete,
    PostPhonebookAssociationsError,
    Schemas.AssociationBase,
    {},
    {},
    {}
  >({ url: "/phonebook/associations/", method: "post", ...variables, signal });

/**
 * Create a new Association by giving an AssociationBase scheme
 *
 * **This endpoint is only usable by CAA, BDE**
 */
export const usePostPhonebookAssociations = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.AssociationComplete,
      PostPhonebookAssociationsError,
      PostPhonebookAssociationsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.AssociationComplete,
    PostPhonebookAssociationsError,
    PostPhonebookAssociationsVariables
  >({
    mutationFn: (variables: PostPhonebookAssociationsVariables) =>
      fetchPostPhonebookAssociations({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetPhonebookRoletagsError = Fetcher.ErrorWrapper<undefined>;

export type GetPhonebookRoletagsVariables = HyperionContext["fetcherOptions"];

/**
 * Return all available role tags from RoleTags enum.
 */
export const fetchGetPhonebookRoletags = (
  variables: GetPhonebookRoletagsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.RoleTagsReturn,
    GetPhonebookRoletagsError,
    undefined,
    {},
    {},
    {}
  >({ url: "/phonebook/roletags", method: "get", ...variables, signal });

/**
 * Return all available role tags from RoleTags enum.
 */
export const useGetPhonebookRoletags = <TData = Schemas.RoleTagsReturn,>(
  variables: GetPhonebookRoletagsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.RoleTagsReturn,
      GetPhonebookRoletagsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<
    Schemas.RoleTagsReturn,
    GetPhonebookRoletagsError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/phonebook/roletags",
      operationId: "getPhonebookRoletags",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetPhonebookRoletags({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type GetPhonebookAssociationsKindsError =
  Fetcher.ErrorWrapper<undefined>;

export type GetPhonebookAssociationsKindsVariables =
  HyperionContext["fetcherOptions"];

/**
 * Return all available kinds of from Kinds enum.
 */
export const fetchGetPhonebookAssociationsKinds = (
  variables: GetPhonebookAssociationsKindsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.KindsReturn,
    GetPhonebookAssociationsKindsError,
    undefined,
    {},
    {},
    {}
  >({
    url: "/phonebook/associations/kinds",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Return all available kinds of from Kinds enum.
 */
export const useGetPhonebookAssociationsKinds = <TData = Schemas.KindsReturn,>(
  variables: GetPhonebookAssociationsKindsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.KindsReturn,
      GetPhonebookAssociationsKindsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<
    Schemas.KindsReturn,
    GetPhonebookAssociationsKindsError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/phonebook/associations/kinds",
      operationId: "getPhonebookAssociationsKinds",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetPhonebookAssociationsKinds(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type PatchPhonebookAssociationsAssociationIdPathParams = {
  associationId: string;
};

export type PatchPhonebookAssociationsAssociationIdError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type PatchPhonebookAssociationsAssociationIdVariables = {
  body?: Schemas.AssociationEdit;
  pathParams: PatchPhonebookAssociationsAssociationIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Update an Association
 *
 * **This endpoint is only usable by CAA, BDE and association's president**
 */
export const fetchPatchPhonebookAssociationsAssociationId = (
  variables: PatchPhonebookAssociationsAssociationIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchPhonebookAssociationsAssociationIdError,
    Schemas.AssociationEdit,
    {},
    {},
    PatchPhonebookAssociationsAssociationIdPathParams
  >({
    url: "/phonebook/associations/{associationId}",
    method: "patch",
    ...variables,
    signal,
  });

/**
 * Update an Association
 *
 * **This endpoint is only usable by CAA, BDE and association's president**
 */
export const usePatchPhonebookAssociationsAssociationId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchPhonebookAssociationsAssociationIdError,
      PatchPhonebookAssociationsAssociationIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchPhonebookAssociationsAssociationIdError,
    PatchPhonebookAssociationsAssociationIdVariables
  >({
    mutationFn: (variables: PatchPhonebookAssociationsAssociationIdVariables) =>
      fetchPatchPhonebookAssociationsAssociationId({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type DeletePhonebookAssociationsAssociationIdPathParams = {
  associationId: string;
};

export type DeletePhonebookAssociationsAssociationIdError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type DeletePhonebookAssociationsAssociationIdVariables = {
  pathParams: DeletePhonebookAssociationsAssociationIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Delete an Association
 *
 * [!] Memberships linked to association_id will be deleted too
 *
 * **This endpoint is only usable by CAA and BDE**
 */
export const fetchDeletePhonebookAssociationsAssociationId = (
  variables: DeletePhonebookAssociationsAssociationIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeletePhonebookAssociationsAssociationIdError,
    undefined,
    {},
    {},
    DeletePhonebookAssociationsAssociationIdPathParams
  >({
    url: "/phonebook/associations/{associationId}",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * Delete an Association
 *
 * [!] Memberships linked to association_id will be deleted too
 *
 * **This endpoint is only usable by CAA and BDE**
 */
export const useDeletePhonebookAssociationsAssociationId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeletePhonebookAssociationsAssociationIdError,
      DeletePhonebookAssociationsAssociationIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeletePhonebookAssociationsAssociationIdError,
    DeletePhonebookAssociationsAssociationIdVariables
  >({
    mutationFn: (
      variables: DeletePhonebookAssociationsAssociationIdVariables,
    ) =>
      fetchDeletePhonebookAssociationsAssociationId({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type GetPhonebookAssociationsAssociationIdMembersPathParams = {
  associationId: string;
};

export type GetPhonebookAssociationsAssociationIdMembersError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type GetPhonebookAssociationsAssociationIdMembersResponse =
  Schemas.MemberComplete[];

export type GetPhonebookAssociationsAssociationIdMembersVariables = {
  pathParams: GetPhonebookAssociationsAssociationIdMembersPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Return the list of MemberComplete of an Association.
 */
export const fetchGetPhonebookAssociationsAssociationIdMembers = (
  variables: GetPhonebookAssociationsAssociationIdMembersVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetPhonebookAssociationsAssociationIdMembersResponse,
    GetPhonebookAssociationsAssociationIdMembersError,
    undefined,
    {},
    {},
    GetPhonebookAssociationsAssociationIdMembersPathParams
  >({
    url: "/phonebook/associations/{associationId}/members/",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Return the list of MemberComplete of an Association.
 */
export const useGetPhonebookAssociationsAssociationIdMembers = <
  TData = GetPhonebookAssociationsAssociationIdMembersResponse,
>(
  variables: GetPhonebookAssociationsAssociationIdMembersVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetPhonebookAssociationsAssociationIdMembersResponse,
      GetPhonebookAssociationsAssociationIdMembersError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<
    GetPhonebookAssociationsAssociationIdMembersResponse,
    GetPhonebookAssociationsAssociationIdMembersError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/phonebook/associations/{associationId}/members/",
      operationId: "getPhonebookAssociationsAssociationIdMembers",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetPhonebookAssociationsAssociationIdMembers(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type GetPhonebookAssociationsAssociationIdMembersMandateYearPathParams =
  {
    associationId: string;
    mandateYear: number;
  };

export type GetPhonebookAssociationsAssociationIdMembersMandateYearError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type GetPhonebookAssociationsAssociationIdMembersMandateYearResponse =
  Schemas.MemberComplete[];

export type GetPhonebookAssociationsAssociationIdMembersMandateYearVariables = {
  pathParams: GetPhonebookAssociationsAssociationIdMembersMandateYearPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Return the list of MemberComplete of an Association with given mandate_year.
 */
export const fetchGetPhonebookAssociationsAssociationIdMembersMandateYear = (
  variables: GetPhonebookAssociationsAssociationIdMembersMandateYearVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetPhonebookAssociationsAssociationIdMembersMandateYearResponse,
    GetPhonebookAssociationsAssociationIdMembersMandateYearError,
    undefined,
    {},
    {},
    GetPhonebookAssociationsAssociationIdMembersMandateYearPathParams
  >({
    url: "/phonebook/associations/{associationId}/members/{mandateYear}",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Return the list of MemberComplete of an Association with given mandate_year.
 */
export const useGetPhonebookAssociationsAssociationIdMembersMandateYear = <
  TData = GetPhonebookAssociationsAssociationIdMembersMandateYearResponse,
>(
  variables: GetPhonebookAssociationsAssociationIdMembersMandateYearVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetPhonebookAssociationsAssociationIdMembersMandateYearResponse,
      GetPhonebookAssociationsAssociationIdMembersMandateYearError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<
    GetPhonebookAssociationsAssociationIdMembersMandateYearResponse,
    GetPhonebookAssociationsAssociationIdMembersMandateYearError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/phonebook/associations/{associationId}/members/{mandateYear}",
      operationId: "getPhonebookAssociationsAssociationIdMembersMandateYear",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetPhonebookAssociationsAssociationIdMembersMandateYear(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type GetPhonebookMemberUserIdPathParams = {
  userId: string;
};

export type GetPhonebookMemberUserIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetPhonebookMemberUserIdVariables = {
  pathParams: GetPhonebookMemberUserIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Return MemberComplete for given user_id.
 */
export const fetchGetPhonebookMemberUserId = (
  variables: GetPhonebookMemberUserIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.MemberComplete,
    GetPhonebookMemberUserIdError,
    undefined,
    {},
    {},
    GetPhonebookMemberUserIdPathParams
  >({ url: "/phonebook/member/{userId}", method: "get", ...variables, signal });

/**
 * Return MemberComplete for given user_id.
 */
export const useGetPhonebookMemberUserId = <TData = Schemas.MemberComplete,>(
  variables: GetPhonebookMemberUserIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.MemberComplete,
      GetPhonebookMemberUserIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<
    Schemas.MemberComplete,
    GetPhonebookMemberUserIdError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/phonebook/member/{userId}",
      operationId: "getPhonebookMemberUserId",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetPhonebookMemberUserId(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type PostPhonebookAssociationsMembershipsError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostPhonebookAssociationsMembershipsVariables = {
  body: Schemas.AppModulesPhonebookSchemasPhonebookMembershipBase;
} & HyperionContext["fetcherOptions"];

/**
 * Create a new Membership.
 * 'role_tags' are used to indicate if the members has a main role in the association (president, secretary ...) and 'role_name' is the display name for this membership
 *
 * **This endpoint is only usable by CAA, BDE and association's president**
 */
export const fetchPostPhonebookAssociationsMemberships = (
  variables: PostPhonebookAssociationsMembershipsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.AppModulesPhonebookSchemasPhonebookMembershipComplete,
    PostPhonebookAssociationsMembershipsError,
    Schemas.AppModulesPhonebookSchemasPhonebookMembershipBase,
    {},
    {},
    {}
  >({
    url: "/phonebook/associations/memberships",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Create a new Membership.
 * 'role_tags' are used to indicate if the members has a main role in the association (president, secretary ...) and 'role_name' is the display name for this membership
 *
 * **This endpoint is only usable by CAA, BDE and association's president**
 */
export const usePostPhonebookAssociationsMemberships = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.AppModulesPhonebookSchemasPhonebookMembershipComplete,
      PostPhonebookAssociationsMembershipsError,
      PostPhonebookAssociationsMembershipsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.AppModulesPhonebookSchemasPhonebookMembershipComplete,
    PostPhonebookAssociationsMembershipsError,
    PostPhonebookAssociationsMembershipsVariables
  >({
    mutationFn: (variables: PostPhonebookAssociationsMembershipsVariables) =>
      fetchPostPhonebookAssociationsMemberships({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type PatchPhonebookAssociationsMembershipsMembershipIdPathParams = {
  membershipId: string;
};

export type PatchPhonebookAssociationsMembershipsMembershipIdError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type PatchPhonebookAssociationsMembershipsMembershipIdVariables = {
  body?: Schemas.MembershipEdit;
  pathParams: PatchPhonebookAssociationsMembershipsMembershipIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Update a Membership.
 *
 * **This endpoint is only usable by CAA, BDE and association's president**
 */
export const fetchPatchPhonebookAssociationsMembershipsMembershipId = (
  variables: PatchPhonebookAssociationsMembershipsMembershipIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchPhonebookAssociationsMembershipsMembershipIdError,
    Schemas.MembershipEdit,
    {},
    {},
    PatchPhonebookAssociationsMembershipsMembershipIdPathParams
  >({
    url: "/phonebook/associations/memberships/{membershipId}",
    method: "patch",
    ...variables,
    signal,
  });

/**
 * Update a Membership.
 *
 * **This endpoint is only usable by CAA, BDE and association's president**
 */
export const usePatchPhonebookAssociationsMembershipsMembershipId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchPhonebookAssociationsMembershipsMembershipIdError,
      PatchPhonebookAssociationsMembershipsMembershipIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchPhonebookAssociationsMembershipsMembershipIdError,
    PatchPhonebookAssociationsMembershipsMembershipIdVariables
  >({
    mutationFn: (
      variables: PatchPhonebookAssociationsMembershipsMembershipIdVariables,
    ) =>
      fetchPatchPhonebookAssociationsMembershipsMembershipId({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type DeletePhonebookAssociationsMembershipsMembershipIdPathParams = {
  membershipId: string;
};

export type DeletePhonebookAssociationsMembershipsMembershipIdError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type DeletePhonebookAssociationsMembershipsMembershipIdVariables = {
  pathParams: DeletePhonebookAssociationsMembershipsMembershipIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Delete a membership.
 *
 * **This endpoint is only usable by CAA, BDE and association's president**
 */
export const fetchDeletePhonebookAssociationsMembershipsMembershipId = (
  variables: DeletePhonebookAssociationsMembershipsMembershipIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeletePhonebookAssociationsMembershipsMembershipIdError,
    undefined,
    {},
    {},
    DeletePhonebookAssociationsMembershipsMembershipIdPathParams
  >({
    url: "/phonebook/associations/memberships/{membershipId}",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * Delete a membership.
 *
 * **This endpoint is only usable by CAA, BDE and association's president**
 */
export const useDeletePhonebookAssociationsMembershipsMembershipId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeletePhonebookAssociationsMembershipsMembershipIdError,
      DeletePhonebookAssociationsMembershipsMembershipIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeletePhonebookAssociationsMembershipsMembershipIdError,
    DeletePhonebookAssociationsMembershipsMembershipIdVariables
  >({
    mutationFn: (
      variables: DeletePhonebookAssociationsMembershipsMembershipIdVariables,
    ) =>
      fetchDeletePhonebookAssociationsMembershipsMembershipId({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type PostPhonebookAssociationsAssociationIdPicturePathParams = {
  associationId: string;
};

export type PostPhonebookAssociationsAssociationIdPictureError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type PostPhonebookAssociationsAssociationIdPictureVariables = {
  body: Schemas.BodyCreateAssociationLogoPhonebookAssociationsAssociationIdPicturePost;
  pathParams: PostPhonebookAssociationsAssociationIdPicturePathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Upload a logo for an Association.
 * **The user must be a member of the group CAA or BDE to use this endpoint**
 */
export const fetchPostPhonebookAssociationsAssociationIdPicture = (
  variables: PostPhonebookAssociationsAssociationIdPictureVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.AppCoreStandardResponsesResult,
    PostPhonebookAssociationsAssociationIdPictureError,
    Schemas.BodyCreateAssociationLogoPhonebookAssociationsAssociationIdPicturePost,
    {},
    {},
    PostPhonebookAssociationsAssociationIdPicturePathParams
  >({
    url: "/phonebook/associations/{associationId}/picture",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Upload a logo for an Association.
 * **The user must be a member of the group CAA or BDE to use this endpoint**
 */
export const usePostPhonebookAssociationsAssociationIdPicture = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.AppCoreStandardResponsesResult,
      PostPhonebookAssociationsAssociationIdPictureError,
      PostPhonebookAssociationsAssociationIdPictureVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.AppCoreStandardResponsesResult,
    PostPhonebookAssociationsAssociationIdPictureError,
    PostPhonebookAssociationsAssociationIdPictureVariables
  >({
    mutationFn: (
      variables: PostPhonebookAssociationsAssociationIdPictureVariables,
    ) =>
      fetchPostPhonebookAssociationsAssociationIdPicture({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type GetPhonebookAssociationsAssociationIdPicturePathParams = {
  associationId: string;
};

export type GetPhonebookAssociationsAssociationIdPictureError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type GetPhonebookAssociationsAssociationIdPictureVariables = {
  pathParams: GetPhonebookAssociationsAssociationIdPicturePathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Get the logo of an Association.
 */
export const fetchGetPhonebookAssociationsAssociationIdPicture = (
  variables: GetPhonebookAssociationsAssociationIdPictureVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    GetPhonebookAssociationsAssociationIdPictureError,
    undefined,
    {},
    {},
    GetPhonebookAssociationsAssociationIdPicturePathParams
  >({
    url: "/phonebook/associations/{associationId}/picture",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get the logo of an Association.
 */
export const useGetPhonebookAssociationsAssociationIdPicture = <
  TData = undefined,
>(
  variables: GetPhonebookAssociationsAssociationIdPictureVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      undefined,
      GetPhonebookAssociationsAssociationIdPictureError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<
    undefined,
    GetPhonebookAssociationsAssociationIdPictureError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/phonebook/associations/{associationId}/picture",
      operationId: "getPhonebookAssociationsAssociationIdPicture",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetPhonebookAssociationsAssociationIdPicture(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type GetTombolaRafflesError = Fetcher.ErrorWrapper<undefined>;

export type GetTombolaRafflesResponse = Schemas.RaffleComplete[];

export type GetTombolaRafflesVariables = HyperionContext["fetcherOptions"];

/**
 * Return all raffles
 */
export const fetchGetTombolaRaffles = (
  variables: GetTombolaRafflesVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetTombolaRafflesResponse,
    GetTombolaRafflesError,
    undefined,
    {},
    {},
    {}
  >({ url: "/tombola/raffles", method: "get", ...variables, signal });

/**
 * Return all raffles
 */
export const useGetTombolaRaffles = <TData = GetTombolaRafflesResponse,>(
  variables: GetTombolaRafflesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetTombolaRafflesResponse,
      GetTombolaRafflesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<
    GetTombolaRafflesResponse,
    GetTombolaRafflesError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/tombola/raffles",
      operationId: "getTombolaRaffles",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetTombolaRaffles({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type PostTombolaRafflesError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostTombolaRafflesVariables = {
  body: Schemas.RaffleBase;
} & HyperionContext["fetcherOptions"];

/**
 * Create a new raffle
 *
 * **The user must be a member of the group admin to use this endpoint**
 */
export const fetchPostTombolaRaffles = (
  variables: PostTombolaRafflesVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.RaffleComplete,
    PostTombolaRafflesError,
    Schemas.RaffleBase,
    {},
    {},
    {}
  >({ url: "/tombola/raffles", method: "post", ...variables, signal });

/**
 * Create a new raffle
 *
 * **The user must be a member of the group admin to use this endpoint**
 */
export const usePostTombolaRaffles = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.RaffleComplete,
      PostTombolaRafflesError,
      PostTombolaRafflesVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.RaffleComplete,
    PostTombolaRafflesError,
    PostTombolaRafflesVariables
  >({
    mutationFn: (variables: PostTombolaRafflesVariables) =>
      fetchPostTombolaRaffles({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type PatchTombolaRafflesRaffleIdPathParams = {
  raffleId: string;
};

export type PatchTombolaRafflesRaffleIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PatchTombolaRafflesRaffleIdVariables = {
  body?: Schemas.RaffleEdit;
  pathParams: PatchTombolaRafflesRaffleIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Edit a raffle
 *
 * **The user must be a member of the raffle's group to use this endpoint**
 */
export const fetchPatchTombolaRafflesRaffleId = (
  variables: PatchTombolaRafflesRaffleIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchTombolaRafflesRaffleIdError,
    Schemas.RaffleEdit,
    {},
    {},
    PatchTombolaRafflesRaffleIdPathParams
  >({
    url: "/tombola/raffles/{raffleId}",
    method: "patch",
    ...variables,
    signal,
  });

/**
 * Edit a raffle
 *
 * **The user must be a member of the raffle's group to use this endpoint**
 */
export const usePatchTombolaRafflesRaffleId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchTombolaRafflesRaffleIdError,
      PatchTombolaRafflesRaffleIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchTombolaRafflesRaffleIdError,
    PatchTombolaRafflesRaffleIdVariables
  >({
    mutationFn: (variables: PatchTombolaRafflesRaffleIdVariables) =>
      fetchPatchTombolaRafflesRaffleId({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type DeleteTombolaRafflesRaffleIdPathParams = {
  raffleId: string;
};

export type DeleteTombolaRafflesRaffleIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type DeleteTombolaRafflesRaffleIdVariables = {
  pathParams: DeleteTombolaRafflesRaffleIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Delete a raffle.
 *
 * **The user must be a member of the raffle's group to use this endpoint**
 */
export const fetchDeleteTombolaRafflesRaffleId = (
  variables: DeleteTombolaRafflesRaffleIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteTombolaRafflesRaffleIdError,
    undefined,
    {},
    {},
    DeleteTombolaRafflesRaffleIdPathParams
  >({
    url: "/tombola/raffles/{raffleId}",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * Delete a raffle.
 *
 * **The user must be a member of the raffle's group to use this endpoint**
 */
export const useDeleteTombolaRafflesRaffleId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteTombolaRafflesRaffleIdError,
      DeleteTombolaRafflesRaffleIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteTombolaRafflesRaffleIdError,
    DeleteTombolaRafflesRaffleIdVariables
  >({
    mutationFn: (variables: DeleteTombolaRafflesRaffleIdVariables) =>
      fetchDeleteTombolaRafflesRaffleId({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetTombolaGroupGroupIdRafflesPathParams = {
  groupId: string;
};

export type GetTombolaGroupGroupIdRafflesError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetTombolaGroupGroupIdRafflesResponse = Schemas.RaffleComplete[];

export type GetTombolaGroupGroupIdRafflesVariables = {
  pathParams: GetTombolaGroupGroupIdRafflesPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Return all raffles from a group
 */
export const fetchGetTombolaGroupGroupIdRaffles = (
  variables: GetTombolaGroupGroupIdRafflesVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetTombolaGroupGroupIdRafflesResponse,
    GetTombolaGroupGroupIdRafflesError,
    undefined,
    {},
    {},
    GetTombolaGroupGroupIdRafflesPathParams
  >({
    url: "/tombola/group/{groupId}/raffles",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Return all raffles from a group
 */
export const useGetTombolaGroupGroupIdRaffles = <
  TData = GetTombolaGroupGroupIdRafflesResponse,
>(
  variables: GetTombolaGroupGroupIdRafflesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetTombolaGroupGroupIdRafflesResponse,
      GetTombolaGroupGroupIdRafflesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<
    GetTombolaGroupGroupIdRafflesResponse,
    GetTombolaGroupGroupIdRafflesError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/tombola/group/{groupId}/raffles",
      operationId: "getTombolaGroupGroupIdRaffles",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetTombolaGroupGroupIdRaffles(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type GetTombolaRafflesRaffleIdStatsPathParams = {
  raffleId: string;
};

export type GetTombolaRafflesRaffleIdStatsError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetTombolaRafflesRaffleIdStatsVariables = {
  pathParams: GetTombolaRafflesRaffleIdStatsPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Return the number of ticket sold and the total amount recollected for a raffle
 */
export const fetchGetTombolaRafflesRaffleIdStats = (
  variables: GetTombolaRafflesRaffleIdStatsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.RaffleStats,
    GetTombolaRafflesRaffleIdStatsError,
    undefined,
    {},
    {},
    GetTombolaRafflesRaffleIdStatsPathParams
  >({
    url: "/tombola/raffles/{raffleId}/stats",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Return the number of ticket sold and the total amount recollected for a raffle
 */
export const useGetTombolaRafflesRaffleIdStats = <TData = Schemas.RaffleStats,>(
  variables: GetTombolaRafflesRaffleIdStatsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.RaffleStats,
      GetTombolaRafflesRaffleIdStatsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<
    Schemas.RaffleStats,
    GetTombolaRafflesRaffleIdStatsError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/tombola/raffles/{raffleId}/stats",
      operationId: "getTombolaRafflesRaffleIdStats",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetTombolaRafflesRaffleIdStats(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type PostTombolaRafflesRaffleIdLogoPathParams = {
  raffleId: string;
};

export type PostTombolaRafflesRaffleIdLogoError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostTombolaRafflesRaffleIdLogoVariables = {
  body: Schemas.BodyCreateCurrentRaffleLogoTombolaRafflesRaffleIdLogoPost;
  pathParams: PostTombolaRafflesRaffleIdLogoPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Upload a logo for a specific raffle.
 *
 * **The user must be a member of the raffle's group to use this endpoint**
 */
export const fetchPostTombolaRafflesRaffleIdLogo = (
  variables: PostTombolaRafflesRaffleIdLogoVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.AppCoreStandardResponsesResult,
    PostTombolaRafflesRaffleIdLogoError,
    Schemas.BodyCreateCurrentRaffleLogoTombolaRafflesRaffleIdLogoPost,
    {},
    {},
    PostTombolaRafflesRaffleIdLogoPathParams
  >({
    url: "/tombola/raffles/{raffleId}/logo",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Upload a logo for a specific raffle.
 *
 * **The user must be a member of the raffle's group to use this endpoint**
 */
export const usePostTombolaRafflesRaffleIdLogo = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.AppCoreStandardResponsesResult,
      PostTombolaRafflesRaffleIdLogoError,
      PostTombolaRafflesRaffleIdLogoVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.AppCoreStandardResponsesResult,
    PostTombolaRafflesRaffleIdLogoError,
    PostTombolaRafflesRaffleIdLogoVariables
  >({
    mutationFn: (variables: PostTombolaRafflesRaffleIdLogoVariables) =>
      fetchPostTombolaRafflesRaffleIdLogo({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetTombolaRafflesRaffleIdLogoPathParams = {
  raffleId: string;
};

export type GetTombolaRafflesRaffleIdLogoError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetTombolaRafflesRaffleIdLogoVariables = {
  pathParams: GetTombolaRafflesRaffleIdLogoPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Get the logo of a specific raffle.
 */
export const fetchGetTombolaRafflesRaffleIdLogo = (
  variables: GetTombolaRafflesRaffleIdLogoVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    GetTombolaRafflesRaffleIdLogoError,
    undefined,
    {},
    {},
    GetTombolaRafflesRaffleIdLogoPathParams
  >({
    url: "/tombola/raffles/{raffleId}/logo",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get the logo of a specific raffle.
 */
export const useGetTombolaRafflesRaffleIdLogo = <TData = undefined,>(
  variables: GetTombolaRafflesRaffleIdLogoVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      undefined,
      GetTombolaRafflesRaffleIdLogoError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<
    undefined,
    GetTombolaRafflesRaffleIdLogoError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/tombola/raffles/{raffleId}/logo",
      operationId: "getTombolaRafflesRaffleIdLogo",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetTombolaRafflesRaffleIdLogo(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type GetTombolaPackTicketsError = Fetcher.ErrorWrapper<undefined>;

export type GetTombolaPackTicketsResponse = Schemas.PackTicketSimple[];

export type GetTombolaPackTicketsVariables = HyperionContext["fetcherOptions"];

/**
 * Return all tickets
 */
export const fetchGetTombolaPackTickets = (
  variables: GetTombolaPackTicketsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetTombolaPackTicketsResponse,
    GetTombolaPackTicketsError,
    undefined,
    {},
    {},
    {}
  >({ url: "/tombola/pack_tickets", method: "get", ...variables, signal });

/**
 * Return all tickets
 */
export const useGetTombolaPackTickets = <
  TData = GetTombolaPackTicketsResponse,
>(
  variables: GetTombolaPackTicketsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetTombolaPackTicketsResponse,
      GetTombolaPackTicketsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<
    GetTombolaPackTicketsResponse,
    GetTombolaPackTicketsError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/tombola/pack_tickets",
      operationId: "getTombolaPackTickets",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetTombolaPackTickets({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type PostTombolaPackTicketsError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostTombolaPackTicketsVariables = {
  body: Schemas.PackTicketBase;
} & HyperionContext["fetcherOptions"];

/**
 * Create a new packticket
 *
 * **The user must be a member of the raffle's group to use this endpoint**
 */
export const fetchPostTombolaPackTickets = (
  variables: PostTombolaPackTicketsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.PackTicketSimple,
    PostTombolaPackTicketsError,
    Schemas.PackTicketBase,
    {},
    {},
    {}
  >({ url: "/tombola/pack_tickets", method: "post", ...variables, signal });

/**
 * Create a new packticket
 *
 * **The user must be a member of the raffle's group to use this endpoint**
 */
export const usePostTombolaPackTickets = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.PackTicketSimple,
      PostTombolaPackTicketsError,
      PostTombolaPackTicketsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.PackTicketSimple,
    PostTombolaPackTicketsError,
    PostTombolaPackTicketsVariables
  >({
    mutationFn: (variables: PostTombolaPackTicketsVariables) =>
      fetchPostTombolaPackTickets({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type PatchTombolaPackTicketsPackticketIdPathParams = {
  packticketId: string;
};

export type PatchTombolaPackTicketsPackticketIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PatchTombolaPackTicketsPackticketIdVariables = {
  body?: Schemas.PackTicketEdit;
  pathParams: PatchTombolaPackTicketsPackticketIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Edit a packticket
 *
 * **The user must be a member of the raffle's group to use this endpoint**
 */
export const fetchPatchTombolaPackTicketsPackticketId = (
  variables: PatchTombolaPackTicketsPackticketIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchTombolaPackTicketsPackticketIdError,
    Schemas.PackTicketEdit,
    {},
    {},
    PatchTombolaPackTicketsPackticketIdPathParams
  >({
    url: "/tombola/pack_tickets/{packticketId}",
    method: "patch",
    ...variables,
    signal,
  });

/**
 * Edit a packticket
 *
 * **The user must be a member of the raffle's group to use this endpoint**
 */
export const usePatchTombolaPackTicketsPackticketId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchTombolaPackTicketsPackticketIdError,
      PatchTombolaPackTicketsPackticketIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchTombolaPackTicketsPackticketIdError,
    PatchTombolaPackTicketsPackticketIdVariables
  >({
    mutationFn: (variables: PatchTombolaPackTicketsPackticketIdVariables) =>
      fetchPatchTombolaPackTicketsPackticketId({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type DeleteTombolaPackTicketsPackticketIdPathParams = {
  packticketId: string;
};

export type DeleteTombolaPackTicketsPackticketIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type DeleteTombolaPackTicketsPackticketIdVariables = {
  pathParams: DeleteTombolaPackTicketsPackticketIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Delete a packticket.
 *
 * **The user must be a member of the raffle's group to use this endpoint**
 */
export const fetchDeleteTombolaPackTicketsPackticketId = (
  variables: DeleteTombolaPackTicketsPackticketIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteTombolaPackTicketsPackticketIdError,
    undefined,
    {},
    {},
    DeleteTombolaPackTicketsPackticketIdPathParams
  >({
    url: "/tombola/pack_tickets/{packticketId}",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * Delete a packticket.
 *
 * **The user must be a member of the raffle's group to use this endpoint**
 */
export const useDeleteTombolaPackTicketsPackticketId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteTombolaPackTicketsPackticketIdError,
      DeleteTombolaPackTicketsPackticketIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteTombolaPackTicketsPackticketIdError,
    DeleteTombolaPackTicketsPackticketIdVariables
  >({
    mutationFn: (variables: DeleteTombolaPackTicketsPackticketIdVariables) =>
      fetchDeleteTombolaPackTicketsPackticketId({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type GetTombolaRafflesRaffleIdPackTicketsPathParams = {
  raffleId: string;
};

export type GetTombolaRafflesRaffleIdPackTicketsError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetTombolaRafflesRaffleIdPackTicketsResponse =
  Schemas.PackTicketSimple[];

export type GetTombolaRafflesRaffleIdPackTicketsVariables = {
  pathParams: GetTombolaRafflesRaffleIdPackTicketsPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Return all pack_tickets associated to a raffle
 */
export const fetchGetTombolaRafflesRaffleIdPackTickets = (
  variables: GetTombolaRafflesRaffleIdPackTicketsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetTombolaRafflesRaffleIdPackTicketsResponse,
    GetTombolaRafflesRaffleIdPackTicketsError,
    undefined,
    {},
    {},
    GetTombolaRafflesRaffleIdPackTicketsPathParams
  >({
    url: "/tombola/raffles/{raffleId}/pack_tickets",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Return all pack_tickets associated to a raffle
 */
export const useGetTombolaRafflesRaffleIdPackTickets = <
  TData = GetTombolaRafflesRaffleIdPackTicketsResponse,
>(
  variables: GetTombolaRafflesRaffleIdPackTicketsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetTombolaRafflesRaffleIdPackTicketsResponse,
      GetTombolaRafflesRaffleIdPackTicketsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<
    GetTombolaRafflesRaffleIdPackTicketsResponse,
    GetTombolaRafflesRaffleIdPackTicketsError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/tombola/raffles/{raffleId}/pack_tickets",
      operationId: "getTombolaRafflesRaffleIdPackTickets",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetTombolaRafflesRaffleIdPackTickets(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type GetTombolaTicketsError = Fetcher.ErrorWrapper<undefined>;

export type GetTombolaTicketsResponse = Schemas.TicketSimple[];

export type GetTombolaTicketsVariables = HyperionContext["fetcherOptions"];

/**
 * Return all tickets
 *
 * **The user must be a member of the group admin to use this endpoint**
 */
export const fetchGetTombolaTickets = (
  variables: GetTombolaTicketsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetTombolaTicketsResponse,
    GetTombolaTicketsError,
    undefined,
    {},
    {},
    {}
  >({ url: "/tombola/tickets", method: "get", ...variables, signal });

/**
 * Return all tickets
 *
 * **The user must be a member of the group admin to use this endpoint**
 */
export const useGetTombolaTickets = <TData = GetTombolaTicketsResponse,>(
  variables: GetTombolaTicketsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetTombolaTicketsResponse,
      GetTombolaTicketsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<
    GetTombolaTicketsResponse,
    GetTombolaTicketsError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/tombola/tickets",
      operationId: "getTombolaTickets",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetTombolaTickets({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type PostTombolaTicketsBuyPackIdPathParams = {
  packId: string;
};

export type PostTombolaTicketsBuyPackIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostTombolaTicketsBuyPackIdResponse = Schemas.TicketComplete[];

export type PostTombolaTicketsBuyPackIdVariables = {
  pathParams: PostTombolaTicketsBuyPackIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Buy a ticket
 */
export const fetchPostTombolaTicketsBuyPackId = (
  variables: PostTombolaTicketsBuyPackIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    PostTombolaTicketsBuyPackIdResponse,
    PostTombolaTicketsBuyPackIdError,
    undefined,
    {},
    {},
    PostTombolaTicketsBuyPackIdPathParams
  >({
    url: "/tombola/tickets/buy/{packId}",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Buy a ticket
 */
export const usePostTombolaTicketsBuyPackId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      PostTombolaTicketsBuyPackIdResponse,
      PostTombolaTicketsBuyPackIdError,
      PostTombolaTicketsBuyPackIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    PostTombolaTicketsBuyPackIdResponse,
    PostTombolaTicketsBuyPackIdError,
    PostTombolaTicketsBuyPackIdVariables
  >({
    mutationFn: (variables: PostTombolaTicketsBuyPackIdVariables) =>
      fetchPostTombolaTicketsBuyPackId({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetTombolaUsersUserIdTicketsPathParams = {
  userId: string;
};

export type GetTombolaUsersUserIdTicketsError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetTombolaUsersUserIdTicketsResponse = Schemas.TicketComplete[];

export type GetTombolaUsersUserIdTicketsVariables = {
  pathParams: GetTombolaUsersUserIdTicketsPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Get tickets of a specific user.
 *
 * **Only admin users can get tickets of another user**
 */
export const fetchGetTombolaUsersUserIdTickets = (
  variables: GetTombolaUsersUserIdTicketsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetTombolaUsersUserIdTicketsResponse,
    GetTombolaUsersUserIdTicketsError,
    undefined,
    {},
    {},
    GetTombolaUsersUserIdTicketsPathParams
  >({
    url: "/tombola/users/{userId}/tickets",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get tickets of a specific user.
 *
 * **Only admin users can get tickets of another user**
 */
export const useGetTombolaUsersUserIdTickets = <
  TData = GetTombolaUsersUserIdTicketsResponse,
>(
  variables: GetTombolaUsersUserIdTicketsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetTombolaUsersUserIdTicketsResponse,
      GetTombolaUsersUserIdTicketsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<
    GetTombolaUsersUserIdTicketsResponse,
    GetTombolaUsersUserIdTicketsError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/tombola/users/{userId}/tickets",
      operationId: "getTombolaUsersUserIdTickets",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetTombolaUsersUserIdTickets(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type GetTombolaRafflesRaffleIdTicketsPathParams = {
  raffleId: string;
};

export type GetTombolaRafflesRaffleIdTicketsError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetTombolaRafflesRaffleIdTicketsResponse = Schemas.TicketComplete[];

export type GetTombolaRafflesRaffleIdTicketsVariables = {
  pathParams: GetTombolaRafflesRaffleIdTicketsPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Get tickets from a specific raffle.
 *
 * **The user must be a member of the raffle's group to use this endpoint
 */
export const fetchGetTombolaRafflesRaffleIdTickets = (
  variables: GetTombolaRafflesRaffleIdTicketsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetTombolaRafflesRaffleIdTicketsResponse,
    GetTombolaRafflesRaffleIdTicketsError,
    undefined,
    {},
    {},
    GetTombolaRafflesRaffleIdTicketsPathParams
  >({
    url: "/tombola/raffles/{raffleId}/tickets",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get tickets from a specific raffle.
 *
 * **The user must be a member of the raffle's group to use this endpoint
 */
export const useGetTombolaRafflesRaffleIdTickets = <
  TData = GetTombolaRafflesRaffleIdTicketsResponse,
>(
  variables: GetTombolaRafflesRaffleIdTicketsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetTombolaRafflesRaffleIdTicketsResponse,
      GetTombolaRafflesRaffleIdTicketsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<
    GetTombolaRafflesRaffleIdTicketsResponse,
    GetTombolaRafflesRaffleIdTicketsError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/tombola/raffles/{raffleId}/tickets",
      operationId: "getTombolaRafflesRaffleIdTickets",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetTombolaRafflesRaffleIdTickets(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type GetTombolaPrizesError = Fetcher.ErrorWrapper<undefined>;

export type GetTombolaPrizesResponse = Schemas.PrizeSimple[];

export type GetTombolaPrizesVariables = HyperionContext["fetcherOptions"];

/**
 * Return all prizes
 */
export const fetchGetTombolaPrizes = (
  variables: GetTombolaPrizesVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetTombolaPrizesResponse,
    GetTombolaPrizesError,
    undefined,
    {},
    {},
    {}
  >({ url: "/tombola/prizes", method: "get", ...variables, signal });

/**
 * Return all prizes
 */
export const useGetTombolaPrizes = <TData = GetTombolaPrizesResponse,>(
  variables: GetTombolaPrizesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetTombolaPrizesResponse,
      GetTombolaPrizesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<
    GetTombolaPrizesResponse,
    GetTombolaPrizesError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/tombola/prizes",
      operationId: "getTombolaPrizes",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetTombolaPrizes({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type PostTombolaPrizesError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostTombolaPrizesVariables = {
  body: Schemas.PrizeBase;
} & HyperionContext["fetcherOptions"];

/**
 * Create a new prize
 *
 * **The user must be a member of the raffle's group to use this endpoint
 */
export const fetchPostTombolaPrizes = (
  variables: PostTombolaPrizesVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.PrizeSimple,
    PostTombolaPrizesError,
    Schemas.PrizeBase,
    {},
    {},
    {}
  >({ url: "/tombola/prizes", method: "post", ...variables, signal });

/**
 * Create a new prize
 *
 * **The user must be a member of the raffle's group to use this endpoint
 */
export const usePostTombolaPrizes = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.PrizeSimple,
      PostTombolaPrizesError,
      PostTombolaPrizesVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.PrizeSimple,
    PostTombolaPrizesError,
    PostTombolaPrizesVariables
  >({
    mutationFn: (variables: PostTombolaPrizesVariables) =>
      fetchPostTombolaPrizes({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type PatchTombolaPrizesPrizeIdPathParams = {
  prizeId: string;
};

export type PatchTombolaPrizesPrizeIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PatchTombolaPrizesPrizeIdVariables = {
  body?: Schemas.PrizeEdit;
  pathParams: PatchTombolaPrizesPrizeIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Edit a prize
 *
 * **The user must be a member of the group raffle's to use this endpoint
 */
export const fetchPatchTombolaPrizesPrizeId = (
  variables: PatchTombolaPrizesPrizeIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchTombolaPrizesPrizeIdError,
    Schemas.PrizeEdit,
    {},
    {},
    PatchTombolaPrizesPrizeIdPathParams
  >({
    url: "/tombola/prizes/{prizeId}",
    method: "patch",
    ...variables,
    signal,
  });

/**
 * Edit a prize
 *
 * **The user must be a member of the group raffle's to use this endpoint
 */
export const usePatchTombolaPrizesPrizeId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchTombolaPrizesPrizeIdError,
      PatchTombolaPrizesPrizeIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchTombolaPrizesPrizeIdError,
    PatchTombolaPrizesPrizeIdVariables
  >({
    mutationFn: (variables: PatchTombolaPrizesPrizeIdVariables) =>
      fetchPatchTombolaPrizesPrizeId({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type DeleteTombolaPrizesPrizeIdPathParams = {
  prizeId: string;
};

export type DeleteTombolaPrizesPrizeIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type DeleteTombolaPrizesPrizeIdVariables = {
  pathParams: DeleteTombolaPrizesPrizeIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Delete a prize.
 *
 * **The user must be a member of the group raffle's to use this endpoint
 */
export const fetchDeleteTombolaPrizesPrizeId = (
  variables: DeleteTombolaPrizesPrizeIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteTombolaPrizesPrizeIdError,
    undefined,
    {},
    {},
    DeleteTombolaPrizesPrizeIdPathParams
  >({
    url: "/tombola/prizes/{prizeId}",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * Delete a prize.
 *
 * **The user must be a member of the group raffle's to use this endpoint
 */
export const useDeleteTombolaPrizesPrizeId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteTombolaPrizesPrizeIdError,
      DeleteTombolaPrizesPrizeIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteTombolaPrizesPrizeIdError,
    DeleteTombolaPrizesPrizeIdVariables
  >({
    mutationFn: (variables: DeleteTombolaPrizesPrizeIdVariables) =>
      fetchDeleteTombolaPrizesPrizeId({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetTombolaRafflesRaffleIdPrizesPathParams = {
  raffleId: string;
};

export type GetTombolaRafflesRaffleIdPrizesError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetTombolaRafflesRaffleIdPrizesResponse = Schemas.PrizeSimple[];

export type GetTombolaRafflesRaffleIdPrizesVariables = {
  pathParams: GetTombolaRafflesRaffleIdPrizesPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Get prizes from a specific raffle.
 */
export const fetchGetTombolaRafflesRaffleIdPrizes = (
  variables: GetTombolaRafflesRaffleIdPrizesVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetTombolaRafflesRaffleIdPrizesResponse,
    GetTombolaRafflesRaffleIdPrizesError,
    undefined,
    {},
    {},
    GetTombolaRafflesRaffleIdPrizesPathParams
  >({
    url: "/tombola/raffles/{raffleId}/prizes",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get prizes from a specific raffle.
 */
export const useGetTombolaRafflesRaffleIdPrizes = <
  TData = GetTombolaRafflesRaffleIdPrizesResponse,
>(
  variables: GetTombolaRafflesRaffleIdPrizesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetTombolaRafflesRaffleIdPrizesResponse,
      GetTombolaRafflesRaffleIdPrizesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<
    GetTombolaRafflesRaffleIdPrizesResponse,
    GetTombolaRafflesRaffleIdPrizesError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/tombola/raffles/{raffleId}/prizes",
      operationId: "getTombolaRafflesRaffleIdPrizes",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetTombolaRafflesRaffleIdPrizes(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type PostTombolaPrizesPrizeIdPicturePathParams = {
  prizeId: string;
};

export type PostTombolaPrizesPrizeIdPictureError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostTombolaPrizesPrizeIdPictureVariables = {
  body: Schemas.BodyCreatePrizePictureTombolaPrizesPrizeIdPicturePost;
  pathParams: PostTombolaPrizesPrizeIdPicturePathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Upload a logo for a specific prize.
 *
 * **The user must be a member of the raffle's group to use this endpoint**
 */
export const fetchPostTombolaPrizesPrizeIdPicture = (
  variables: PostTombolaPrizesPrizeIdPictureVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.AppCoreStandardResponsesResult,
    PostTombolaPrizesPrizeIdPictureError,
    Schemas.BodyCreatePrizePictureTombolaPrizesPrizeIdPicturePost,
    {},
    {},
    PostTombolaPrizesPrizeIdPicturePathParams
  >({
    url: "/tombola/prizes/{prizeId}/picture",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Upload a logo for a specific prize.
 *
 * **The user must be a member of the raffle's group to use this endpoint**
 */
export const usePostTombolaPrizesPrizeIdPicture = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.AppCoreStandardResponsesResult,
      PostTombolaPrizesPrizeIdPictureError,
      PostTombolaPrizesPrizeIdPictureVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.AppCoreStandardResponsesResult,
    PostTombolaPrizesPrizeIdPictureError,
    PostTombolaPrizesPrizeIdPictureVariables
  >({
    mutationFn: (variables: PostTombolaPrizesPrizeIdPictureVariables) =>
      fetchPostTombolaPrizesPrizeIdPicture({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetTombolaPrizesPrizeIdPicturePathParams = {
  prizeId: string;
};

export type GetTombolaPrizesPrizeIdPictureError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetTombolaPrizesPrizeIdPictureVariables = {
  pathParams: GetTombolaPrizesPrizeIdPicturePathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Get the logo of a specific prize.
 */
export const fetchGetTombolaPrizesPrizeIdPicture = (
  variables: GetTombolaPrizesPrizeIdPictureVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    GetTombolaPrizesPrizeIdPictureError,
    undefined,
    {},
    {},
    GetTombolaPrizesPrizeIdPicturePathParams
  >({
    url: "/tombola/prizes/{prizeId}/picture",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get the logo of a specific prize.
 */
export const useGetTombolaPrizesPrizeIdPicture = <TData = undefined,>(
  variables: GetTombolaPrizesPrizeIdPictureVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      undefined,
      GetTombolaPrizesPrizeIdPictureError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<
    undefined,
    GetTombolaPrizesPrizeIdPictureError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/tombola/prizes/{prizeId}/picture",
      operationId: "getTombolaPrizesPrizeIdPicture",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetTombolaPrizesPrizeIdPicture(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type GetTombolaUsersCashError = Fetcher.ErrorWrapper<undefined>;

export type GetTombolaUsersCashResponse = Schemas.CashComplete[];

export type GetTombolaUsersCashVariables = HyperionContext["fetcherOptions"];

/**
 * Get cash from all users.
 *
 * **The user must be a member of the group admin to use this endpoint
 */
export const fetchGetTombolaUsersCash = (
  variables: GetTombolaUsersCashVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetTombolaUsersCashResponse,
    GetTombolaUsersCashError,
    undefined,
    {},
    {},
    {}
  >({ url: "/tombola/users/cash", method: "get", ...variables, signal });

/**
 * Get cash from all users.
 *
 * **The user must be a member of the group admin to use this endpoint
 */
export const useGetTombolaUsersCash = <TData = GetTombolaUsersCashResponse,>(
  variables: GetTombolaUsersCashVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetTombolaUsersCashResponse,
      GetTombolaUsersCashError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<
    GetTombolaUsersCashResponse,
    GetTombolaUsersCashError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/tombola/users/cash",
      operationId: "getTombolaUsersCash",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetTombolaUsersCash({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type GetTombolaUsersUserIdCashPathParams = {
  userId: string;
};

export type GetTombolaUsersUserIdCashError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetTombolaUsersUserIdCashVariables = {
  pathParams: GetTombolaUsersUserIdCashPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Get cash from a specific user.
 *
 * **The user must be a member of the group admin to use this endpoint or can only access the endpoint for its own user_id**
 */
export const fetchGetTombolaUsersUserIdCash = (
  variables: GetTombolaUsersUserIdCashVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.CashComplete,
    GetTombolaUsersUserIdCashError,
    undefined,
    {},
    {},
    GetTombolaUsersUserIdCashPathParams
  >({
    url: "/tombola/users/{userId}/cash",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get cash from a specific user.
 *
 * **The user must be a member of the group admin to use this endpoint or can only access the endpoint for its own user_id**
 */
export const useGetTombolaUsersUserIdCash = <TData = Schemas.CashComplete,>(
  variables: GetTombolaUsersUserIdCashVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.CashComplete,
      GetTombolaUsersUserIdCashError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<
    Schemas.CashComplete,
    GetTombolaUsersUserIdCashError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/tombola/users/{userId}/cash",
      operationId: "getTombolaUsersUserIdCash",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetTombolaUsersUserIdCash(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type PostTombolaUsersUserIdCashPathParams = {
  userId: string;
};

export type PostTombolaUsersUserIdCashError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostTombolaUsersUserIdCashVariables = {
  body: Schemas.CashEdit;
  pathParams: PostTombolaUsersUserIdCashPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Create cash for a user.
 *
 * **The user must be a member of the group admin to use this endpoint**
 */
export const fetchPostTombolaUsersUserIdCash = (
  variables: PostTombolaUsersUserIdCashVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.CashComplete,
    PostTombolaUsersUserIdCashError,
    Schemas.CashEdit,
    {},
    {},
    PostTombolaUsersUserIdCashPathParams
  >({
    url: "/tombola/users/{userId}/cash",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Create cash for a user.
 *
 * **The user must be a member of the group admin to use this endpoint**
 */
export const usePostTombolaUsersUserIdCash = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.CashComplete,
      PostTombolaUsersUserIdCashError,
      PostTombolaUsersUserIdCashVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.CashComplete,
    PostTombolaUsersUserIdCashError,
    PostTombolaUsersUserIdCashVariables
  >({
    mutationFn: (variables: PostTombolaUsersUserIdCashVariables) =>
      fetchPostTombolaUsersUserIdCash({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type PatchTombolaUsersUserIdCashPathParams = {
  userId: string;
};

export type PatchTombolaUsersUserIdCashError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PatchTombolaUsersUserIdCashVariables = {
  body: Schemas.CashEdit;
  pathParams: PatchTombolaUsersUserIdCashPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Edit cash for an user. This will add the balance to the current balance.
 * A negative value can be provided to remove money from the user.
 *
 * **The user must be a member of the group admin to use this endpoint**
 */
export const fetchPatchTombolaUsersUserIdCash = (
  variables: PatchTombolaUsersUserIdCashVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchTombolaUsersUserIdCashError,
    Schemas.CashEdit,
    {},
    {},
    PatchTombolaUsersUserIdCashPathParams
  >({
    url: "/tombola/users/{userId}/cash",
    method: "patch",
    ...variables,
    signal,
  });

/**
 * Edit cash for an user. This will add the balance to the current balance.
 * A negative value can be provided to remove money from the user.
 *
 * **The user must be a member of the group admin to use this endpoint**
 */
export const usePatchTombolaUsersUserIdCash = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchTombolaUsersUserIdCashError,
      PatchTombolaUsersUserIdCashVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchTombolaUsersUserIdCashError,
    PatchTombolaUsersUserIdCashVariables
  >({
    mutationFn: (variables: PatchTombolaUsersUserIdCashVariables) =>
      fetchPatchTombolaUsersUserIdCash({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type PostTombolaPrizesPrizeIdDrawPathParams = {
  prizeId: string;
};

export type PostTombolaPrizesPrizeIdDrawError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostTombolaPrizesPrizeIdDrawResponse = Schemas.TicketComplete[];

export type PostTombolaPrizesPrizeIdDrawVariables = {
  pathParams: PostTombolaPrizesPrizeIdDrawPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchPostTombolaPrizesPrizeIdDraw = (
  variables: PostTombolaPrizesPrizeIdDrawVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    PostTombolaPrizesPrizeIdDrawResponse,
    PostTombolaPrizesPrizeIdDrawError,
    undefined,
    {},
    {},
    PostTombolaPrizesPrizeIdDrawPathParams
  >({
    url: "/tombola/prizes/{prizeId}/draw",
    method: "post",
    ...variables,
    signal,
  });

export const usePostTombolaPrizesPrizeIdDraw = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      PostTombolaPrizesPrizeIdDrawResponse,
      PostTombolaPrizesPrizeIdDrawError,
      PostTombolaPrizesPrizeIdDrawVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    PostTombolaPrizesPrizeIdDrawResponse,
    PostTombolaPrizesPrizeIdDrawError,
    PostTombolaPrizesPrizeIdDrawVariables
  >({
    mutationFn: (variables: PostTombolaPrizesPrizeIdDrawVariables) =>
      fetchPostTombolaPrizesPrizeIdDraw({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type PatchTombolaRafflesRaffleIdOpenPathParams = {
  raffleId: string;
};

export type PatchTombolaRafflesRaffleIdOpenError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PatchTombolaRafflesRaffleIdOpenVariables = {
  pathParams: PatchTombolaRafflesRaffleIdOpenPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Open a raffle
 *
 * **The user must be a member of the raffle's group to use this endpoint**
 */
export const fetchPatchTombolaRafflesRaffleIdOpen = (
  variables: PatchTombolaRafflesRaffleIdOpenVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchTombolaRafflesRaffleIdOpenError,
    undefined,
    {},
    {},
    PatchTombolaRafflesRaffleIdOpenPathParams
  >({
    url: "/tombola/raffles/{raffleId}/open",
    method: "patch",
    ...variables,
    signal,
  });

/**
 * Open a raffle
 *
 * **The user must be a member of the raffle's group to use this endpoint**
 */
export const usePatchTombolaRafflesRaffleIdOpen = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchTombolaRafflesRaffleIdOpenError,
      PatchTombolaRafflesRaffleIdOpenVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchTombolaRafflesRaffleIdOpenError,
    PatchTombolaRafflesRaffleIdOpenVariables
  >({
    mutationFn: (variables: PatchTombolaRafflesRaffleIdOpenVariables) =>
      fetchPatchTombolaRafflesRaffleIdOpen({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type PatchTombolaRafflesRaffleIdLockPathParams = {
  raffleId: string;
};

export type PatchTombolaRafflesRaffleIdLockError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PatchTombolaRafflesRaffleIdLockVariables = {
  pathParams: PatchTombolaRafflesRaffleIdLockPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Lock a raffle
 *
 * **The user must be a member of the raffle's group to use this endpoint**
 */
export const fetchPatchTombolaRafflesRaffleIdLock = (
  variables: PatchTombolaRafflesRaffleIdLockVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchTombolaRafflesRaffleIdLockError,
    undefined,
    {},
    {},
    PatchTombolaRafflesRaffleIdLockPathParams
  >({
    url: "/tombola/raffles/{raffleId}/lock",
    method: "patch",
    ...variables,
    signal,
  });

/**
 * Lock a raffle
 *
 * **The user must be a member of the raffle's group to use this endpoint**
 */
export const usePatchTombolaRafflesRaffleIdLock = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchTombolaRafflesRaffleIdLockError,
      PatchTombolaRafflesRaffleIdLockVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchTombolaRafflesRaffleIdLockError,
    PatchTombolaRafflesRaffleIdLockVariables
  >({
    mutationFn: (variables: PatchTombolaRafflesRaffleIdLockVariables) =>
      fetchPatchTombolaRafflesRaffleIdLock({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetRecommendationRecommendationsError =
  Fetcher.ErrorWrapper<undefined>;

export type GetRecommendationRecommendationsResponse = Schemas.Recommendation[];

export type GetRecommendationRecommendationsVariables =
  HyperionContext["fetcherOptions"];

/**
 * Get recommendations.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const fetchGetRecommendationRecommendations = (
  variables: GetRecommendationRecommendationsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetRecommendationRecommendationsResponse,
    GetRecommendationRecommendationsError,
    undefined,
    {},
    {},
    {}
  >({
    url: "/recommendation/recommendations",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get recommendations.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const useGetRecommendationRecommendations = <
  TData = GetRecommendationRecommendationsResponse,
>(
  variables: GetRecommendationRecommendationsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetRecommendationRecommendationsResponse,
      GetRecommendationRecommendationsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<
    GetRecommendationRecommendationsResponse,
    GetRecommendationRecommendationsError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/recommendation/recommendations",
      operationId: "getRecommendationRecommendations",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetRecommendationRecommendations(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type PostRecommendationRecommendationsError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostRecommendationRecommendationsVariables = {
  body: Schemas.RecommendationBase;
} & HyperionContext["fetcherOptions"];

/**
 * Create a recommendation.
 *
 * **This endpoint is only usable by members of the group BDE**
 */
export const fetchPostRecommendationRecommendations = (
  variables: PostRecommendationRecommendationsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.Recommendation,
    PostRecommendationRecommendationsError,
    Schemas.RecommendationBase,
    {},
    {},
    {}
  >({
    url: "/recommendation/recommendations",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Create a recommendation.
 *
 * **This endpoint is only usable by members of the group BDE**
 */
export const usePostRecommendationRecommendations = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.Recommendation,
      PostRecommendationRecommendationsError,
      PostRecommendationRecommendationsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.Recommendation,
    PostRecommendationRecommendationsError,
    PostRecommendationRecommendationsVariables
  >({
    mutationFn: (variables: PostRecommendationRecommendationsVariables) =>
      fetchPostRecommendationRecommendations({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type PatchRecommendationRecommendationsRecommendationIdPathParams = {
  /**
   * @format uuid
   */
  recommendationId: string;
};

export type PatchRecommendationRecommendationsRecommendationIdError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type PatchRecommendationRecommendationsRecommendationIdVariables = {
  body?: Schemas.RecommendationEdit;
  pathParams: PatchRecommendationRecommendationsRecommendationIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Edit a recommendation.
 *
 * **This endpoint is only usable by members of the group BDE**
 */
export const fetchPatchRecommendationRecommendationsRecommendationId = (
  variables: PatchRecommendationRecommendationsRecommendationIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchRecommendationRecommendationsRecommendationIdError,
    Schemas.RecommendationEdit,
    {},
    {},
    PatchRecommendationRecommendationsRecommendationIdPathParams
  >({
    url: "/recommendation/recommendations/{recommendationId}",
    method: "patch",
    ...variables,
    signal,
  });

/**
 * Edit a recommendation.
 *
 * **This endpoint is only usable by members of the group BDE**
 */
export const usePatchRecommendationRecommendationsRecommendationId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchRecommendationRecommendationsRecommendationIdError,
      PatchRecommendationRecommendationsRecommendationIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchRecommendationRecommendationsRecommendationIdError,
    PatchRecommendationRecommendationsRecommendationIdVariables
  >({
    mutationFn: (
      variables: PatchRecommendationRecommendationsRecommendationIdVariables,
    ) =>
      fetchPatchRecommendationRecommendationsRecommendationId({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type DeleteRecommendationRecommendationsRecommendationIdPathParams = {
  /**
   * @format uuid
   */
  recommendationId: string;
};

export type DeleteRecommendationRecommendationsRecommendationIdError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type DeleteRecommendationRecommendationsRecommendationIdVariables = {
  pathParams: DeleteRecommendationRecommendationsRecommendationIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Delete a recommendation.
 *
 * **This endpoint is only usable by members of the group BDE**
 */
export const fetchDeleteRecommendationRecommendationsRecommendationId = (
  variables: DeleteRecommendationRecommendationsRecommendationIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteRecommendationRecommendationsRecommendationIdError,
    undefined,
    {},
    {},
    DeleteRecommendationRecommendationsRecommendationIdPathParams
  >({
    url: "/recommendation/recommendations/{recommendationId}",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * Delete a recommendation.
 *
 * **This endpoint is only usable by members of the group BDE**
 */
export const useDeleteRecommendationRecommendationsRecommendationId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteRecommendationRecommendationsRecommendationIdError,
      DeleteRecommendationRecommendationsRecommendationIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteRecommendationRecommendationsRecommendationIdError,
    DeleteRecommendationRecommendationsRecommendationIdVariables
  >({
    mutationFn: (
      variables: DeleteRecommendationRecommendationsRecommendationIdVariables,
    ) =>
      fetchDeleteRecommendationRecommendationsRecommendationId({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type GetRecommendationRecommendationsRecommendationIdPicturePathParams =
  {
    /**
     * @format uuid
     */
    recommendationId: string;
  };

export type GetRecommendationRecommendationsRecommendationIdPictureError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type GetRecommendationRecommendationsRecommendationIdPictureVariables = {
  pathParams: GetRecommendationRecommendationsRecommendationIdPicturePathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Get the image of a recommendation.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const fetchGetRecommendationRecommendationsRecommendationIdPicture = (
  variables: GetRecommendationRecommendationsRecommendationIdPictureVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    GetRecommendationRecommendationsRecommendationIdPictureError,
    undefined,
    {},
    {},
    GetRecommendationRecommendationsRecommendationIdPicturePathParams
  >({
    url: "/recommendation/recommendations/{recommendationId}/picture",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get the image of a recommendation.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const useGetRecommendationRecommendationsRecommendationIdPicture = <
  TData = undefined,
>(
  variables: GetRecommendationRecommendationsRecommendationIdPictureVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      undefined,
      GetRecommendationRecommendationsRecommendationIdPictureError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useHyperionContext(options);
  return reactQuery.useQuery<
    undefined,
    GetRecommendationRecommendationsRecommendationIdPictureError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/recommendation/recommendations/{recommendationId}/picture",
      operationId: "getRecommendationRecommendationsRecommendationIdPicture",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetRecommendationRecommendationsRecommendationIdPicture(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type PostRecommendationRecommendationsRecommendationIdPicturePathParams =
  {
    /**
     * @format uuid
     */
    recommendationId: string;
  };

export type PostRecommendationRecommendationsRecommendationIdPictureError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type PostRecommendationRecommendationsRecommendationIdPictureVariables =
  {
    body: Schemas.BodyCreateRecommendationImageRecommendationRecommendationsRecommendationIdPicturePost;
    pathParams: PostRecommendationRecommendationsRecommendationIdPicturePathParams;
  } & HyperionContext["fetcherOptions"];

/**
 * Add an image to a recommendation.
 *
 * **This endpoint is only usable by members of the group BDE**
 */
export const fetchPostRecommendationRecommendationsRecommendationIdPicture = (
  variables: PostRecommendationRecommendationsRecommendationIdPictureVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.AppCoreStandardResponsesResult,
    PostRecommendationRecommendationsRecommendationIdPictureError,
    Schemas.BodyCreateRecommendationImageRecommendationRecommendationsRecommendationIdPicturePost,
    {},
    {},
    PostRecommendationRecommendationsRecommendationIdPicturePathParams
  >({
    url: "/recommendation/recommendations/{recommendationId}/picture",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Add an image to a recommendation.
 *
 * **This endpoint is only usable by members of the group BDE**
 */
export const usePostRecommendationRecommendationsRecommendationIdPicture = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.AppCoreStandardResponsesResult,
      PostRecommendationRecommendationsRecommendationIdPictureError,
      PostRecommendationRecommendationsRecommendationIdPictureVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.AppCoreStandardResponsesResult,
    PostRecommendationRecommendationsRecommendationIdPictureError,
    PostRecommendationRecommendationsRecommendationIdPictureVariables
  >({
    mutationFn: (
      variables: PostRecommendationRecommendationsRecommendationIdPictureVariables,
    ) =>
      fetchPostRecommendationRecommendationsRecommendationIdPicture({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type QueryOperation =
  | {
      path: "/auth/authorize";
      operationId: "getAuthAuthorize";
      variables: GetAuthAuthorizeVariables;
    }
  | {
      path: "/auth/userinfo";
      operationId: "getAuthUserinfo";
      variables: GetAuthUserinfoVariables;
    }
  | {
      path: "/oidc/authorization-flow/jwks_uri";
      operationId: "getOidcAuthorizationFlowJwksUri";
      variables: GetOidcAuthorizationFlowJwksUriVariables;
    }
  | {
      path: "/.well-known/openid-configuration";
      operationId: "getWellKnownOpenidConfiguration";
      variables: GetWellKnownOpenidConfigurationVariables;
    }
  | {
      path: "/information";
      operationId: "getInformation";
      variables: GetInformationVariables;
    }
  | {
      path: "/privacy";
      operationId: "getPrivacy";
      variables: GetPrivacyVariables;
    }
  | {
      path: "/terms-and-conditions";
      operationId: "getTermsAndConditions";
      variables: GetTermsAndConditionsVariables;
    }
  | {
      path: "/support";
      operationId: "getSupport";
      variables: GetSupportVariables;
    }
  | {
      path: "/security.txt";
      operationId: "getSecurityTxt";
      variables: GetSecurityTxtVariables;
    }
  | {
      path: "/.well-known/security.txt";
      operationId: "getWellKnownSecurityTxt";
      variables: GetWellKnownSecurityTxtVariables;
    }
  | {
      path: "/robots.txt";
      operationId: "getRobotsTxt";
      variables: GetRobotsTxtVariables;
    }
  | {
      path: "/style/{file}.css";
      operationId: "getStyleFileCss";
      variables: GetStyleFileCssVariables;
    }
  | {
      path: "/favicon.ico";
      operationId: "getFaviconIco";
      variables: GetFaviconIcoVariables;
    }
  | {
      path: "/module-visibility/";
      operationId: "getModuleVisibility";
      variables: GetModuleVisibilityVariables;
    }
  | {
      path: "/module-visibility/me";
      operationId: "getModuleVisibilityMe";
      variables: GetModuleVisibilityMeVariables;
    }
  | {
      path: "/groups/";
      operationId: "getGroups";
      variables: GetGroupsVariables;
    }
  | {
      path: "/groups/{groupId}";
      operationId: "getGroupsGroupId";
      variables: GetGroupsGroupIdVariables;
    }
  | {
      path: "/notification/devices";
      operationId: "getNotificationDevices";
      variables: GetNotificationDevicesVariables;
    }
  | {
      path: "/notification/messages/{firebaseToken}";
      operationId: "getNotificationMessagesFirebaseToken";
      variables: GetNotificationMessagesFirebaseTokenVariables;
    }
  | {
      path: "/notification/topics";
      operationId: "getNotificationTopics";
      variables: GetNotificationTopicsVariables;
    }
  | {
      path: "/notification/topics/{topic}";
      operationId: "getNotificationTopicsTopic";
      variables: GetNotificationTopicsTopicVariables;
    }
  | {
      path: "/users/";
      operationId: "getUsers";
      variables: GetUsersVariables;
    }
  | {
      path: "/users/count";
      operationId: "getUsersCount";
      variables: GetUsersCountVariables;
    }
  | {
      path: "/users/search";
      operationId: "getUsersSearch";
      variables: GetUsersSearchVariables;
    }
  | {
      path: "/users/me";
      operationId: "getUsersMe";
      variables: GetUsersMeVariables;
    }
  | {
      path: "/users/activate";
      operationId: "getUsersActivate";
      variables: GetUsersActivateVariables;
    }
  | {
      path: "/users/migrate-mail-confirm";
      operationId: "getUsersMigrateMailConfirm";
      variables: GetUsersMigrateMailConfirmVariables;
    }
  | {
      path: "/users/{userId}";
      operationId: "getUsersUserId";
      variables: GetUsersUserIdVariables;
    }
  | {
      path: "/users/me/profile-picture";
      operationId: "getUsersMeProfilePicture";
      variables: GetUsersMeProfilePictureVariables;
    }
  | {
      path: "/users/{userId}/profile-picture";
      operationId: "getUsersUserIdProfilePicture";
      variables: GetUsersUserIdProfilePictureVariables;
    }
  | {
      path: "/advert/advertisers";
      operationId: "getAdvertAdvertisers";
      variables: GetAdvertAdvertisersVariables;
    }
  | {
      path: "/advert/me/advertisers";
      operationId: "getAdvertMeAdvertisers";
      variables: GetAdvertMeAdvertisersVariables;
    }
  | {
      path: "/advert/adverts";
      operationId: "getAdvertAdverts";
      variables: GetAdvertAdvertsVariables;
    }
  | {
      path: "/advert/adverts/{advertId}";
      operationId: "getAdvertAdvertsAdvertId";
      variables: GetAdvertAdvertsAdvertIdVariables;
    }
  | {
      path: "/advert/adverts/{advertId}/picture";
      operationId: "getAdvertAdvertsAdvertIdPicture";
      variables: GetAdvertAdvertsAdvertIdPictureVariables;
    }
  | {
      path: "/amap/products";
      operationId: "getAmapProducts";
      variables: GetAmapProductsVariables;
    }
  | {
      path: "/amap/products/{productId}";
      operationId: "getAmapProductsProductId";
      variables: GetAmapProductsProductIdVariables;
    }
  | {
      path: "/amap/deliveries";
      operationId: "getAmapDeliveries";
      variables: GetAmapDeliveriesVariables;
    }
  | {
      path: "/amap/deliveries/{deliveryId}/orders";
      operationId: "getAmapDeliveriesDeliveryIdOrders";
      variables: GetAmapDeliveriesDeliveryIdOrdersVariables;
    }
  | {
      path: "/amap/orders/{orderId}";
      operationId: "getAmapOrdersOrderId";
      variables: GetAmapOrdersOrderIdVariables;
    }
  | {
      path: "/amap/users/cash";
      operationId: "getAmapUsersCash";
      variables: GetAmapUsersCashVariables;
    }
  | {
      path: "/amap/users/{userId}/cash";
      operationId: "getAmapUsersUserIdCash";
      variables: GetAmapUsersUserIdCashVariables;
    }
  | {
      path: "/amap/users/{userId}/orders";
      operationId: "getAmapUsersUserIdOrders";
      variables: GetAmapUsersUserIdOrdersVariables;
    }
  | {
      path: "/amap/information";
      operationId: "getAmapInformation";
      variables: GetAmapInformationVariables;
    }
  | {
      path: "/booking/managers";
      operationId: "getBookingManagers";
      variables: GetBookingManagersVariables;
    }
  | {
      path: "/booking/managers/users/me";
      operationId: "getBookingManagersUsersMe";
      variables: GetBookingManagersUsersMeVariables;
    }
  | {
      path: "/booking/bookings/users/me/manage";
      operationId: "getBookingBookingsUsersMeManage";
      variables: GetBookingBookingsUsersMeManageVariables;
    }
  | {
      path: "/booking/bookings/confirmed/users/me/manage";
      operationId: "getBookingBookingsConfirmedUsersMeManage";
      variables: GetBookingBookingsConfirmedUsersMeManageVariables;
    }
  | {
      path: "/booking/bookings/confirmed";
      operationId: "getBookingBookingsConfirmed";
      variables: GetBookingBookingsConfirmedVariables;
    }
  | {
      path: "/booking/bookings/users/me";
      operationId: "getBookingBookingsUsersMe";
      variables: GetBookingBookingsUsersMeVariables;
    }
  | {
      path: "/booking/rooms";
      operationId: "getBookingRooms";
      variables: GetBookingRoomsVariables;
    }
  | {
      path: "/calendar/events/";
      operationId: "getCalendarEvents";
      variables: GetCalendarEventsVariables;
    }
  | {
      path: "/calendar/events/confirmed";
      operationId: "getCalendarEventsConfirmed";
      variables: GetCalendarEventsConfirmedVariables;
    }
  | {
      path: "/calendar/events/user/{applicantId}";
      operationId: "getCalendarEventsUserApplicantId";
      variables: GetCalendarEventsUserApplicantIdVariables;
    }
  | {
      path: "/calendar/events/{eventId}";
      operationId: "getCalendarEventsEventId";
      variables: GetCalendarEventsEventIdVariables;
    }
  | {
      path: "/calendar/events/{eventId}/applicant";
      operationId: "getCalendarEventsEventIdApplicant";
      variables: GetCalendarEventsEventIdApplicantVariables;
    }
  | {
      path: "/calendar/ical";
      operationId: "getCalendarIcal";
      variables: GetCalendarIcalVariables;
    }
  | {
      path: "/campaign/sections";
      operationId: "getCampaignSections";
      variables: GetCampaignSectionsVariables;
    }
  | {
      path: "/campaign/lists";
      operationId: "getCampaignLists";
      variables: GetCampaignListsVariables;
    }
  | {
      path: "/campaign/voters";
      operationId: "getCampaignVoters";
      variables: GetCampaignVotersVariables;
    }
  | {
      path: "/campaign/votes";
      operationId: "getCampaignVotes";
      variables: GetCampaignVotesVariables;
    }
  | {
      path: "/campaign/results";
      operationId: "getCampaignResults";
      variables: GetCampaignResultsVariables;
    }
  | {
      path: "/campaign/status";
      operationId: "getCampaignStatus";
      variables: GetCampaignStatusVariables;
    }
  | {
      path: "/campaign/stats/{sectionId}";
      operationId: "getCampaignStatsSectionId";
      variables: GetCampaignStatsSectionIdVariables;
    }
  | {
      path: "/campaign/lists/{listId}/logo";
      operationId: "getCampaignListsListIdLogo";
      variables: GetCampaignListsListIdLogoVariables;
    }
  | {
      path: "/cdr/sellers/";
      operationId: "getCdrSellers";
      variables: GetCdrSellersVariables;
    }
  | {
      path: "/cdr/users/me/sellers/";
      operationId: "getCdrUsersMeSellers";
      variables: GetCdrUsersMeSellersVariables;
    }
  | {
      path: "/cdr/online/sellers/";
      operationId: "getCdrOnlineSellers";
      variables: GetCdrOnlineSellersVariables;
    }
  | {
      path: "/cdr/sellers/{sellerId}/products/";
      operationId: "getCdrSellersSellerIdProducts";
      variables: GetCdrSellersSellerIdProductsVariables;
    }
  | {
      path: "/cdr/online/sellers/{sellerId}/products/";
      operationId: "getCdrOnlineSellersSellerIdProducts";
      variables: GetCdrOnlineSellersSellerIdProductsVariables;
    }
  | {
      path: "/cdr/sellers/{sellerId}/documents/";
      operationId: "getCdrSellersSellerIdDocuments";
      variables: GetCdrSellersSellerIdDocumentsVariables;
    }
  | {
      path: "/cdr/users/{userId}/purchases/";
      operationId: "getCdrUsersUserIdPurchases";
      variables: GetCdrUsersUserIdPurchasesVariables;
    }
  | {
      path: "/cdr/users/{userId}/signatures/";
      operationId: "getCdrUsersUserIdSignatures";
      variables: GetCdrUsersUserIdSignaturesVariables;
    }
  | {
      path: "/cdr/curriculums/";
      operationId: "getCdrCurriculums";
      variables: GetCdrCurriculumsVariables;
    }
  | {
      path: "/cdr/users/{userId}/payments/";
      operationId: "getCdrUsersUserIdPayments";
      variables: GetCdrUsersUserIdPaymentsVariables;
    }
  | {
      path: "/cdr/users/{userId}/memberships/";
      operationId: "getCdrUsersUserIdMemberships";
      variables: GetCdrUsersUserIdMembershipsVariables;
    }
  | {
      path: "/cdr/status/";
      operationId: "getCdrStatus";
      variables: GetCdrStatusVariables;
    }
  | {
      path: "/cinema/sessions";
      operationId: "getCinemaSessions";
      variables: GetCinemaSessionsVariables;
    }
  | {
      path: "/cinema/sessions/{sessionId}/poster";
      operationId: "getCinemaSessionsSessionIdPoster";
      variables: GetCinemaSessionsSessionIdPosterVariables;
    }
  | {
      path: "/flappybird/scores";
      operationId: "getFlappybirdScores";
      variables: GetFlappybirdScoresVariables;
    }
  | {
      path: "/flappybird/scores/me";
      operationId: "getFlappybirdScoresMe";
      variables: GetFlappybirdScoresMeVariables;
    }
  | {
      path: "/loans/loaners/";
      operationId: "getLoansLoaners";
      variables: GetLoansLoanersVariables;
    }
  | {
      path: "/loans/loaners/{loanerId}/loans";
      operationId: "getLoansLoanersLoanerIdLoans";
      variables: GetLoansLoanersLoanerIdLoansVariables;
    }
  | {
      path: "/loans/loaners/{loanerId}/items";
      operationId: "getLoansLoanersLoanerIdItems";
      variables: GetLoansLoanersLoanerIdItemsVariables;
    }
  | {
      path: "/loans/users/me";
      operationId: "getLoansUsersMe";
      variables: GetLoansUsersMeVariables;
    }
  | {
      path: "/loans/users/me/loaners";
      operationId: "getLoansUsersMeLoaners";
      variables: GetLoansUsersMeLoanersVariables;
    }
  | {
      path: "/ph/{paperId}/pdf";
      operationId: "getPhPaperIdPdf";
      variables: GetPhPaperIdPdfVariables;
    }
  | {
      path: "/ph/";
      operationId: "getPh";
      variables: GetPhVariables;
    }
  | {
      path: "/ph/admin";
      operationId: "getPhAdmin";
      variables: GetPhAdminVariables;
    }
  | {
      path: "/ph/{paperId}/cover";
      operationId: "getPhPaperIdCover";
      variables: GetPhPaperIdCoverVariables;
    }
  | {
      path: "/phonebook/associations/";
      operationId: "getPhonebookAssociations";
      variables: GetPhonebookAssociationsVariables;
    }
  | {
      path: "/phonebook/roletags";
      operationId: "getPhonebookRoletags";
      variables: GetPhonebookRoletagsVariables;
    }
  | {
      path: "/phonebook/associations/kinds";
      operationId: "getPhonebookAssociationsKinds";
      variables: GetPhonebookAssociationsKindsVariables;
    }
  | {
      path: "/phonebook/associations/{associationId}/members/";
      operationId: "getPhonebookAssociationsAssociationIdMembers";
      variables: GetPhonebookAssociationsAssociationIdMembersVariables;
    }
  | {
      path: "/phonebook/associations/{associationId}/members/{mandateYear}";
      operationId: "getPhonebookAssociationsAssociationIdMembersMandateYear";
      variables: GetPhonebookAssociationsAssociationIdMembersMandateYearVariables;
    }
  | {
      path: "/phonebook/member/{userId}";
      operationId: "getPhonebookMemberUserId";
      variables: GetPhonebookMemberUserIdVariables;
    }
  | {
      path: "/phonebook/associations/{associationId}/picture";
      operationId: "getPhonebookAssociationsAssociationIdPicture";
      variables: GetPhonebookAssociationsAssociationIdPictureVariables;
    }
  | {
      path: "/tombola/raffles";
      operationId: "getTombolaRaffles";
      variables: GetTombolaRafflesVariables;
    }
  | {
      path: "/tombola/group/{groupId}/raffles";
      operationId: "getTombolaGroupGroupIdRaffles";
      variables: GetTombolaGroupGroupIdRafflesVariables;
    }
  | {
      path: "/tombola/raffles/{raffleId}/stats";
      operationId: "getTombolaRafflesRaffleIdStats";
      variables: GetTombolaRafflesRaffleIdStatsVariables;
    }
  | {
      path: "/tombola/raffles/{raffleId}/logo";
      operationId: "getTombolaRafflesRaffleIdLogo";
      variables: GetTombolaRafflesRaffleIdLogoVariables;
    }
  | {
      path: "/tombola/pack_tickets";
      operationId: "getTombolaPackTickets";
      variables: GetTombolaPackTicketsVariables;
    }
  | {
      path: "/tombola/raffles/{raffleId}/pack_tickets";
      operationId: "getTombolaRafflesRaffleIdPackTickets";
      variables: GetTombolaRafflesRaffleIdPackTicketsVariables;
    }
  | {
      path: "/tombola/tickets";
      operationId: "getTombolaTickets";
      variables: GetTombolaTicketsVariables;
    }
  | {
      path: "/tombola/users/{userId}/tickets";
      operationId: "getTombolaUsersUserIdTickets";
      variables: GetTombolaUsersUserIdTicketsVariables;
    }
  | {
      path: "/tombola/raffles/{raffleId}/tickets";
      operationId: "getTombolaRafflesRaffleIdTickets";
      variables: GetTombolaRafflesRaffleIdTicketsVariables;
    }
  | {
      path: "/tombola/prizes";
      operationId: "getTombolaPrizes";
      variables: GetTombolaPrizesVariables;
    }
  | {
      path: "/tombola/raffles/{raffleId}/prizes";
      operationId: "getTombolaRafflesRaffleIdPrizes";
      variables: GetTombolaRafflesRaffleIdPrizesVariables;
    }
  | {
      path: "/tombola/prizes/{prizeId}/picture";
      operationId: "getTombolaPrizesPrizeIdPicture";
      variables: GetTombolaPrizesPrizeIdPictureVariables;
    }
  | {
      path: "/tombola/users/cash";
      operationId: "getTombolaUsersCash";
      variables: GetTombolaUsersCashVariables;
    }
  | {
      path: "/tombola/users/{userId}/cash";
      operationId: "getTombolaUsersUserIdCash";
      variables: GetTombolaUsersUserIdCashVariables;
    }
  | {
      path: "/recommendation/recommendations";
      operationId: "getRecommendationRecommendations";
      variables: GetRecommendationRecommendationsVariables;
    }
  | {
      path: "/recommendation/recommendations/{recommendationId}/picture";
      operationId: "getRecommendationRecommendationsRecommendationIdPicture";
      variables: GetRecommendationRecommendationsRecommendationIdPictureVariables;
    };
